## 3993	星号阵列-24	https://www.xujcoj.com/home/problem/detail/3993
**答案：**
#include<iostream>
using namespace std;
int main()
{
    int n;
    cin >> n;
    while (n--)
    {
        int a, b;
        cin >> a;
        while (true)
        {
            for (int i = 0; i < a; i++)
            {
                cout << "*";
            }
            cout << endl;
            if (a == 1) break;
            for (b = 2; b * b <= a; b++)
            {
                if (a % b == 0) break;
            }
            if (a % b == 0) a = a / b;
            else a = 1;
        }
    }
    return 0;
}
**解析**：
1. 输入部分
先输入测试案例数量 n，表示需要处理的星号阵列组数。
每组案例输入一个正整数 a，表示第一行星号的数量（a ≤ 100）。
2. 策略与步骤
外层 while (n--) 循环
用于依次处理每一组测试案例。
读取当前案例的初始星号数量 a。
使用 while(true) 循环逐行输出星号阵列：
每一轮循环输出当前行的 a 个星号。
输出完成后换行。
终止条件判断：
如果当前星号数量 a == 1，说明已经到达最后一行，跳出循环。
计算下一行星号数量：
从 b = 2 开始遍历，寻找 a 的最小因子（不包含 1 和自身）。
一旦找到因子 b，则 a / b 即为 a 的最大非自身因子。
若在遍历过程中未找到因子，说明 a 是质数，则下一行星号数量直接设为 1。
更新 a 的值，进入下一轮循环，继续输出星号。
## 2177	平行四边形	https://www.xujcoj.com/home/problem/detail/2177
**答案：**
#include<iostream>
using namespace std;
int main()
{
	int n;
	cin >> n;
	while (n--)
	{
		int x1, y1, x2, y2, x3, y3;
		cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;
		int x4 = x1 + x3 - x2;
		int y4 = y1 + y3 - y2;
		cout << x4 << " " << y4 << endl;
	}
	return 0;
}
**解析**：
1. 输入部分
先输入测试案例数量 n，表示需要处理的案例组数。
每组案例输入 6 个整数：
x1, y1, x2, y2, x3, y3，分别表示三个已知点的坐标。
2. 策略与步骤
外层 while (n--) 循环
用于依次处理每一组测试案例。
读取三个已知点的坐标：
第一个点：(x1, y1)
第二个点：(x2, y2)
第三个点：(x3, y3)
根据向量或平行四边形性质计算第四个点：
利用公式：
x4 = x1 + x3 - x2
y4 = y1 + y3 - y2
该计算方式等价于：
从点 (x1, y1) 出发，加上向量 (x3 - x2, y3 - y2)，得到第四个点 (x4, y4)。
输出计算得到的第四个点坐标：
按格式输出 x4 y4
每组结果占一行。
3. 注意事项
每组测试案例独立计算并输出结果，输出后立即换行。
输入和输出均为整数运算，不涉及浮点数误差问题。
不同测试案例之间不额外输出空行，结果连续输出。
核心逻辑在于坐标计算公式，利用已知三点推导第四点。
## 3971	日期-2	https://www.xujcoj.com/home/problem/detail/3971
**答案：**
#include<iostream>
using namespace std;
bool isLeap(int y)
{
	return y % 400 == 0 && y % 3200 != 0 || y % 4 == 0 && y % 100 != 0;
}
int main()
{
	int days[] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
	int n;
	cin >> n;
	while (n--)
	{
		int y, m, d;
		cin >> y >> m >> d;
		if (isLeap(y))
		{
			days[2] = 29;
			cout << 366 << " " << days[m] << endl;
		}
		else
		{
			days[2] = 28;
			cout << 365 << " " << days[m] << endl;
		}
	}
	return 0;
}
**解析**：
1输入部分
首先输入一个正整数 n，表示有多少组测试案例。
每组案例输入三个正整数：
第一个整数表示年份 y
第二个整数表示月份 m
第三个整数表示日期 d（日期在本题中仅用于输入，不参与计算）
2策略与步骤
循环处理每组案例：
按照输入的案例数量依次处理每一组数据。
判断年份是否为闰年：
如果年份是400的倍数且不是3200的倍数，则为闰年。
如果年份是4的倍数且不是100的倍数，也为闰年。
其他情况为平年。
确定月份天数：
平年每月天数固定，2月为28天，其余月份分别为31或30天。
闰年2月天数为29天，其余月份不变。
输出结果：
对每组案例，先输出该年的总天数（平年365天，闰年366天），再输出该月的天数。
两个整数之间用空格分隔，每组案例输出占一行。
3注意事项
每组案例独立计算和输出，互不影响。
输入和输出均为整数运算，不涉及浮点数问题。
输出顺序与输入顺序严格对应，每组输出后立即换行，不额外添加空行。
核心逻辑在于闰年判断规则和月份天数确定。
## 3432	没出现的数字	https://www.xujcoj.com/home/problem/detail/3432
**答案：**
#include<iostream>
using namespace std;
int main()
{
	int n;
	cin >> n;
	while (n--)
	{
		int m, cnt = 0;
		bool a[10] = { 0 };
		cin >> m;
		while (m > 0)
		{
			a[m % 10] = true;
			m = m / 10;
		}
		for (int i = 0; i < 10; i++)
		{
			cnt += a[i];
		}
		cout << 10 - cnt << endl;
	}
	return 0;
}
**解析**：
1 输入部分
首先输入一个正整数 n，表示测试案例的数量。
接下来有 n 组测试案例，每组案例输入一个正整数 m（m ≤ 1e9）。
2 策略与步骤
循环处理每组案例：
使用外层循环依次读取每一组输入，并对每组数据单独计算。
初始化计数和数组：
定义一个长度为 10 的布尔数组 a[10]，每个元素表示数字 0~9 是否出现过，初始值全部为 false。
定义计数变量 cnt 用于统计出现过的数字数量。
判断每一位数字是否出现：
对当前正整数 m：
取 m % 10 得到最后一位数字
将对应数组元素 a[数字] 标记为 true
用 m / 10 去掉最后一位，继续处理剩余数字
直到 m 为 0 为止，保证每一位数字都被检查。
统计出现过的数字数量：
遍历布尔数组 a[0]~a[9]
对每个 true 元素计数，累加到 cnt
cnt 表示数字 0~9 中出现过的数量。
计算未出现的数字数量：
总共有 10 个数字，未出现的数量 = 10 - cnt
输出结果，每组案例占一行。
3 输出部分
对每组案例，输出一个整数，表示正整数 m 中 未出现过的数字数量。
输出后立即换行，不额外添加空行。
4 注意事项
每组案例独立计算，互不影响。
数组 a[10] 的初始值必须为 false，以便正确统计。
使用 % 和 / 运算依次取出每一位数字，保证数字不重复统计。
输出顺序与输入顺序一致。
## 2645	三天花完的钱	https://www.xujcoj.com/home/problem/detail/2645
**答案：**
#include<iostream>
using namespace std;
int main()
{
	int n;
	cin >> n;
	while (n--)
	{
		int a;
		cin >> a;
		int cnt = 0;
		for (int i = 1; i <= (a - 3) / 3; i++)//i表示第一天花的钱
		{
			int m;
			if ((a - i) % 2 != 0)
			{
				m = (a - i) / 2;
			}
			else
			{
				m = (a - i) / 2 - 1;
			}
			//for (int j = i + 1; j <= m; j++)
			//{
			//	cnt++;
			//}
			cnt = cnt + (m - i);
		}
		cout << cnt << endl;
	}
	return 0;
}
**解析**：
1️⃣ 输入部分
首先输入一个正整数 n，表示测试案例的数量。
每组案例输入一个正整数 a，表示奖学金总额（a <= 1500）。
2️⃣ 策略与步骤
循环处理每组案例：
使用外层循环依次处理每一组输入。
初始化计数：
定义计数变量 cnt，用来统计不同的花钱方式。
确定第一天花的钱：
用变量 i 表示第一天花的钱，取值范围从 1 到 (a-3)/3：
原因：第一天花的钱必须小于第二天和第三天，每天至少花1元，所以最大不超过 (a-3)/3。
确定第二天花的钱范围：
剩下的钱为 a - i
第二天花的钱 j 必须大于 i 且小于第三天的钱。
根据总额计算第二天的最大值 m：
如果 (a - i) 为奇数：m = (a - i) / 2
如果 (a - i) 为偶数：m = (a - i) / 2 - 1
这样保证第三天花的钱比第二天多，并且每天花的钱都是正整数。
统计每种组合数量：
第二天花的钱 j 从 i + 1 到 m
组合数就是 m - i
将其累加到 cnt，统计所有可能的组合。
3️⃣ 输出部分
对每组案例，输出统计的组合数 cnt。
每组输出占一行。
4️⃣ 注意事项
每组案例独立计算，互不影响。
每天花的钱必须是正整数，并且严格递增：第一天 < 第二天 < 第三天。
最大值的计算通过 (a - i)/2 或 (a - i)/2 - 1 来保证第三天至少比第二天多 1 元。
输出顺序与输入顺序一致，每组输出后立即换行。
## 2016	星号阵列-14	https://www.xujcoj.com/home/problem/detail/2016
**答案：**
#include <iostream>
using namespace std;
int main() {
	int n;
	cin >> n;
	while (n--) {
		int m;
		cin >> m; 
		for (int i = 0; i < m; i++) {
			cout << "*";
		}
		cout << endl;
		for (int i = 0; i < m-1; i++) {
				cout << "*";
				for (int j = 0; j < m - i - 3; j++) {
					cout << " ";
				}
				if (i < m -2) {
					cout << "*";
				}
				cout << endl;
		}
	}
}
**解析**：
1️⃣ 输入部分
首先输入一个正整数 n，表示测试案例的数量。
每组案例输入一个正整数 m（m >= 3），表示倒三角形的行数或宽度。
2️⃣ 策略与步骤
外层循环处理每组案例：
使用 while (n--) 循环依次处理每组输入。
打印第一行星号：
第一行输出 m 个连续的星号 *
这一行表示倒三角形最宽的顶部
输出完后换行
打印倒三角形的中间部分：
使用外层循环 for i = 0 到 m-2：
每一行至少打印一个星号（左边的 *）
中间打印空格，数量 = m - i - 3
这个空格数量随行数递减，使星号逐渐靠近形成倒三角形
如果当前行不是最后一行（即 i < m-2），再打印一个右边的星号
每行结束后换行
这样可以得到第一行星号之外每行两端的星号和中间空格排列
注意最后一行只有一个星号，符合倒三角形形状
3️⃣ 输出部分
每组案例输出一个倒三角形，要求：
每行星号之间的空格正确
每行最后一个星号后不能有多余空格
每组倒三角形输出完后自动换行
4️⃣ 注意事项
每组案例独立计算和输出，互不影响。
第一行是完整的连续星号行，其余行两端星号，中间空格逐渐减少。
星号和空格的数量计算要确保最后一行只剩一个星号，没有多余空格。
输出顺序严格对应输入顺序。
## 4304	比日期	https://www.xujcoj.com/home/problem/detail/4304
**答案：**
#include<iostream>
using namespace std;
int main()
{
	int y1, m1, d1, y2, m2, d2;
	cin >> y1 >> m1 >> d1 >> y2 >> m2 >> d2;
	if (y1 == y2 && m1 == m2 && d1 == d2)
	{
		cout << "Same";
	}
	else if (y1 < y2 || y1 == y2 && m1 < m2 || y1 == y2 && m1 == m2 && d1 < d2)
	{
		cout << "Early";
	}
	else
	{
		cout << "Late";
	}
	return 0;
}
**解析**：
1️⃣ 输入部分
首先输入两个日期，每个日期由三个整数表示：
第一个日期：y1（年份）、m1（月份）、d1（日）
第二个日期：y2（年份）、m2（月份）、d2（日）
保证输入的日期都是合法的，不需要进行额外验证。
输入顺序严格为：第一行第一个日期，第二行第二个日期。
2️⃣ 策略与步骤
(1) 判断两个日期是否相同
条件：年份、月份、日期都相同。
如果完全相同，则输出 "Same"。
这是最先判断的情况，确保相同日期优先处理。
(2) 判断第一个日期是否更早
条件逻辑分三步：
第一个日期年份比第二个日期小 → 第一个日期早。
年份相同，但第一个日期月份比第二个日期小 → 第一个日期早。
年份和月份都相同，但第一个日期的日比第二个日期小 → 第一个日期早。
只要满足上述任意一种情况，就输出 "Early"。
(3) 判断第一个日期是否更晚
如果既不是相同，也不是更早，那么剩下的情况就是：
第一个日期比第二个日期晚 → 输出 "Late"。
3️⃣ 输出部分
根据判断结果，输出三种可能：
"Same"：两个日期完全相同。
"Early"：第一个日期比第二个日期早。
"Late"：第一个日期比第二个日期晚。
输出要求：
仅输出对应的字符串
不要换行，输出在同一行即可
4️⃣ 注意事项
日期比较按 年 → 月 → 日 的顺序逐层判断。
条件组合使用逻辑或时，需要确保优先级正确。
输出严格按照要求，不要添加额外空格或换行。
逻辑清晰，分三种情况处理，使代码易于理解和维护。
## 1500	画矩形	https://www.xujcoj.com/home/problem/detail/1500
**答案：**
#include<iostream>
using namespace std;
int main()
{
	int m, n, d;
	char c;
	cin >> m >> n >> c >> d;
	for (int i = 1; i <= m; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			if (d == 0)
			{
				if (i == 1 || i == m || j == 1 || j == n)cout << c;
				else cout << " ";
			}
			else if (d == 1)
			{
				cout << c;
			}
		}
		cout << endl;
	}
	return 0;
}
**解析**：
1️⃣ 输入部分
程序只处理一组案例。
输入包含四个元素：
m：矩形的高度（行数），满足 3 <= m <= 10
n：矩形的宽度（列数），满足 3 <= n <= 10
c：用于绘制矩形的字符
d：整数 0 或 1，表示矩形类型：
0 → 空心矩形
1 → 实心矩形
输入顺序严格为：m n c d
2️⃣ 策略与步骤
(1) 外层循环控制行
使用外层循环从 1 到 m 遍历每一行。
每次循环表示矩形的一行输出。
(2) 内层循环控制列
在每一行内，使用内层循环从 1 到 n 遍历每一列。
根据矩形类型判断输出内容：
空心矩形 (d == 0)
条件：
当前行是第一行或最后一行 → 输出绘制字符 c
当前列是第一列或最后一列 → 输出绘制字符 c
其他位置 → 输出空格 " "
逻辑说明：
第一行和最后一行构成矩形的上下边界。
第一列和最后一列构成矩形的左右边界。
中间部分用空格填充，形成空心效果。
实心矩形 (d == 1)
条件：
无需判断行列，直接输出绘制字符 c
逻辑说明：
每个位置都输出字符，形成实心矩形。
(3) 每行结束换行
每打印完一行列后，输出换行符 endl 或 \n。
确保矩形按行正确排列。
3️⃣ 输出部分
输出结果为一个矩形：
行数 = m
列数 = n
符号 = c
空心或实心由 d 决定
每行末尾不加多余空格，最后一行也要换行。
4️⃣ 注意事项
确保行列循环边界正确，防止索引超出。
空心矩形中间的空格数量随矩形大小自动调整。
输入保证合法，无需额外验证。
输出严格按照矩形形状排列，保持整齐。
## 4357	斐波那契程序员-3	https://www.xujcoj.com/home/problem/detail/4357
**答案：**
#include<iostream>
using namespace std;
//返回a数组前d项之和
int getSum(int a[], int d)
{
	int sum = 0;
	for (int i = 0; i < d; i++)
	{
		sum += a[i];
	}
	return sum;
}
int main()
{
	int n;
	cin >> n;
	while (n--)
	{
		int a[10], m;
		for (int i = 0; i < 10; i++)
		{
			cin >> a[i];
		}
		cin >> m;
		if (m <= 10) cout << getSum(a, m) << endl;
		else
		{
			int pre = getSum(a, 10), cur;
			for (int i = 11; i <= m; i++)
			{
				cur = pre % 100;
				pre += cur;
			}
			cout << pre << endl;
		}
	}
	return 0;
}
**解析**：
1️⃣ 输入部分
首先输入一个正整数 n，表示案例的数量（n ≤ 100）。
每组案例输入：
前十天每天的代码量，10 个非负整数，每个小于 100。
一个正整数 m，表示总共要统计的天数（1 ≤ m ≤ 10 万）。
输入顺序严格为：前十天代码量 → 总天数 m。
2️⃣ 策略与步骤
(1) 前十天总和
对于每组案例，先计算前十天的总代码量 pre。
如果 m ≤ 10，只需要求前 m 天的和即可，不需要考虑后续累积。
(2) 第 11 天及之后的代码量
从第 11 天开始，每天的代码量 = 前面所有天写的代码总和的 末两位数。
计算方法：cur = pre % 100
然后把当天的代码量加入总和：pre += cur
持续循环直到第 m 天。
(3) 特殊情况处理
当 m <= 10：
直接求前 m 天的和，不进入循环。
当 m > 10：
先计算前十天总和
循环从第 11 天到第 m 天，每天累加末两位数
保证总和精确，不会因为大数导致错误。
3️⃣ 输出部分
每组案例输出一个整数：
表示该程序员在总共 m 天里写的代码总量
每组输出结束换行
输出顺序严格按照输入顺序
4️⃣ 注意事项
计算第 11 天及之后的代码量时，必须取前面总和的 末两位数。
当 m 非常大（如 10 万），循环仍然可以顺序累加，因为每次只需 % 100 操作。
输入保证合法，无需额外检查。
前十天数组的下标从 0 开始，循环计算总和时注意范围。
输出总和必须包含前十天和后续所有天的累加量。
## 4359	满足条件的数字和	https://www.xujcoj.com/home/problem/detail/4359
**答案：**
#include<iostream>
using namespace std;
int main()
{
	int n;
	cin >> n;
	while (n--)
	{
		int m, p, a[100], sum = 0;
		cin >> m >> p;
		for (int i = 0; i < m; i++)
		{
			cin >> a[i];
		}
		for (int i = 0; i < m; i++)
		{
			int cnt = 0;
			for (int j = 0; j < m; j++)
			{
				if (i != j && a[j] % a[i] == 0)
				{
					cnt++;
				}
			}
			if (cnt >= p) sum += a[i];
		}
		cout << sum << endl;
	}
	return 0;
}
**解析**：
1️⃣ 输入部分
首先输入一个正整数 n，表示案例数量（n ≤ 100）。
每组案例输入：
两个正整数 m 和 p：
m：数字的个数（m ≤ 100）
p：要求该数字至少是 其他 p 个数字的因子
接着输入 m 个正整数，每个数字 ≤ 100。
输入顺序严格为：m p → m 个数字。
2️⃣ 策略与步骤
(1) 遍历每个数字
对于每组案例，依次检查每个数字 a[i] 是否满足条件：
条件：a[i] 至少是 **其他 p 个数字的因子`
注意 是其他数字，不能把自己算作因子检查对象。
(2) 统计因子数量
对当前数字 a[i]：
遍历数组中所有数字 a[j]
如果 i != j 且 a[j] % a[i] == 0 → 说明 a[i] 是 a[j] 的因子
将满足条件的数字个数记为 cnt
(3) 判断并累加
如果 cnt ≥ p → 当前数字符合条件
将其加入总和 sum
遍历完所有数字后，得到该组案例的总和
3️⃣ 输出部分
每组案例输出一个整数：
表示满足条件的数字之和
每组输出完换行
输出顺序严格按照输入顺序
4️⃣ 注意事项
因子统计时不能把当前数字自己算进去
重复数字也可以计算，例如 [4, 4, 8] 中两个 4 都可以满足条件
数字最大 100，p 最大 10，直接使用双重循环效率足够
输出总和必须包含所有满足条件的数字
## 4448	英文字母	https://www.xujcoj.com/home/problem/detail/4448
**答案：**
#include <iostream>
#include <string>
using namespace std;
int main()
{
    int n;
    cin >> n;
    while (n--)
    {
        string a;
        cin >> a;
        int f[26] = {0}, cnt = 0;
        // 经典三个表达式 for 循环
        for (int i = 0; i < a.length(); i++)
        {
            char b = a[i];
            if (isupper(b)) f[b - 'A'] = 1;
            else f[b - 'a'] = 1;
        }
        for (int i = 0; i < 26; i++)
        {
            cnt += f[i];
        }
        if (cnt == 26) cout << "Yes" << endl;
        else cout << "No" << endl;
    }
    return 0;
}
**解析**：
1️⃣ 输入部分
首先输入一个正整数 n，表示案例数量（n ≤ 100）。
每组案例输入：
一段只包含大写或小写字母的字符串
字符串长度 ≤ 1000
输入顺序严格为：每组案例一行字符串
2️⃣ 策略与步骤
(1) 初始化计数数组
使用长度为 26 的数组 f[26] 来记录每个字母是否出现：
下标 0 → 'a' 或 'A'
下标 1 → 'b' 或 'B'
…
下标 25 → 'z' 或 'Z'
初始化数组所有元素为 0，表示初始状态下字母未出现。
(2) 遍历字符串统计字母出现情况
对字符串中的每个字符 b：
如果是大写字母 → f[b - 'A'] = 1
如果是小写字母 → f[b - 'a'] = 1
这样可以把大写和小写统一映射到数组下标，实现大小写无关的统计。
(3) 统计出现的字母总数
遍历数组 f，累加每个元素：
出现过的字母计为 1
未出现的字母计为 0
计算总数 cnt，表示字符串中出现的不同字母数。
(4) 判断是否包含全部 26 个字母
如果 cnt == 26 → 输出 "Yes"，表示字符串包含所有英文字母
否则 → 输出 "No"，表示有缺失
3️⃣ 输出部分
每组案例输出：
"Yes" 或 "No"
输出顺序严格对应输入顺序
每组输出后换行
4️⃣ 注意事项
大小写字母视为相同字母进行统计
字符串可能很长，但使用数组映射统计效率高
输出必须严格符合要求，不要多余空格或换行
## 3767	优秀的成绩	https://www.xujcoj.com/home/problem/detail/3767
**答案：**
#include<iostream>
using namespace std;
int main()
{
	int a, b, c;
	cin >> a >> b >> c;
	if (a + b + c >= 90 * 3 && a >= 85 && b >= 85 && c >= 85)
	{
		cout << "Excellent";
	}
	else
	{
		cout << "Not Excellent";
	}
	return 0;
}
**解析**：
1️⃣ 输入部分
输入一行，包含三个整数，分别表示三门课程的成绩：
a：第一门课程成绩
b：第二门课程成绩
c：第三门课程成绩
成绩范围假设为合法整数（通常 0~100）
输入顺序严格为：三门课成绩依次输入
2️⃣ 策略与步骤
(1) 判断单科成绩条件
每门课成绩必须不低于 85 分
条件：
a >= 85
b >= 85
c >= 85
(2) 判断平均分条件
三门课平均分必须不低于 90 分
计算方法：
(a + b + c) / 3 >= 90
为避免浮点运算，可以写作总分判断：
a + b + c >= 90 * 3
(3) 综合条件判断
两个条件同时满足时：
每门课 ≥ 85
三门课总分 ≥ 270
则输出 "Excellent"
否则输出 "Not Excellent"
3️⃣ 输出部分
输出要求：
如果满足优秀条件 → "Excellent"
如果不满足 → "Not Excellent"
不要换行，直接输出字符串即可
4️⃣ 注意事项
可以用总分判断平均分，避免浮点数运算
条件顺序可以任意，但需要同时满足两个条件
输出字符串必须严格符合要求，不要多余空格或换行
## 4302	数的乘积	https://www.xujcoj.com/home/problem/detail/4302
**答案：**
#include<iostream>
using namespace std;
int main()
{
	int a, neg = 0, pos = 0;
	for (int i = 0; i < 4; i++)
	{
		cin >> a;
		if (a > 0) pos++;
		else if (a < 0) neg++;
	}
	if (pos >= 1 && neg >= 1)
	{
		cout << "Yes";
	}
	else
	{
		cout << "No";
	}
	return 0;
}
**解析**：
1️⃣ 输入部分
输入四个整数，分别记为 a1, a2, a3, a4
输入顺序严格按照题目要求
数值可以为正数、负数或零
2️⃣ 策略与步骤
(1) 统计正数和负数数量
初始化两个计数器：
pos → 统计正数个数
neg → 统计负数个数
遍历四个整数：
如果数字 > 0 → pos++
如果数字 < 0 → neg++
如果数字 = 0 → 不计入
(2) 判断是否存在乘积为负数的组合
两个整数的乘积为负数的条件：
一个正数 × 一个负数 → 乘积为负
因此判断条件：
pos >= 1 且 neg >= 1 → 存在乘积为负数的组合
(3) 输出结果
如果满足条件 → 输出 "Yes"
否则 → 输出 "No"
3️⃣ 输出部分
输出要求：
不要换行
字符串严格为 "Yes" 或 "No"
4️⃣ 注意事项
零不能参与产生负数乘积，因为：
0 × 任何数 = 0 → 不为负
只要存在至少一个正数和至少一个负数即可满足条件
数量统计方法比枚举所有组合更高效
## 3361	静默的质数	https://www.xujcoj.com/home/problem/detail/3361
**答案：**
#include<iostream>
#include<cmath>
using namespace std;
bool isPrime(int n)
{
	if (n < 2)
	{
		return false;
	}
	for (int i = 2; i <= sqrt(n); i++)
	{
		if (n % i == 0)
		{
			return false;
		}
	}
	return true;
}
int main()
{
	int n;
	cin >> n;
	while (n--)
	{
		int m, a, cnt = 0;
		cin >> m >> a;
		for (int i = a; i < a + m; i++)
		{
			if (isPrime(i)) cnt++;
		}
		cout << cnt << endl;
	}
	return 0;
}
**解析**：
1️⃣ 输入部分
首先输入一个正整数 n，表示案例数量（n ≤ 20）。
每组案例输入两个正整数：
m：同学数量（m ≤ 100）
a：1号同学想的数字（2 ≤ a ≤ 10000，且保证不是质数）
输入顺序严格为：m a
2️⃣ 策略与步骤
(1) 定义判断质数函数
函数 isPrime(n) 用于判断整数 n 是否为质数：
如果 n < 2 → 返回 false
遍历从 2 到 √n 的整数 i：
如果 n % i == 0 → n 不是质数，返回 false
遍历完成仍未被整除 → n 是质数，返回 true
(2) 遍历同学数字
1号同学喊出的数字为 a
每位同学得到前一个数字并加 1：
2号同学数字 = a + 1
3号同学数字 = a + 2
…
第 m 名同学数字 = a + (m-1)
遍历从 i = a 到 i = a + m - 1 的每个数字
(3) 统计质数
对每个数字调用 isPrime(i)：
如果返回 true → 该同学数字为质数 → cnt++
最终 cnt 就是游戏中数字为质数的同学人数
3️⃣ 输出部分
每组案例输出一个整数：
表示数字是质数的同学人数
每组输出完换行
输出顺序严格按照输入顺序
## 4446	打卡时间	https://www.xujcoj.com/home/problem/detail/4446
**答案：**
#include <iostream>
using namespace std;
int main()
{
    int a, b, am, bm, sum = 0;
    cin >> a;
    am = a / 100 * 60 + a % 100;
    for (int i = 0; i < 5; i++)
    {
        cin >> b;
        bm = b / 100 * 60 + b % 100;
        if (bm > am) sum += (bm - am);
    }
    cout << sum;
    return 0;
}
**解析**：
1️⃣ 输入部分
第一行输入一个 4 位整数 a，表示企业规定的上班打卡时间：
前两位表示小时（0~23）
后两位表示分钟（0~59）
例如 0830 → 08:30
第二行输入 5 个 4 位整数，表示员工一周 5 天的打卡时间：
分别对应星期一到星期五
格式同样是 HHMM
2️⃣ 策略与步骤
(1) 将时间转换为分钟数
规定上班时间 a 转换为分钟数：
am = a / 100 * 60 + a % 100
a / 100 → 小时
a % 100 → 分钟
方便直接进行分钟比较
每天打卡时间 b 也转换为分钟数：
bm = b / 100 * 60 + b % 100
(2) 计算迟到分钟数
对每一天：
如果 bm > am → 迟到
迟到分钟数 = bm - am
累加到总迟到时间 sum
如果 bm <= am → 未迟到
不累加
(3) 累加 5 天的迟到时间
循环 5 次，统计整个工作周的迟到分钟数
最终得到总迟到时间 sum
3️⃣ 输出部分
输出一个整数：
表示一周 5 天的总迟到分钟数
不要换行，直接输出整数
4️⃣ 注意事项
时间必须转换为分钟数再比较，避免直接用 HHMM 整数比较导致错误
如果打卡早于或等于上班时间 → 不算迟到
输入保证合法（4 位整数，0~2359）
输出严格为总分钟数整数，不要多余字符
## 2883	互质问题	https://www.xujcoj.com/home/problem/detail/2883
**答案：**
#include<iostream>
using namespace std;
int getGCD(int a, int b)
{
	return b == 0 ? a : getGCD(b, a % b);
}
int main()
{
	int n;
	cin >> n;
	while (n--)
	{
		int m, p;
		cin >> m;
		int a[2000], c[2000];
		for (int i = 0; i < m; i++)
		{
			cin >> a[i];
		}
		c[0] = 1;//第0轮，看到下标0号数字，最后一个选中的数字是下标0号数字，最多可以保留1个数字
		int max = c[0];
		for (int i = 1; i < m; i++)
		{
			//第i轮，看到下标i号数字
			//最后一个选中的数字是下标i号数字，至少可以保留这1个数字（前面的数字都不要）
			c[i] = 1;
			for (int j = 0; j < i; j++)
			{
				//如果下标i号数字与下标j号数字互质，且选中j的情况下能获得更多的数字，
				//那么就选中j且选中i，更新c[i]的值
				if (c[j] >= c[i] && getGCD(a[i], a[j]) == 1)
				{
					c[i] = c[j] + 1;
				}
			}
			if (c[i] > max) max = c[i];
			//第i轮，看到下标i号数字，
			//最后一个选中的数字不是下标i号数字，那么c[0]~c[i-1]的值都不用改变（没增加选中的数字）
		}
		cout << m - max << endl;
	}
	return 0;
}
**解析**：
1️⃣ 输入部分
首先输入一个正整数 n，表示案例数量（n ≤ 20）。
每组案例输入：
一个正整数 m，表示数字的数量（2 ≤ m ≤ 2000）
接着输入 m 个正整数，表示排成一行的数字，每个数字 ≤ 100 万
2️⃣ 策略与步骤
(1) 定义求最大公因数函数
函数 getGCD(a, b) 用于求两个数字的最大公因数：
使用递归实现欧几里得算法：
getGCD(a, b) = getGCD(b, a % b)
当 b == 0 → 返回 a
判断两个数字是否互质：
getGCD(a, b) == 1 → 互质
否则 → 不互质
(2) 使用动态规划求最长互质子序列
定义数组 c[i]：
表示以第 i 个数字结尾的最长互质子序列长度
初始化：
c[0] = 1 → 第 0 个数字自己可以保留，最长子序列长度为 1
遍历每个数字 i（从 1 到 m-1）：
初始值 c[i] = 1 → 至少可以单独保留自己
遍历之前的数字 j（0 到 i-1）：
如果 a[i] 与 a[j] 互质 (getGCD(a[i], a[j]) == 1)
且选择 j 时能得到更长子序列 (c[j] >= c[i])
更新 c[i] = c[j] + 1
更新全局最大值 max → max = max(c[i], max)
动态规划逻辑：
每个 c[i] 记录以 i 结尾的最长互质子序列
最终全局 max 就是可以保留的最多数字数量
(3) 计算最少需要删除的数字
最少删除数量 = 总数字数 - 最长互质子序列长度
m - max
3️⃣ 输出部分
每组案例输出一个整数：
表示最少需要删除的数字数量
每组输出完换行
输出顺序严格对应输入顺序
## 3819	谁是大佬	https://www.xujcoj.com/home/problem/detail/3819
**答案：**
#include<iostream>
using namespace std;
int main()
{
	int n;
	cin >> n;
	while (n--)
	{
		int m, max = -1, maxno = -1;
		cin >> m;
		for (int i = 1; i <= m; i++)
		{
			int a;
			cin >> a;
			if (a > max)
			{
				max = a;
				maxno = i;
			}
		}
		cout << maxno << endl;
	}
	return 0;
}
**解析**：
1️⃣ 输入部分
首先输入一个正整数 n，表示案例数量（n ≤ 10）。
每组案例输入：
一个正整数 m，表示学生数量（m ≤ 100）
接着输入 m 个整数，表示 1 号到 m 号学生的期中考试成绩（0~100）
输入顺序严格为：m → m 个成绩
2️⃣ 策略与步骤
(1) 初始化变量
max → 用于记录当前最高分，初始值设为 -1（保证小于所有成绩）
maxno → 记录最高分对应的学生学号，初始值 -1
(2) 遍历学生成绩
从 i = 1 到 i = m 遍历每个学生：
读取学生成绩 a
如果 a > max：
更新最高分 max = a
更新学号 maxno = i
遍历完成后，maxno 即为成绩最高的学生学号
3️⃣ 输出部分
每组案例输出一个整数：
表示成绩最高的学生学号
每组输出完换行
输出顺序严格按照输入顺序
4️⃣ 注意事项
题目保证最高分唯一 → 无需处理并列情况
学号从 1 开始，与数组索引无关
成绩在 0~100 范围，初始最大值设为 -1 安全
## 2927	最近的坐标点	https://www.xujcoj.com/home/problem/detail/2927
**答案：**
#include<iostream>
using namespace std;
int main()
{
	double x1, y1, x2, y2, x3, y3, d, xmin, ymin, dmin;
	cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;
	xmin = x1; ymin = y1; dmin = x1 * x1 + y1 * y1;
	d = x2 * x2 + y2 * y2;
	if (d < dmin)
	{
		dmin = d;
		xmin = x2;
		ymin = y2;
	}
	d = x3 * x3 + y3 * y3;
	if (d < dmin)
	{
		dmin = d;
		xmin = x3;
		ymin = y3;
	}
	cout << "(" << xmin << "," << ymin << ")";
	return 0;
}
**解析**：
1️⃣ 输入部分
只有一组案例
输入三行，每行包含两个浮点数 a 和 b：
表示平面直角坐标系中的一个点 (a, b)
|a|, |b| ≤ 10000
三行分别对应三个点的坐标
2️⃣ 策略与步骤
(1) 计算距离平方
距离原点的公式：
距离 = √(x² + y²)
为了避免浮点开平方计算，可以直接比较距离平方：
d = x*x + y*y
(2) 初始化最小距离
将第一个点 (x1, y1) 作为初始最近点：
xmin = x1, ymin = y1
dmin = x1*x1 + y1*y1
(3) 比较剩余两点
对第二个点 (x2, y2)：
计算 d = x2*x2 + y2*y2
如果 d < dmin → 更新最近点：
dmin = d
xmin = x2, ymin = y2
对第三个点 (x3, y3)：
同样计算 d = x3*x3 + y3*y3
如果 d < dmin → 更新最近点：
dmin = d
xmin = x3, ymin = y3
(4) 得到最终最近点
遍历完三点后，(xmin, ymin) 即为离原点最近的坐标点
3️⃣ 输出部分
输出要求：
按数学坐标格式输出 (x, y)
括号和逗号为英文输入法状态
逗号前后 无空格
不要换行
示例：
(1,2)
4️⃣ 注意事项
使用距离平方比较即可，避免开平方运算
输入为浮点数，但输出样例显示为整数：
可以直接输出浮点数，会自动去除小数点尾 0
或者根据题目需求用整数类型存储坐标
三个点比较顺序固定，从第一个点开始依次比较
## 4334	字母表	https://www.xujcoj.com/home/problem/detail/4334
**答案：**
#include<iostream>
using namespace std;
int main()
{
	char a;
	cin >> a;
	for (char i = 'A'; i <= 'Z'; i++)
	{
		if (i != toupper(a)) cout << i;
	}
	cout << endl;
	for (char i = 'a'; i <= 'z'; i++)
	{
		if (i != tolower(a)) cout << i;
	}
	cout << endl;
	return 0;
}
**解析**：
1️⃣ 输入部分
只有一组案例
输入一个英文字母字符 a：
可以是大写或小写
输入顺序严格为单个字符
2️⃣ 策略与步骤
(1) 输出大写字母
遍历 'A' 到 'Z'：
for (char i = 'A'; i <= 'Z'; i++)
判断条件：
如果当前大写字母 i 不等于输入字母的对应大写 toupper(a) → 输出
toupper(a) 函数将输入字母转换为大写
(2) 输出小写字母
遍历 'a' 到 'z'：
for (char i = 'a'; i <= 'z'; i++)
判断条件：
如果当前小写字母 i 不等于输入字母的对应小写 tolower(a) → 输出
tolower(a) 函数将输入字母转换为小写
(3) 输出换行
大写字母输出完后 cout << endl;
小写字母输出完后 cout << endl;
3️⃣ 输出部分
第一行：除输入字母对应大写外的所有大写字母
第二行：除输入字母对应小写外的所有小写字母
第二行输出完换行
字母间无空格
4️⃣ 注意事项
输入字母可能是大写或小写，都必须在两行中排除
使用 toupper() 和 tolower() 保证正确排除对应大小写
输出顺序严格为字母顺序
大写字母和小写字母分别独立输出
## 4024	0和1	https://www.xujcoj.com/home/problem/detail/4024
**答案：**
#include<iostream>
#include<string>
using namespace std;
int main()
{
    int n;
    cin >> n;
    while (n--)
    {
        int a, b;
        cin >> a >> b;
        string s = to_string(a + b);
        if (s.find("01") != -1 || s.find("10") != -1) cout << "Yes" << endl;
        else cout << "No" << endl;
    }
    return 0;
}
**解析**：
1️⃣ 输入部分
首先输入一个正整数 n，表示案例数量（n ≤ 100 等限制可假定）
每组案例输入两个整数 a 和 b
2️⃣ 策略与步骤
(1) 计算总和
对每组案例：
先计算总和 sum = a + b
(2) 将数字转成字符串
使用 to_string(sum) 将整数转换为字符串：
便于直接判断相邻数字
每个字符就是总和中的一位数字
(3) 判断是否有相邻 0 和 1
使用字符串的 find 函数判断：
s.find("01") → 如果存在子串 "01" → 返回索引，否则返回 -1
s.find("10") → 如果存在子串 "10" → 返回索引，否则返回 -1
条件判断：
如果 "01" 或 "10" 出现 → 输出 "Yes"
否则 → 输出 "No"
(4) 输出换行
每组案例输出完换行
输出顺序严格对应输入顺序
3️⃣ 输出部分
每组案例输出 "Yes" 或 "No"
不输出多余字符或空格
每行输出一组结果
4️⃣ 注意事项
相邻数字必须连续出现：
例如 3012 → 包含 01 → 符合
例如 3120 → 虽有 0 和 1，但不相邻 → 不符合
使用字符串判断比整数逐位判断更方便、直观
find 返回 -1 或 string::npos，可以直接判断
## 2910	四边形	https://www.xujcoj.com/home/problem/detail/2910
**答案：**
#include<iostream>
using namespace std;
int main()
{
	int T;
	cin >> T;
	while (T--)
	{
		int a, b, c, d;
		cin >> a >> b >> c >> d;
		if (a >= b + c + d || b >= a + c + d || c >= a + b + d || d >= a + b + c)
		{
			cout << "No" << endl;
		}
		else
		{
			cout << "Yes" << endl;
		}
	}
	return 0;
}
**解析**：
(1) 四边形判定规则
四边形成立条件（常规规则）：
任意一条边的长度 小于 其他三条边之和
即：
a < b + c + d
b < a + c + d
c < a + b + d
d < a + b + c
如果有任意一条边不满足上述条件 → 不能构成四边形 → 输出 "No"
否则 → 可以构成四边形 → 输出 "Yes"
注意：题目中“判定规则：两条最短边之和应大于剩下两条边之差”是描述思路，本质上符合 任意边小于其他三边之和 的判断。
(2) 实现步骤
读取四条边 a, b, c, d
判断是否有边不满足条件：
if (a >= b+c+d || b >= a+c+d || c >= a+b+d || d >= a+b+c)
如果成立 → 输出 "No"
否则 → 输出 "Yes"
3️⃣ 输出部分
每组案例输出：
"Yes" → 可以构成四边形
"No" → 不能构成四边形
每组输出后换行
4️⃣ 注意事项
判定时使用 >= 而不是 >：
长度等于其他三边之和 → 线段无法闭合 → 不能构成四边形
不需要排序四条边，直接按四边分别判断即可
输出顺序严格对应输入顺序
## 3764	老人与海	https://www.xujcoj.com/home/problem/detail/3764
**答案：**
#include <iostream>
using namespace std;
int main() {
    long long a;
    cin >> a;
    int lv = 1;
    while (a > 0) {
        if (lv < 50) {
            lv++;
            a--;
        } else {
            long long need = lv - 48; // 升一级所需鱼
            if (a >= need) {
                lv++;
                a -= need;
            } else {
                break; // 鱼不够升下一级
            }
        }
    }
    cout << lv;
    return 0;
}
**解析**：
1️⃣ 输入部分
首先输入一个整数 a，表示玩家总共钓到的鱼的数量（1 ≤ a ≤ 10^9）。
数据类型使用 long long，保证在鱼的数量非常大时不会溢出。
long long a;
cin >> a;
2️⃣ 策略与步骤
(1) 初始化技能点
玩家初始技能点为 1。
int lv = 1;
(2) 模拟升级过程
使用 while(a > 0) 循环，表示还有鱼可用于提升技能。
技能点 < 50：
每条鱼可直接增加 1 点技能。
扣除一条鱼，技能点 +1。
if (lv < 50) {
    lv++;
    a--;
}
技能点 ≥ 50：
升一级需要的鱼数量随技能逐渐增加：
升到 lv + 1 需要 lv - 48 条鱼。
判断鱼是否足够：
如果足够 → 升级并扣除相应鱼数。
如果不足 → 停止循环，技能无法再升级。
else {
    long long need = lv - 48; // 升一级所需鱼
    if (a >= need) {
        lv++;
        a -= need;
    } else {
        break; // 鱼不够升下一级
    }
}
(3) 循环终止条件
当 a = 0 或剩余鱼不足以升级下一级技能时，循环结束。
最终技能点 lv 即为玩家当前的钓鱼技能。
3️⃣ 输出部分
输出最终技能点 lv，不换行。
4️⃣ 注意事项
升级规则分两段：
技能 < 50：每条鱼升 1 点
技能 ≥ 50：升一级所需鱼数量逐步增加
使用 long long 避免大数溢出
break 语句用于处理鱼数量不足时的情况
循环模拟方法直观易懂，但当 a 很大时效率较低
## 2931	声音的频率	https://www.xujcoj.com/home/problem/detail/2931
**答案：**
#include<iostream>
using namespace std;
int main()
{
	int f, min = 20001, max = 19;
	for (int i = 0; i < 5; i++)
	{
		cin >> f;
		if (f >= 20 && f <= 20000)
		{
			if (f < min)
			{
				min = f;
			}
			if (f > max)
			{
				max = f;
			}
		}
	}
	if (min == 20001)
	{
		cout << -1;
	}
	else
	{
		cout << min << " " << max;
	}
	return 0;
}
**解析**：
1️⃣ 输入部分
本题只有一组输入数据。
输入的是 5 个正整数，分别表示五种不同动物发出的声音频率，单位是赫兹（Hz）。
2️⃣ 问题目标
人类能够听到的声音频率范围是 20 Hz 到 20000 Hz（包含 20 和 20000）。
题目的目标是：
在这 5 个声音中
找出 人类能够听到的声音频率里的最小值和最大值
如果 5 个声音人类全部听不到，则输出 -1
3️⃣ 解题思路与步骤
（1）筛选可听频率
逐个检查这 5 个声音频率：
如果某个频率 小于 20 或 大于 20000
→ 人类听不到，直接忽略
如果频率在 20 到 20000 之间
→ 这是人类可以听到的声音，需要参与比较
（2）记录最小值和最大值
在所有可听到的声音中：
记录 最小的可听频率
记录 最大的可听频率
随着不断比较，逐步更新这两个值。
（3）判断是否有可听声音
如果遍历完 5 个频率后，没有任何一个频率落在可听范围内
→ 说明人类完全听不到这些声音
→ 输出 -1
否则
→ 输出可听到的 最低频率 和 最高频率，中间用一个空格隔开
4️⃣ 输出要求
如果有可听声音：
输出两个整数：
最低频率 最高频率
如果全部听不到：
-1
不要换行
不输出多余的空格或字符
## 3770	总和最大	https://www.xujcoj.com/home/problem/detail/3770
**答案：**
#include<iostream>
using namespace std;
int main()
{
	int a, b, c, sum = 0;
	cin >> a >> b >> c;
	if (a > 0) sum += a;
	if (b > 0) sum += b;
	if (c > 0) sum += c;
	cout << sum;
	return 0;
}
**解析**：
1️⃣ 输入部分
输入只有一行，包含 三个整数，可以是正数、负数或 0。
这三个整数分别表示可以被选择的数字。
2️⃣ 问题目标
从这三个整数中：
可以选择 0 个、1 个、2 个或 3 个数字
要求 所选数字的总和尽可能大
如果一个数字会让总和变小，可以选择不选它
如果一个都不选，总和为 0
最终输出这个 最大可能的总和。
3️⃣ 解题思路与步骤
（1）明确关键结论
正数：加入总和一定会让结果变大 → 应该选择
负数：加入总和会让结果变小 → 不应该选择
0：加不加对结果没有影响 → 可加可不加
因此，最优策略是：
👉 把所有大于 0 的数全部加起来
（2）逐个判断三个数字
对输入的三个整数分别进行判断：
如果某个数 大于 0
→ 把它加入总和
如果某个数 小于或等于 0
→ 不加入总和
这样得到的结果，一定是可以取得的最大值。
4️⃣ 输出部分
输出一个整数，表示最大可能的总和
不要换行
不输出多余字符或空格
## 3359	输出字符	https://www.xujcoj.com/home/problem/detail/3359
**答案：**
#include<iostream>
using namespace std;
int main()
{
	int n;
	cin >> n;
	while (n--)
	{
		int m;
		char a;
		cin >> m >> a;
		if (m % 2 != 0)
		{
			for (int i = 0; i < m; i++)
			{
				cout << a;
			}
			cout << endl;
		}
		else
		{
			for (int i = 0; i < m / 2; i++)
			{
				if (i == 0) cout << a;
				else cout << " " << a;
			}
			cout << endl;
		}
	}
	return 0;
}
**解析**：
1️⃣ 输入部分
首先输入一个正整数 n，表示测试案例的数量
接下来有 n 组案例
每组案例包含：
一个正整数 m：表示数量
一个字符 a：表示要输出的字符
2️⃣ 问题目标
针对每一组案例，根据 m 的奇偶性，用不同的规则输出字符 a：
如果 m 是奇数
→ 输出 m 个 a
→ 字符之间 不加任何空格
如果 m 是偶数
→ 输出 m / 2 个 a
→ 每两个 a 之间加一个空格
→ 最后一个 a 后面不能有空格
3️⃣ 解题思路与步骤
（1）判断 m 的奇偶性
通过判断 m 是否能被 2 整除：
不能整除 → 奇数
能整除 → 偶数
（2）当 m 是奇数时的处理方式
直接连续输出 m 个字符 a
不插入任何空格
输出完成后换行
例如：
m = 5, a = B
输出：BBBBB
（3）当 m 是偶数时的处理方式
实际只需要输出 m / 2 个字符 a
每输出一个字符：
第一个字符 前面不加空格
从第二个字符开始，在前面加一个空格
这样可以保证：
字符之间有且只有一个空格
行末没有多余空格
输出完成后换行
例如：
m = 6, a = N
输出：N N N
4️⃣ 输出部分
每组案例输出一行结果
行末必须换行
不输出多余的空格或其他字符
## 2648	程序员纪元法	https://www.xujcoj.com/home/problem/detail/2648
**答案：**
#include<iostream>
using namespace std;
bool isLeapYear(int y)
{
	if (y % 400 == 0 || y % 100 != 0 && y % 4 == 0)
	{
		return true;
	}
	else
	{
		return false;
	}
}
int main()
{
	int n;
	cin >> n;
	while (n--)
	{
		int a, b, c;
		cin >> a >> b >> c;
		int cnt = 0;
		for (int i = 1970; i < a; i++)
		{
			if (isLeapYear(i))
			{
				cnt += 366;
			}
			else
			{
				cnt += 365;
			}
		}
		int days[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
		if (isLeapYear(a))
		{
			days[2] = 29;
		}
		for (int i = 1; i < b; i++)
		{
			cnt += days[i];
		}
		cnt += c;
		cout << cnt << endl;
	}
	return 0;
}
**解析**：
1️⃣ 题目核心含义
把 1970 年 1 月 1 日 规定为 第 1 天
之后的日期每天顺延 +1
1970-01-02 → 第 2 天
1971-01-01 → 第 366 天
现在给定一个日期 a 年 b 月 c 日
要求计算：该日期是从 1970-01-01 开始算起的第几天
2️⃣ 输入部分说明
首先输入一个正整数 n，表示案例数量
接下来有 n 组日期
每组输入三个整数：
a：年份
b：月份
c：日期
题目保证：
日期一定合法
日期晚于 1970-01-01
不超过 3199-12-31
3️⃣ 解题总体思路
把目标日期拆成三部分来累计天数：
**总天数 = 1970 年到 a−1 年的整年天数
a 年中 b−1 月的天数
c 天**
4️⃣ 关键步骤解析
（1）判断闰年
判断某一年是否是闰年，规则是：
能被 400 整除 → 闰年
或者
能被 4 整除但不能被 100 整除 → 闰年
其他情况 → 平年
闰年有 366 天，平年有 365 天。
（2）累计完整年份的天数
从 1970 年 开始
一直累加到 a−1 年
每一年：
如果是闰年，加 366
否则，加 365
这样就算出了 到 a 年 1 月 1 日之前的总天数
（3）准备每个月的天数表
一般年份中各月天数如下：
月份	天数
1	31
2	28
3	31
4	30
5	31
6	30
7	31
8	31
9	30
10	31
11	30
12	31
如果 a 年是闰年
把 2 月的天数从 28 改为 29
（4）累计当前年份中已过去的月份天数
从 1 月 开始
累加到 b−1 月
每个月加对应的天数
（5）加上当前月的日期 c
最后再加上 c
因为第 c 天本身也要计入总天数
5️⃣ 输出部分
对每一组案例：
输出计算得到的总天数
每组结果占一行
不输出多余内容
## 3978	符合条件的数-3	https://www.xujcoj.com/home/problem/detail/3978
**答案：**
#include<iostream>
using namespace std;
int main()
{
	int n;
	cin >> n;
	while (n--)
	{
		int a, b;
		cin >> a >> b;
		int c = b % 10 - a % 10;
		if (c <= 0) c += 10;
		cout << c << endl;
	}
	return 0;
}
**解析**：
1️⃣ 输入部分
首先输入一个正整数 n
表示测试案例的数量
约束条件：n ≤ 1000
接下来有 n 组数据
每组输入两个正整数：a 和 b
a、b 的范围：不大于 10^9
输入顺序严格为：
a b
2️⃣ 策略与步骤
(1) 明确目标
需要找到一个 最小的正整数 c
满足条件：
(a + c) 的个位数 = b 的个位数
换句话说，只关心 个位数字，不关心十位及以上的数值。
(2) 提取个位数
a 的个位数：
等于 a 对 10 取余
b 的个位数：
等于 b 对 10 取余
这样问题就转化为：
找到一个最小的正整数 c，使
(a 的个位 + c) 对 10 取余 = b 的个位
(3) 计算个位差值
初步计算差值：
c = b 的个位 − a 的个位
但这里可能出现两种情况：
情况一：c > 0
说明直接加这个 c 就能让个位相等
并且这是最小的正整数解
情况二：c ≤ 0
说明直接相减无法得到正整数
需要 向前进一轮（+10）
因为个位数字是以 10 为一个循环
所以执行：
c = c + 10
这样可以保证：
c 为正整数
且是满足条件的最小值
(4) 为什么一定要加 10
个位数的变化规律是：
0 → 1 → 2 → … → 9 → 0 → …
如果差值为 0 或负数
说明需要“绕一圈”才能再次到达目标个位
加 10 正好完成一次完整循环
3️⃣ 输出部分
对每一组测试数据：
输出一个整数 c
表示满足条件的 最小正整数解
每组结果 单独一行输出
4️⃣ 注意事项
只比较个位数，其他位完全无关
c 必须是 正整数，不能为 0
使用个位差值 + 循环补偿（+10）
比枚举所有 c 更高效
能保证在常数时间内解决每个案例
## 3006	最大的长方形	https://www.xujcoj.com/home/problem/detail/3006
**答案：**
#include <iostream>
using namespace std;
int main()
{
    int n;
    cin >> n;
    while (n--)
    {
        int m, maxL = 0, maxW = 0, max = 0;
        cin >> m;
        while (m--)
        {
            int a, b;
            cin >> a >> b;
            if (a != b && a * b > max)
            {
                max = a * b;
                if (a > b)
                {
                    maxL = a;
                    maxW = b;
                }
                else
                {
                    maxL = b;
                    maxW = a;
                }
            }
        }
        cout << maxL << " " << maxW << " " << max << endl;
    }
    return 0;
}
**解析**：
1️⃣ 输入部分
首先输入一个正整数 n
表示测试案例的数量
约束：n ≤ 20
对于每一组案例：
1️⃣ 输入一个正整数 m
表示给定的图形数量
包括 长方形和正方形
m ≤ 20
2️⃣ 接下来输入 m 组数据
每组由两个正整数构成
表示一个图形相邻两条边的长度
可能是长方形，也可能是正方形
2️⃣ 策略与步骤
(1) 初始化变量
在每一组案例中，设置以下变量用于记录结果：
max
当前找到的 最大面积
初始为 0
maxL
记录最大面积长方形的 长
maxW
记录最大面积长方形的 宽
(2) 遍历所有图形
对输入的每一个图形，执行以下判断：
① 排除正方形
如果两条边相等（a == b）
说明是正方形
根据题目要求 不参与比较
直接忽略
② 计算面积并比较
若是长方形（a != b）：
计算面积：
面积 = a × b
如果该面积 大于当前记录的最大面积：
更新最大面积
记录该长方形的信息
(3) 规范输出的长和宽
题目要求：
长必须比宽大
因此在更新最大长方形时：
比较两条边
较大的作为 长
较小的作为 宽
这样可以确保输出格式符合要求。
(4) 最大值唯一性保证
题目已保证：
每组案例中
不会出现多个面积并列最大的长方形
因此只需简单比较，无需额外处理冲突情况。
3️⃣ 输出部分
对每一组案例，输出三项数据：
长 宽 面积
数据之间用 一个空格 隔开
每组案例输出完成后 换行
4️⃣ 注意事项
正方形必须排除，即使面积很大也不能选
只比较长方形的面积
面积不会超出 int 范围，使用普通整数即可
遍历 + 比较的方法在数据量很小（m ≤ 20）的情况下效率完全足够
## 2173	时间差-2	https://www.xujcoj.com/home/problem/detail/2173
**答案：**
#include<iostream>
#include<cmath>
using namespace std;
int getSeconds(int h, int m, int s)
{
	return h * 3600 + m * 60 + s;
}
int main()
{
	int n;
	cin >> n;
	while (n--)
	{
		int h1, m1, s1, h2, m2, s2;
		cin >> h1 >> m1 >> s1 >> h2 >> m2 >> s2;
		int seconds = abs(getSeconds(h1, m1, s1) - getSeconds(h2, m2, s2));
		cout << seconds / 3600 << " " << seconds % 3600 / 60 << " " << seconds % 60 << endl;
	}
	return 0;
}
**解析**：
1️⃣ 输入部分
首先输入一个正整数 n
表示测试案例的数量
对于每一组案例：
输入 6 个整数
输入顺序为：
h1 m1 s1 h2 m2 s2
前三个整数表示 第一个时间点的时、分、秒
后三个整数表示 第二个时间点的时、分、秒
所有输入时间都保证合法
范围在 00:00:00 到 23:59:59 之间
不保证哪一个时间点更早
2️⃣ 策略与步骤
(1) 时间统一转换为秒
定义一个辅助思路：
将一个时间点（时、分、秒）
转换为 从当天 00:00:00 开始计算的总秒数
转换规则：
总秒数 = 小时 × 3600 + 分钟 × 60 + 秒
这样可以把复杂的时间差问题，转化为 两个整数之间的差值问题。
(2) 计算两个时间点的秒数差
分别计算两个时间点对应的总秒数
由于不确定哪个时间更早：
对二者的差值取 绝对值
得到变量：
表示两个时间点之间的 总秒数差
(3) 将秒数差还原为时、分、秒
利用整数除法和取余操作拆分：
① 计算小时
用总秒数除以 3600
商即为 小时差
② 计算分钟
用总秒数对 3600 取余
再除以 60
得到 分钟差
③ 计算秒
用总秒数对 60 取余
得到 秒差
这样保证：
分钟 < 60
秒 < 60
完全符合题目输出要求
3️⃣ 输出部分
对每一组案例输出三个非负整数：
a b c
表示两个时间点之间相差：
a 小时
b 分钟
c 秒
每两个数之间用一个空格隔开
每组案例输出完成后换行
4️⃣ 注意事项
使用秒作为中间单位，逻辑简单、不会出错
使用绝对值处理时间先后不确定的问题
不涉及跨天问题（题目限定为同一天）
输出的分钟和秒一定不会超过 59
## 4017	21世纪的第几天	https://www.xujcoj.com/home/problem/detail/4017
**答案：**
#include<iostream>
using namespace std;
bool isLeap(int y)
{
	if (y % 400 == 0 && y % 3200 != 0 || y % 4 == 0 && y % 100 != 0) return true;
	else return false;
}
int main()
{
	int n;
	cin >> n;
	while (n--)
	{
		int y, m, d, cnt = 0;
		cin >> y >> m >> d;
		for (int i = 2000; i < y; i++)
		{
			if (isLeap(i)) cnt += 366;
			else cnt += 365;
		}
		int days[] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };
		if (isLeap(y)) days[2] = 29;
		for (int i = 1; i < m; i++)
		{
			cnt += days[i];
		}
		cnt += d;
		cout << cnt << endl;
	}
	return 0;
}
**解析**：
1️⃣ 输入部分
首先输入一个正整数 n
表示测试案例数量
约束：n ≤ 10000
每组案例输入 三个正整数：
y m d
y：年份（2000~2099）
m：月份（1~12）
d：日（合法的天数）
保证输入的日期都在21世纪范围内
2️⃣ 策略与步骤
(1) 判断闰年
定义一个函数判断年份是否为闰年
闰年的判断规则（符合 21 世纪及一般公历）：
能被 400 整除且不能被 3200 整除 → 闰年
能被 4 整除但不能被 100 整除 → 闰年
其他年份 → 平年
闰年是为了处理 2 月的天数（29 天或 28 天）
(2) 累加前几年天数
定义一个计数器 cnt = 0
遍历 2000 年到 y-1 年
如果是闰年 → 累加 366 天
如果是平年 → 累加 365 天
这样可以得到从 2000年1月1日到上一年12月31日 的总天数
(3) 累加当年月份天数
定义一个数组记录每个月的天数：
days = {0,31,28,31,30,31,30,31,31,30,31,30,31}
下标 1~12 对应 1~12 月
下标 0 用作占位
如果当年是闰年 → 把 days[2] 改为 29
遍历 1 月到 m-1 月
将每个月的天数累加到计数器 cnt
(4) 加上当月天数
最后将 d（当月天数）加入 cnt
此时 cnt 就是从 2000年1月1日 起到该日期的 累计天数
3️⃣ 输出部分
对每一组案例输出一个正整数
表示该天是 21 世纪的第几天
每组输出单独一行
4️⃣ 注意事项
闰年的处理要准确，否则 2 月天数错误会导致累积天数不对
累加天数时，必须分两步：
累加前几年天数
累加当年月份天数 + 当日
cnt 从 1 开始计数，2000 年 1 月 1 日为第 1 天
数组下标从 1 开始，方便对应月份