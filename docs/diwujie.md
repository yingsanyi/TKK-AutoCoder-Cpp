第五节：计算的引擎——运算符 (Operators)
变量里存的是“数据”，而运算符就是对这些数据动手操作的工具。
 这一节从常用到容易踩坑，循序介绍：
- 算术运算符：加减乘除、取余、自增自减
- 复合赋值运算符：+=、-= 等简写
- 常用数学函数：pow、sqrt、ceil 等
- 运算优先级：同一行代码里，谁先算谁后算
🚀 核心隐喻： 如果变量是“食材”，数据类型是“容器”，那么运算符就是厨师手中的“烹饪技法”。
- 算术运算是切菜煮饭（基础处理）。
- 逻辑运算是品尝味道（判断好坏）。
- 位运算是分子料理（底层微操）。

---
5.1 算术运算符 —— 加减乘除 + 取模 + 自增自减
5.1.1 基本算术运算符
常见的算术运算符：
暂时无法在飞书文档外展示此内容
两个重要细节：
1. 整数 / 整数 = 整数（小数部分被直接截掉）
7 / 2;   // 结果是 3，而不是 3.5
5 / 4;   // 结果是 1，而不是 1.25
1. %（取模）只适用于整数，不能对 double 等小数使用。
5 % 2;     // 合法，结果为 1
5.0 % 2;   // ❌ 非法，不能编译
示例 5.1-1：加减乘除与取模
#include <iostream>
using namespace std;

int main() {
    int a = 7;
    int b = 3;

    cout << "a + b = " << a + b << endl; // 10
    cout << "a - b = " << a - b << endl; // 4
    cout << "a * b = " << a * b << endl; // 21

    cout << "a / b = " << a / b << endl; // 2 （整数除法）
    cout << "a % b = " << a % b << endl; // 1 （7 除以 3 的余数）

    // 想要小数结果，可以让其中一个是浮点数
    cout << "7.0 / 3 = " << 7.0 / 3 << endl; // 2.33333...
    cout << "7 / 3.0 = " << 7 / 3.0 << endl; // 2.33333...

    return 0;
}
练习 5.1-A（判断 + 小陷阱）
判断下列说法对错（对写 T，错写 F），并简单说明理由：
1. 9 / 4 的结果是 2.25。 ____
2. 9 % 4 的结果是 1。 ____
3. 表达式 5 % 2.0 在 C++ 中是合法的。 ____
4. 如果想让 7 / 2 输出 3.5，可以写成 7.0 / 2。 ____

---
5.1.2 自增、自减运算符 ++ 和 --
- ++：让变量自己 加 1
- --：让变量自己 减 1
有两种位置写法：
- 前置：++i、--i
 使用时的含义：先改变，再使用
- 后置：i++、i--
 使用时的含义：先使用，再改变
示例 5.1-2：单独使用时几乎等价
#include <iostream>
using namespace std;

int main() {
    int x = 5;

    x++;        // 等价于 x = x + 1;
    cout << "x++ 之后 x = " << x << endl; // 6

    ++x;        // 再加 1
    cout << "++x 之后 x = " << x << endl; // 7

    x--;        // 减 1
    cout << "x-- 之后 x = " << x << endl; // 6

    return 0;
}
在“单独一行使用”的情况下，++x 和 x++ 效果几乎没有区别。
练习 5.1-B（选择）
假设 int x = 10;，下面四句各执行一次后，x 的值分别是多少？
x++;
++x;
x--;
--x;
（可以自己写一个小程序，把每句之间用 cout 打印出来验证。）

---
5.1.3 难点：前置 ++i 与 后置 i++ 的区别（表达式中）
记忆方式：
- ++i：变量 先加 1，然后把新值拿去算；
- i++：先把旧值拿去算，算完后变量再加 1。
示例 5.1-3：前置和后置参与表达式的区别
#include <iostream>
using namespace std;

int main() {
    int a = 1;
    int b = 2;

    cout << "a + ++b = " << a + ++b << endl; // ?
    cout << "此时 b = " << b << endl;

    int c = 2;
    cout << "a + c++ = " << a + c++ << endl; // ?
    cout << "此时 c = " << c << endl;

    return 0;
}
执行过程拆解：
1. a + ++b
  - 初始：a = 1, b = 2
  - ++b：b 先加 1 → b = 3
  - 表达式：a + b = 1 + 3 = 4
  - 打印：a + ++b = 4，此时 b = 3
2. a + c++
  - 初始：a = 1, c = 2
  - 表达式先用 c 当前值：1 + 2 = 3
  - 表达式结束后，c 再加 1 → c = 3
  - 打印：a + c++ = 3，此时 c = 3
练习 5.1-C（小陷阱）
不建议在实际项目中这样写，但很适合训练理解力。
1. 写出下面语句执行完之后，x 和 y 的值：
int x = 3;
int y = x++ + ++x;
1. 提示：按“从左到右”的顺序，跟踪每一步 x 的变化。
2. 判断对错：在任何情况下，x++ + ++x 的结果都一定等于 2 * x + 1。
 （用 T/F 作答，并尝试举例说明）
建议：实际写代码时，不要在同一个表达式里同时对同一个变量既前置又后置自增/自减，容易读不懂，也容易出错。
 学习阶段可以用来练习理解，但正常写代码时应避免。

---
5.2 复合赋值运算符 —— “在自己基础上再来一下”
有很多时候，我们会写出这样的代码：
x = x + 3;
y = y * 2;
这里的“右边用了自己，再赋值给自己”非常常见，所以 C++ 提供了复合赋值运算符，用来简写：
暂时无法在飞书文档外展示此内容
示例 5.2-1：复合赋值的连续使用
#include <iostream>
using namespace std;

int main() {
    int x = 10;

    x += 5;  // 10 + 5 = 15
    cout << "x += 5  之后: " << x << endl;

    x *= 2;  // 15 * 2 = 30
    cout << "x *= 2  之后: " << x << endl;

    x -= 6;  // 30 - 6 = 24
    cout << "x -= 6  之后: " << x << endl;

    x /= 4;  // 24 / 4 = 6
    cout << "x /= 4  之后: " << x << endl;

    x %= 5;  // 6 % 5 = 1
    cout << "x %= 5  之后: " << x << endl;

    return 0;
}
练习 5.2-A（改写 + 判断）
1. 把下列写法改成使用复合赋值运算符的形式：
x = x + 10;
y = y * 3;
z = z - 7;
a = a % 2;
1. 判断下列两行语句是否等价（如果等价写 =，否则写 ≠ 并说明理由）：
  - x += y + 1;  ______  x = x + y + 1;
  - x *= y + 1;  ______  x = x * y + 1;
2. 提示：第二条要特别小心运算优先级。

---
5.3 常用数学函数 —— <cmath> 数学工具包
基本算术只能处理简单的加减乘除。
 更多“数学味”很重的运算，<cmath> 头文件提供了一整套函数。
使用方式：
#include <cmath>

double a = sqrt(9.0);   // 平方根
double b = pow(2.0, 3); // 2 的 3 次方
常见函数（本节用到的）：
- pow(x, y)：计算 (x^y)
- sqrt(x)：计算 (\sqrt{x})
- abs(x)：计算绝对值（整数绝对值也可以用 <cstdlib> 里的 abs，这里只做直观理解）
- ceil(x)：向上取整（返回大于等于 (x) 的最小整数值，类型仍为 double）
- floor(x)：向下取整（返回小于等于 (x) 的最大整数值，类型为 double）
示例 5.3-1：常用数学函数演示
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    double x = 2.0;
    double y = 3.0;

    cout << "pow(2.0, 3.0) = " << pow(x, y) << endl;   // 8

    double v = 9.0;
    cout << "sqrt(9.0)     = " << sqrt(v) << endl;     // 3

    int n = -5;
    cout << "abs(-5)       = " << abs(n) << endl;      // 5

    double a = 3.14;
    cout << "ceil(3.14)    = " << ceil(a) << endl;     // 4
    cout << "floor(3.14)   = " << floor(a) << endl;    // 3

    return 0;
}
注意：
- ceil 和 floor 虽然名字里有“整”，但返回类型仍是 double；
- 想要得到整数类型，可以再用强制类型转换（这个可以放在后续章节讲）。
练习 5.3-A（计算题）
1. 用 <cmath> 写一段程序，计算半径为 r = 2.5 的圆的面积（取 (\pi = 3.14159)）：
  - 面积公式：(S = \pi r^2)
  - 可以选择用 pow(r, 2)，也可以用 r * r
2. 直接写出结果（不必写代码）：
  - ceil(2.01) = ______
  - floor(2.99) = ______
  - abs(-12) = ______
  - pow(2, 4) = ______
练习 5.3-B（小陷阱·精度）
以下代码片段的输出，哪个更接近 0？（单选）
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    double x = sqrt(2.0);
    cout << 2 - x * x << endl;
    cout << 2.0 - x * x << endl;
    return 0;
}
A. 第一行更接近 0
 B. 第二行更接近 0
 C. 两行完全一样
 D. 肉眼看不出区别
提示：涉及浮点数精度问题，可以先运行看看，再简单讨论为什么会有“看似不为 0”的情况。

---
5.4 运算优先级 —— 一行里谁先算谁后算
当一个表达式中有好几种运算符时，如果没有括号，C++ 会按照运算优先级来排队计算顺序。
完整的优先级表很长，这里只记住简单版本：
1. 括号 () 始终最高：
 任何时候只要不确定，都可以加括号。
2. 常用优先级从高到低，可以记成这样一条“梯子”：
()                     // 括号最高
!                      // 逻辑非
*  /  %                // 乘、除、取模
+  -                   // 加、减
>  <  >=  <=  ==  !=   // 各种比较
&&                     // 逻辑与
||                     // 逻辑或
=  ,                   // 赋值 和 逗号（最低）
1. 同一层级内通常是从左到右计算（赋值是从右到左）。
示例 5.4-1：没有括号 vs 有括号
#include <iostream>
using namespace std;

int main() {
    int a = 2, b = 3, c = 4;

    int r1 = a + b * c;       // 先算 b * c，再加 a
    int r2 = (a + b) * c;     // 先算 a + b，再乘 c

    bool r3 = a + b > c;      // 先算 a + b，再比较 > c
    bool r4 = a > b && b > c; // 先算两个比较，再做 &&

    cout << "a + b * c   = " << r1 << endl;        // 14
    cout << "(a + b) * c = " << r2 << endl;        // 20

    cout << boolalpha;
    cout << "a + b > c   = " << r3 << endl;        // true
    cout << "a > b && b > c = " << r4 << endl;     // false

    return 0;
}
拆解 a + b * c：
- b * c 优先级高：3 * 4 = 12
- 再算 a + 12 = 14
拆解 a + b > c：
- 先算 a + b = 5
- 再算 5 > 4，结果为 true
练习 5.4-A（顺序 + 结果）
假设 int a = 2, b = 3, c = 4, d = 5;，写出下面每条语句的结果：
1. int x = a + b * c;
  - 先算：________________________
  - 结果：x = ______
2. int y = (a + b) * c - d;
  - 先算：________________________
  - 结果：y = ______
3. bool z = a + b * c > d;
  - 先算：________________________
  - 比较：________________________
  - 结果：z = ______（写 true 或 false）
练习 5.4-B（给表达式“加上护栏”）
在不改变计算结果的前提下，为下列表达式加上括号，让顺序一眼就能看懂（可以有多种写法）：
int result = a + b * c - d / e;
bool ok = a + b > c && d < e;
示例参考（其中一种）：
int result = a + (b * c) - (d / e);
bool ok = (a + b > c) && (d < e);
练习 5.4-C（判断题·陷阱）
判断下列说法的对错（T/F）：
1. 在没有括号时，a && b || c 一定先算 a && b，再算 || c。 ____
2. x += y + 1; 和 x = (x + y) + 1; 的结果总是一样的。 ____
3. 表达式 a = b = c = 0; 的执行顺序是从左到右。 ____
4. 括号会改变运算符的优先级。 ____

---
这一节结束后，可以尝试把变量、输入输出、运算符串联起来，写一些小程序，例如：
- 输入三个整数，输出它们的和与平均值（注意整数除法的陷阱）；
- 输入圆的半径，输出周长和面积（用 pow 或 r * r）。