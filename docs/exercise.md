下面是一整套 **完全不含数组** 的 20 道 C++ 指针单选题（每题 5 个选项），都只涉及：指针定义、取地址、解引用、`const` 组合、空指针、`void*`、多级指针、作为函数参数等，不出现 `T a[N]` / 下标访问。题目默认在标准 C++（至少 C++11）环境下编译 [ref:2,3,5,8]。

---

## 1. 指针的基本定义

下面哪一行代码 **正确定义了指向 `int` 的指针 `p`**？

A. `int p;`  
B. `int *p;`  
C. `int &p;`  
D. `int p*;`  
E. `int *p();`

**答案：** B  

**解析：**  
`int *p;` 声明一个指向 `int` 类型的指针变量 `p`。  
A 是普通 `int` 变量；C 为引用；D 语法错误；E 是声明返回 `int*` 的函数。 [ref:2,3]

---

## 2. 取地址运算符 `&`

```cpp
int x = 10;
int *p;
```

哪一行能让 `p` 正确指向 `x`？

A. `p = x;`  
B. `*p = &x;`  
C. `p = &x;`  
D. `&p = x;`  
E. `*p = x;`

**答案：** C  

**解析：**  
`&x` 的类型是 `int*`，可以赋值给 `p`。A 把 `int` 赋给 `int*`；B、D 语法/类型不对；E 在 `p` 未初始化时解引用，行为未定义。 [ref:2,3]

---

## 3. 解引用运算符 `*`

```cpp
int x = 5;
int *p = &x;
*p = 20;
std::cout << x << std::endl;
```

输出结果是？

A. 5  
B. 20  
C. 地址值  
D. 不确定  
E. 编译错误

**答案：** B  

**解析：**  
`p` 指向 `x`，`*p = 20;` 相当于给 `x` 赋值 20，因此输出 20。 [ref:2,3]

---

## 4. 指针与 `sizeof`

在大多数 64 位系统上（如常见桌面环境），下面哪种说法最有可能正确？

A. `sizeof(int*) == sizeof(int)`  
B. `sizeof(int*) == sizeof(double*)`  
C. `sizeof(int*) < sizeof(double*)`  
D. `sizeof(int*) > sizeof(double*)`  
E. `sizeof(int*)` 由所指向类型大小决定

**答案：** B  

**解析：**  
同一平台上所有对象指针的大小通常相同（例如都为 8 字节），与所指类型无关；而 `int` 本身可能只有 4 字节。 [ref:2,5]

---

## 5. 未初始化指针

```cpp
int *p;
*p = 10;
```

关于这段代码，哪个说法是正确的？

A. 一定给某个 `int` 变量赋值 10  
B. 一定导致编译错误  
C. 行为未定义（Undefined Behavior）  
D. `p` 自动被初始化为 `nullptr`  
E. `p` 自动指向某个全局变量

**答案：** C  

**解析：**  
未初始化的局部指针 `p` 含有不确定值，解引用 `*p` 是未定义行为，可能崩溃也可能“看似正常”。不会自动为 `nullptr`。 [ref:2,8]

---

## 6. 指向常量的指针（所指对象为 `const`）

下列哪一句声明了一个“**指向 `const int` 的指针**”？

A. `const int *p;`  
B. `int *const p;`  
C. `const int *const p;`  
D. `int const *p;`  
E. A 和 D

**答案：** E  

**解析：**  
`const int *p;` 与 `int const *p;` 等价：指针可以改变指向，但不能通过 `p` 修改所指 `int`。  
B 是“常量指针，指向非常量 `int`”；C 则两者都 `const`。 [ref:2]

---

## 7. 常量指针（指针本身为 `const`）

想声明一个“**常量指针，永远指向同一个 `int` 对象**，但可通过该指针修改对象内容”，应该使用：

A. `const int *p;`  
B. `int const *p;`  
C. `int *const p;`  
D. `const int *const p;`  
E. `int &const p;`

**答案：** C  

**解析：**  
`int *const p;`：`p` 是常量指针（地址不可改），指向的 `int` 非 `const`（可以改内容）。  
A / B：指向常量；D：指针和所指都常量；E 语法错误。 [ref:2]

---

## 8. 指针与 `const` 的综合

希望下面的声明表示：  
“`p` 是一个常量指针，始终指向一个常量 `int`，既不能改变指针本身，也不能通过 `p` 改变值”。

应写为：

A. `const int *p;`  
B. `int const *p;`  
C. `int *const p;`  
D. `const int *const p;`  
E. `int const *const p;`

**答案：** D 或 E  

**解析：**  
`const int *const p;` 和 `int const *const p;` 等价：  
- 前一个 `const` 修饰 `int`；  
- 后一个 `const` 修饰指针本身。  
二者都不可修改。 [ref:2]

---

## 9. 空指针常量

在 C++11 及之后，推荐使用哪一个来表示空指针？

A. `0`  
B. `NULL`  
C. `nullptr`  
D. `'\0'`  
E. `false`

**答案：** C  

**解析：**  
`nullptr` 是专门的空指针字面量，类型安全，不与整数混淆，是 C++11 以后推荐的空指针写法。 [ref:2,3]

---

## 10. 判断指针是否为空

```cpp
int x = 42;
int *p = nullptr;
if (!p) {
    p = &x;
}
std::cout << *p << std::endl;
```

输出结果是？

A. 不确定  
B. 0  
C. 42  
D. 编译错误  
E. 运行时错误

**答案：** C  

**解析：**  
`p` 初始为空，`if (!p)` 为真，因此将 `p` 置为 `&x`，随后 `*p` 为 42。 [ref:2]

---

## 11. 指向指针的指针

下面哪一行 **正确定义了“指向 `int*` 的指针”**？

A. `int **p;`  
B. `int *p*;`  
C. `int &*p;`  
D. `int *&p;`  
E. `int **&p;`

**答案：** A  

**解析：**  
`int **p;`：`p` 是指向 `int*` 的指针。  
D/E 中的 `&` 表示“引用”，含义不同；B/C 语法错误。 [ref:2]

---

## 12. 多级指针解引用

```cpp
int x = 5;
int *p = &x;
int **pp = &p;
**pp = 10;
std::cout << x << std::endl;
```

输出结果是？

A. 5  
B. 10  
C. 地址值  
D. 不确定  
E. 编译错误

**答案：** B  

**解析：**  
`pp` 指向 `p`，`*pp` 是 `p`，`**pp` 就是 `x`。`**pp = 10;` 等价于 `x = 10;`。 [ref:2,4]

---

## 13. `void*` 指针

关于 `void*`，下面哪一项说法是正确的？

A. `void*` 不能存储任何地址  
B. `void*` 可以在不转换的情况下直接解引用  
C. `void*` 可以存储任意对象的地址，但解引用前必须转换为具体类型  
D. `void*` 只能指向函数  
E. C++ 中禁止使用 `void*`

**答案：** C  

**解析：**  
`void*` 是“通用对象指针”，可以存储任意对象的地址，但因为不知道其类型，不能直接解引用，必须先转为合适类型。 [ref:2,5,8]

---

## 14. 从 `void*` 恢复原类型

```cpp
int x = 7;
void *pv = &x;
// ??? 补全一行
*p = 20;
```

想通过 `pv` 修改 `x` 的值，下面哪一行应填在注释处？

A. `int p = pv;`  
B. `int *p = pv;`  
C. `int *p = (int*)pv;`  
D. `int &p = *pv;`  
E. `auto p = *pv;`

**答案：** C  

**解析：**  
需把 `void*` 强制转换为 `int*`，写作 `int *p = (int*)pv;` 或 `static_cast<int*>(pv)`。B 在 C++ 中通常需要显式转换，不符合标准的类型安全要求。 [ref:2,5]

---

## 15. 指针作为函数参数（按地址“传参”）

```cpp
void setZero(int *p) {
    *p = 0;
}

int main() {
    int x = 5;
    setZero(&x);
    std::cout << x << std::endl;
}
```

程序输出为：

A. 5  
B. 0  
C. 随机值  
D. 编译错误  
E. 运行时错误

**答案：** B  

**解析：**  
把 `x` 的地址传给 `setZero`，函数中通过 `*p = 0;` 修改的就是 `x` 本身，输出 0。 [ref:2,4]

---

## 16. 通过指针修改指针本身（“指针的指针”用在函数参数）

```cpp
void reset(int **pp) {
    *pp = nullptr;
}

int main() {
    int x = 10;
    int *p = &x;
    reset(&p);
    if (p == nullptr) {
        std::cout << "null\n";
    }
}
```

关于这段代码，哪种说法正确？

A. `reset` 无法改变 `p` 的值  
B. `reset` 只能改变 `x` 的值  
C. 调用 `reset(&p);` 后，`p` 被置为 `nullptr`  
D. `reset` 会导致编译错误  
E. `reset` 一定导致未定义行为

**答案：** C  

**解析：**  
`pp` 指向 `p`，`*pp = nullptr;` 等价于 `p = nullptr;`，因此主函数中 `p` 被重置为空指针。 [ref:2,5]

---

## 17. 指针与引用的区别

```cpp
int x = 1;
int y = 2;
int *p = &x;
int &r = x;
p = &y;
// r = &y; // 假设尝试这样写
```

关于指针 `p` 和引用 `r` 的行为，下列哪点是正确的？

A. 指针和引用都可以在初始化后改为绑定另一个对象  
B. 只有指针可以在之后指向另一个对象  
C. 只有引用可以在之后绑定另一个对象  
D. 二者都不能在初始化时绑定对象  
E. 引用必须通过 `new` 得到

**答案：** B  

**解析：**  
指针可以改变所指对象（`p = &y;` 合法）；引用在初始化后就不能再“改绑定”，无法写出 `r = &y;` 这样的改变绑定代码。 [ref:2,4]

---

## 18. 指针自增的合法性（不依赖数组）

```cpp
int x = 1;
int *p = &x;
++p;
```

关于这段代码，哪种说法**最符合标准 C++ 要求**？

A. 完全安全，`p` 现在指向下一个合法 `int`  
B. 行为明确且定义良好  
C. 行为未定义，因为 `p` 不再指向一个合法对象  
D. 一定导致编译错误  
E. 一定导致运行时异常抛出

**答案：** C  

**解析：**  
标准规定：只有指向同一数组内元素或尾后位置的指针才允许做加减并保持定义良好；这里 `&x` 不属于数组元素，`++p` 使 `p` 不再指向有效对象，行为未定义。 [ref:1,10]

---

## 19. 指针比较

```cpp
int x = 1;
int y = 2;
int *p = &x;
int *q = &y;
bool b = (p == q);
```

以下哪项说法是正确的？

A. 这段代码一定是未定义行为  
B. 只能比较 `void*`，不能比较 `int*`  
C. 比较两个指向任意对象的指针是否相等是允许的  
D. 只有在它们指向同一个对象时才允许比较  
E. 编译器会拒绝编译 `p == q`

**答案：** C  

**解析：**  
比较两个对象指针是否相等是合法且定义良好的（结果通常为 `false`）。未定义的是跨对象的“大小比较”而不是“相等比较”。 [ref:5,8]

---

## 20. 指针初始化与悬空指针的最佳实践

下面关于指针的说法，哪一条是 **最佳实践**？

A. 局部指针变量会自动初始化为 `nullptr`  
B. 释放动态内存后必须立刻把指针赋值为 `nullptr`，以避免悬空指针  
C. 指针只要不是 `nullptr`，就一定可以安全解引用  
D. 为了效率，应尽量避免检查指针是否为空  
E. 可以复用已经 `delete` 掉的指针指向的内存

**答案：** B  

**解析：**  
局部未初始化指针的值是不确定的；用完动态内存后应 `delete` 并把指针置为 `nullptr`，否则易形成悬空指针；非空也不代表指针指向的是仍然有效的对象。 [ref:2,5,8]

---
ß