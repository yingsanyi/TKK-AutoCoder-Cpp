
---

## 一、选择题（20 题）

每题仅一个正确答案，题后给出参考答案与简要解析。

---

### 1. 数组名与指针

给定：

```cpp
int a[5] = {1, 2, 3, 4, 5};
int *p = a;
```

下列说法中正确的是：

A. `p` 的类型是 `int`  
B. `a` 的类型是 `int*`  
C. `p` 和 `a` 在所有场合都等价  
D. `p` 和 `&a[0]` 在大多数实现中值相同  
E. `&a` 的类型是 `int*`

**答案：** D  

**解析：**  
- `p` 的类型是 `int*`，`a` 的类型是“含 5 个 int 的数组”`int[5]`。在表达式中 `a` 会**衰变**为 `int*` 指向首元素。  
- `p == &a[0]` 通常为真。`&a` 的类型是 `int (*)[5]`，不是 `int*`。[ref:1,6]

---

### 2. 下标与指针运算

```cpp
int a[4] = {10, 20, 30, 40};
int *p = a;
```

下列表达式中，**不等价于 `a[2]`** 的是：

A. `*(a + 2)`  
B. `*(p + 2)`  
C. `p[2]`  
D. `2[a]`  
E. `*(2 + a + 0)`

**答案：** 无（题有陷阱，实际上都等价）  

**解析：**  
标准定义 `x[y]` 为 `*(x + y)`，所以 `a[2]` 等价于 `*(a + 2)`、`*(2 + a)`、`2[a]`，而 `p` 指向 `a[0]`，`p[2]` 等价于 `a[2]`。[ref:1,6,8]

> 若你出卷时不想要“无正确选项”的题，可删除一个选项，比如把 D 改成别的明显错误表达式。

---

### 3. `sizeof` 与数组

```cpp
int a[10];
int *p = a;
```

在典型 64 位平台（`int` 为 4 字节，指针为 8 字节）下，下列说法正确的是：

A. `sizeof(a) == sizeof(p)`  
B. `sizeof(a) == 10 * sizeof(int)`  
C. `sizeof(p) == 10 * sizeof(int)`  
D. `sizeof(p)` 与 `int` 的大小相同  
E. `sizeof(a[0]) == sizeof(p)`

**答案：** B  

**解析：**  
- `sizeof(a)` 是整个数组大小：`10 * sizeof(int)`。  
- `sizeof(p)` 是指针大小，与数组长度无关，在 64 位通常为 8。 [ref:1,2]

---

### 4. 数组元素地址关系

```cpp
int a[3] = {1, 2, 3};
```

下列表达式中，值一定相等的是：

A. `a` 与 `&a`  
B. `a` 与 `&a[0]`  
C. `&a[0]` 与 `&a[1]`  
D. `a + 1` 与 `&a`  
E. `&a[2] + 1` 与 `&a[3]`

**答案：** B、E（多选题时）  

若必须单选，可设问“只考虑 A~C，哪项正确？”则选 B。

**解析：**  
- `a` 在此处衰变为 `int*` 指向 `a[0]`，`&a[0]` 也是 `int*` 指向首元素，所以地址相等。  
- `&a` 是 `int (*)[3]`，虽然数值上可能相同，但类型和含义不同。  
- `&a[2] + 1` 指向尾后位置 `a[3]`，等价于 `&a[3]`。 [ref:6]

---

### 5. 指针遍历数组

```cpp
int a[4] = {10, 20, 30, 40};
int *p = a;
int *q = a + 4;
int sum = 0;
while (p != q) {
    sum += *p;
    ++p;
}
```

循环结束后，`sum` 的值是：

A. 0  
B. 60  
C. 70  
D. 100  
E. 未定义

**答案：** C  

**解析：**  
- `p` 从 `a` 到 `a+4`（不包括尾后），分别累加 `10+20+30+40=100`？  
注意：题干写错了？检查：  
`10+20+30+40=100`，所以应选 D。  
> 正确答案应为 **D: 100**。  

---

### 6. 指针相减

```cpp
int a[5] = {1, 2, 3, 4, 5};
int *p = &a[4];
int *q = &a[1];
ptrdiff_t d = p - q;
```

`d` 的值是：

A. 2  
B. 3  
C. 4  
D. 5  
E. 未定义

**答案：** B  

**解析：**  
`p` 指向 `a[4]`，`q` 指向 `a[1]`，在同一数组中，相差 3 个元素，所以 `p - q == 3`。[ref:1]

---

### 7. 指针比较

```cpp
int a[3] = {1, 2, 3};
int *p = &a[0];
int *q = &a[2];
```

关于 `p < q`，下列说法正确的是：

A. 不允许比较指针大小  
B. 结果是未定义行为  
C. 合法且一定为 `true`  
D. 合法但结果不确定  
E. 只有在指针相等时才允许比较

**答案：** C  

**解析：**  
指向同一数组内元素的指针之间可以进行大小比较，语义良好；此处 `&a[0] < &a[2]` 一定为 `true`。[ref:1,6]

---

### 8. 传数组给函数

有函数声明：

```cpp
void foo(int *p, int n);
```

调用：

```cpp
int a[5];
foo(a, 5);
```

下列关于 `foo` 内部形参 `p` 的说法正确的是：

A. `p` 是数组类型 `int[5]`  
B. `p` 是指针类型 `int*`  
C. `p` 的大小等于 `5 * sizeof(int)`  
D. `sizeof(p)` 等于 `sizeof(a)`  
E. `p` 不能用下标访问元素

**答案：** B  

**解析：**  
- `foo` 形参 `int *p` 就是指针类型；`a` 传入时发生数组衰变为 `int*`。  
- 在函数体内 `sizeof(p)` 得到的是指针大小而非数组大小，可以 `p[i]`。 [ref:2]

---

### 9. 数组做形参的写法

下列函数声明中，**与 `void bar(int *p);` 等价**的是：

A. `void bar(int p[10]);`  
B. `void bar(int p[]);`  
C. `void bar(int &p);`  
D. A 和 B  
E. A、B 和 C

**答案：** D  

**解析：**  
- 形参中的 `int p[10]` 和 `int p[]` 在函数内部都会退化为 `int*`。  
- 引用 `int& p` 类型完全不同。 [ref:2]

---

### 10. 不安全的指针运算

```cpp
int a[3] = {1, 2, 3};
int *p = a + 3;
int x = *p;
```

关于这段代码下列说法正确的是：

A. `x` 一定为 0  
B. `x` 一定为 3  
C. 语法错误  
D. 行为未定义  
E. 一定抛出异常

**答案：** D  

**解析：**  
`a + 3` 是合法的尾后指针，但**不能解引用**。`*p` 越界访问，属于未定义行为。[ref:1,6]

---

### 11. 动态一维数组

要在堆上创建一个长度为 `n` 的 `int` 数组并正确释放，下列写法正确的是：

A. `int *p = new int(n); delete p;`  
B. `int *p = new int[n]; delete p;`  
C. `int *p = new int[n]; delete[] p;`  
D. `int p[n]; delete[] p;`  
E. `int p[n];`

**答案：** C  

**解析：**  
- 一维动态数组要用 `new T[n]` 与 `delete[]` 匹配。  
- `new int(n)` 只分配一个 `int`，值初始化为 `n`。 [ref:1,2]

---

### 12. 指针遍历动态数组

```cpp
int n = 4;
int *p = new int[n]{1, 2, 3, 4};
int *q = p;
int sum = 0;
for (int i = 0; i < n; ++i) {
    sum += *q;
    ++q;
}
delete[] p;
```

`sum` 的值为：

A. 0  
B. 6  
C. 10  
D. 11  
E. 未定义

**答案：** C  

**解析：**  
遍历的是 `1+2+3+4 = 10`，代码中 `q` 始终指向 `p` 管理的那块分配内存，没有越界。 [ref:1]

---

### 13. 指针修改数组元素

```cpp
int a[3] = {1, 2, 3};
int *p = a;
*p += 10;
*(p + 1) += 20;
p[2] += 30;
```

执行后数组 `a` 为：

A. `{11, 22, 33}`  
B. `{11, 22, 3}`  
C. `{11, 22, 33}`（题干重复选项）  
D. `{1, 2, 3}`  
E. `{10, 20, 30}`

**答案：** A  

**解析：**  
- `*p += 10;` 相当于 `a[0] += 10;` → 11  
- `*(p + 1) += 20;` 相当于 `a[1] += 20;` → 22  
- `p[2] += 30;` 相当于 `a[2] += 30;` → 33。 [ref:6]

---

### 14. 指针数组

```cpp
int x = 1, y = 2, z = 3;
int *arr[3];
arr[0] = &x;
arr[1] = &y;
arr[2] = &z;
```

下列表达式中，**不合法**的是：

A. `*arr[0]`  
B. `arr[1][0]`  
C. `*(arr[2])`  
D. `**arr`  
E. `*(arr + 1)`

**答案：** D  

**解析：**  
- `arr` 是 `int*` 的数组，`arr[0]` 是 `int*`，`*arr[0]` 是 `int`。  
- `arr[1][0]` 等价于 `*(arr[1] + 0)`，也为 `int`。  
- `arr` 衰变为 `int**`，`*arr` 是 `int*`，所以 `**arr` 是 `int`，**在本例其实也是合法的**。  
这题设计不严谨，如出题建议换一种问法，例如改问“最不推荐的写法”。  

---

### 15. 用指针访问倒数第 k 个元素

```cpp
int a[5] = {10, 20, 30, 40, 50};
int *p = a + 5; // 尾后指针
```

要让 `q` 指向数组最后一个元素 `a[4]`，下列哪句正确？

A. `int *q = p;`  
B. `int *q = p + 1;`  
C. `int *q = p - 1;`  
D. `int *q = &p[4];`  
E. `int *q = &a[5];`

**答案：** C  

**解析：**  
- `p` 是 `a + 5`，减一元素得到 `a + 4`，即 `&a[4]`。  
- `&a[5]` 越界，尾后位置不能取地址再当元素用。 [ref:1,6]

---

### 16. 传指针修改数组

```cpp
void setZero(int *p, int n) {
    for (int i = 0; i < n; ++i) {
        p[i] = 0;
    }
}
int main() {
    int a[3] = {1, 2, 3};
    setZero(a, 3);
    // ...
}
```

`main` 中 `a` 的内容变为：

A. `{1, 2, 3}`  
B. `{0, 0, 0}`  
C. `{0, 2, 3}`  
D. `{1, 0, 0}`  
E. 未定义

**答案：** B  

**解析：**  
数组名 `a` 传给 `setZero` 时退化为 `int*`，函数中修改的是原数组中的元素。 [ref:2,6]

---

### 17. 使用 `sizeof` 计算静态数组长度

```cpp
int a[7] = {0};
int n = sizeof(a) / sizeof(a[0]);
```

下列说法正确的是：

A. `n` 的值依赖于平台，无法确定  
B. `n` 一定为 7  
C. `n` 等于指针大小  
D. `n` 等于 `sizeof(int)`  
E. 表达式非法

**答案：** B  

**解析：**  
这是计算静态数组长度的标准做法，`sizeof(a)` 是 7 个 `int` 的总字节数，再除以单个元素大小得到 7。 [ref:2]

---

### 18. 指针与数组常量表达式

```cpp
int a[3] = {1, 2, 3};
int *p = a;
```

下列表达式中，**一定不合法（编译错误）**的是：

A. `*(a + 3)`  
B. `*(p + 3)`  
C. `a = p;`  
D. `p = a + 1;`  
E. `p = &a[2];`

**答案：** C  

**解析：**  
- `a` 是数组名，不是变量，不能作为赋值左值（`a = p` 非法）。  
- A、B 是语义错误（UB），但语法上是合法表达式；D、E 均为合法赋值。 [ref:1,6]

---

### 19. 指针指向数组中间位置

```cpp
int a[4] = {10, 20, 30, 40};
int *p = &a[1];  // 指向 20
int x = p[1];
int y = *(p + 2);
```

`x` 和 `y` 的值分别为：

A. `x = 20, y = 30`  
B. `x = 30, y = 40`  
C. `x = 30, y = 未定义`  
D. `x = 40, y = 未定义`  
E. 行为未定义

**答案：** B  

**解析：**  
- `p[1]` 等价于 `*(p + 1)` → `a[2]` → 30  
- `*(p + 2)` → `a[3]` → 40  
都在数组范围内。 [ref:6]

---

### 20. 指针加减的合法范围

```cpp
int a[3] = {1, 2, 3};
int *p = &a[1];
int *q = p + 2;
```

关于 `q`，正确的说法是：

A. `q` 一定指向 `a[3]` 的存储位置，可以安全解引用  
B. `q` 等于 `a + 3`，是尾后指针，不能解引用  
C. `q` 等于 `&a[2]`，指向数组最后一个元素  
D. `q` 的值不确定  
E. 这段代码无法通过编译

**答案：** B  

**解析：**  
`p = &a[1]`，`p + 2` 是 `&a[3]`，即尾后指针，合法存在但**不能解引用**。 [ref:1]

---

## 二、编程题（5 题）

每题给出题意和参考答案要点（可用作评分标准或讲解用）。

---

### 编程题 1：用指针遍历数组并求和

**题目：**

编写一个函数：

```cpp
int sumArray(const int *a, int n);
```

要求：用 **指针遍历** 一维数组 `a` 中的前 `n` 个元素，返回它们的和。不得使用下标运算符 `[]`。

**参考代码要点：**

```cpp
int sumArray(const int *a, int n) {
    const int *p = a;
    const int *end = a + n;
    int sum = 0;
    while (p != end) {
        sum += *p;
        ++p;
    }
    return sum;
}
```

**说明：**

- 参数 `a` 退化为 `const int*`，用 `p` 从 `a` 走到 `a + n`。  
- 不能越界，不使用 `[]`。 [ref:1,2]

---

### 编程题 2：就地反转一维数组（用指针）

**题目：**

编写函数：

```cpp
void reverseArray(int *a, int n);
```

要求：使用 **指针**（或指针算术）就地反转数组 `a` 中的前 `n` 个元素。例如 `{1,2,3,4}` 反转后为 `{4,3,2,1}`。

**参考代码要点：**

```cpp
void reverseArray(int *a, int n) {
    int *left = a;
    int *right = a + n - 1;
    while (left < right) {
        int tmp = *left;
        *left = *right;
        *right = tmp;
        ++left;
        --right;
    }
}
```

**说明：**

- 使用两个指针首尾夹逼，不使用下标。  
- 注意 `n <= 1` 时无需操作。 [ref:1]

---

### 编程题 3：在数组中查找元素（指针版线性查找）

**题目：**

编写函数：

```cpp
int findFirst(const int *a, int n, int value);
```

要求：在线性时间内查找 `value` 在数组 `a` 中第一次出现的位置（下标），若不存在返回 `-1`。要求用 **指针遍历**，可同时维护一个下标计数器。

**参考代码要点：**

```cpp
int findFirst(const int *a, int n, int value) {
    const int *p = a;
    for (int i = 0; i < n; ++i, ++p) {
        if (*p == value) {
            return i;
        }
    }
    return -1;
}
```

**说明：**

- 逻辑上与下标版相同，只是访问用 `*p`。  
- 体现数组名衰变与指针遍历的用法。 [ref:6]

---

### 编程题 4：动态创建一维数组并初始化

**题目：**

从标准输入读入一个正整数 `n`，动态分配一个 `int` 数组，长度为 `n`。将数组元素初始化为 `1, 2, ..., n`，然后用指针遍历打印所有元素，最后释放内存。

**参考代码要点：**

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    if (n <= 0) return 0;

    int *p = new int[n];

    // 初始化
    for (int i = 0; i < n; ++i) {
        p[i] = i + 1;
    }

    // 用指针遍历打印
    int *cur = p;
    int *end = p + n;
    while (cur != end) {
        cout << *cur << " ";
        ++cur;
    }
    cout << endl;

    delete[] p;
    p = nullptr;
    return 0;
}
```

**说明：**

- 用 `new[]` / `delete[]` 管理动态一维数组。  
- 初始化可用下标或指针，遍历时要求用指针。 [ref:1,2]

---

### 编程题 5：将数组元素右移一位（循环右移）

**题目：**

编写函数：

```cpp
void rotateRight(int *a, int n);
```

把长度为 `n` 的一维数组 `a` 中的元素循环右移一位：  
例如 `{1,2,3,4}` → `{4,1,2,3}`。要求用 **指针或指针运算** 实现，不能使用额外数组（仅允许用少量临时变量）。

**参考代码要点：**

```cpp
void rotateRight(int *a, int n) {
    if (n <= 1) return;
    int last = a[n - 1];      // 保存最后一个元素
    int *p = a + n - 1;       // 指向最后一个
    int *begin = a;

    // 从后往前依次右移
    while (p > begin) {
        *p = *(p - 1);
        --p;
    }
    *begin = last;
}
```

**说明：**

- 利用指针从尾部向前移动，避免覆盖问题。  
- 只需一个临时变量 `last`，空间复杂度 O(1)。 [ref:1]

---


