## 1. 什么是 C++ 函数模板（Function Template）

 **函数模板** ：把“类型”当作参数写进函数，使一个函数的算法/逻辑可以适用于多种类型。编译器会在用到时根据实参**推导模板参数**并生成对应类型的函数（实例化，instantiation）。

形象类比：

* 普通函数像“ **做一双 42 码鞋** ”：只能给特定尺码的人穿。
* 函数模板像“ **鞋的纸样** ”：你给我尺码（类型），我按纸样裁出对应尺码的鞋（生成对应版本函数）。

---

## 2. 最基础语法：`template <typename T>`

```cpp
#include <iostream>

template <typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    std::cout << add(1, 2) << '\n';       // T 推导为 int
    std::cout << add(1.5, 2.3) << '\n';   // T 推导为 double
}
```

要点：

* `typename T` 和 `class T` 在模板参数里等价（都表示“类型参数”）。
* 编译器根据调用 `add(1, 2)` 推导出 `T=int`，生成 `int add(int,int)` 的实例。

---

## 3. 显式指定模板参数 vs 自动推导

### 3.1 自动推导（最常用）

```cpp
add(1, 2);      // T=int
add(1.0, 2.0);  // T=double
```

### 3.2 显式指定（当推导失败或你想强制类型）

```cpp
std::cout << add<double>(1, 2.5) << '\n'; // 强制 T=double，1 会转成 double
```

---

## 4. 模板参数推导规则：为什么 `add(1, 2.5)` 会失败？

上面 `add` 的签名是 `T add(T, T)`：两个参数必须是 **同一个 T** 。

```cpp
// add(1, 2.5); // 错：一个是 int，一个是 double，无法推导出同一个 T
```

解决思路有两种：

### 4.1 调用者显式指定

```cpp
add<double>(1, 2.5);
```

### 4.2 让模板支持“不同类型参数”（两个模板参数）

```cpp
#include <type_traits>

template <typename A, typename B>
auto add2(A a, B b) -> std::common_type_t<A, B> {
    using R = std::common_type_t<A, B>;
    return static_cast<R>(a) + static_cast<R>(b);
}

int main() {
    std::cout << add2(1, 2.5) << '\n'; // R 推导为 double
}
```

---

## 5. 函数模板也能重载（与普通函数一起参与重载决议）

```cpp
#include <iostream>

void print(int x) {
    std::cout << "non-template int: " << x << '\n';
}

template <typename T>
void print(const T& x) {
    std::cout << "template: " << x << '\n';
}

int main() {
    print(10);        // 优先选更匹配的非模板版本
    print(3.14);      // 没有非模板 double，就用模板
}
```

规则直觉版：

* 如果普通函数和模板都能匹配，且普通函数“同等匹配或更好”，通常优先普通函数。
* 否则用模板。

---

## 6. `const T&`：模板里最常用的参数写法之一

```cpp
template <typename T>
void show(const T& x) {
    // const&：避免拷贝、可绑定左值/右值
}
```

但注意：如果要修改实参，才用 `T&`；如果要接收右值并“接管资源”，会用右值引用/转发引用（见后文）。

---

## 7. 特化与偏特化：函数模板“不能偏特化”，但可以重载/全特化

### 7.1 函数模板不支持偏特化（重点）

类模板能偏特化，但 **函数模板不能偏特化** 。想实现类似效果，通常用：

* **重载**
* `if constexpr`（C++17）
* Concepts/`requires`（C++20）

### 7.2 函数模板可以“全特化”（不常用，但存在）

```cpp
#include <iostream>
#include <string>

template <typename T>
void info(const T&) {
    std::cout << "generic\n";
}

// 全特化：T=std::string
template <>
void info<std::string>(const std::string&) {
    std::cout << "string\n";
}

int main() {
    info(1);                    // generic
    info(std::string("hi"));    // string
}
```

实践中更常用“重载”替代全特化（可读性通常更好）。

---

## 8. `if constexpr`：让模板“按类型走不同分支”（C++17）

```cpp
#include <iostream>
#include <type_traits>
#include <string>

template <typename T>
void describe(const T& x) {
    if constexpr (std::is_integral_v<T>) {
        std::cout << "integral: " << x << '\n';
    } else if constexpr (std::is_floating_point_v<T>) {
        std::cout << "floating: " << x << '\n';
    } else {
        std::cout << "other type\n";
    }
}

int main() {
    describe(10);
    describe(3.14);
    describe(std::string("hi"));
}
```

`if constexpr` 的好处：不走的分支不会参与编译（避免不合法代码报错）。

---

## 9. 转发引用（万能引用）与 `std::forward`（进阶但很常用）

当你写：

```cpp
template <typename T>
void wrapper(T&& x);
```

这里的 `T&&` 在模板参数推导时可能是 **转发引用** ：能保持实参的左值/右值属性。

经典写法（完美转发）：

```cpp
#include <utility>

template <typename F, typename... Args>
decltype(auto) call(F&& f, Args&&... args) {
    return std::forward<F>(f)(std::forward<Args>(args)...);
}
```

用途：写“包装器/中转函数”时，不丢失引用/const/右值信息。

（如果你还没学到引用折叠规则，这段先当“见过即可”。）

---

# 小练习（含答案）

## 练习 1：模板参数推导（能否通过编译？输出是什么？）

```cpp
#include <iostream>

template <typename T>
T max2(T a, T b) {
    return (a < b) ? b : a;
}

int main() {
    std::cout << max2(3, 7) << '\n';
    std::cout << max2(2.5, 1.2) << '\n';
    // std::cout << max2(1, 2.5) << '\n';
}
```

**答案：**

* `max2(3,7)`：`T=int`，输出 `7`
* `max2(2.5,1.2)`：`T=double`，输出 `2.5`
* `max2(1,2.5)`：❌ 不能通过：`T` 无法同时推导为 `int` 和 `double`

  修复：`max2<double>(1, 2.5)` 或改成双模板参数版本。

---

## 练习 2：写一个支持不同类型的 `max`（返回公共类型）

 **要求** ：实现 `max_any(a,b)`，支持 `int` 和 `double` 混用，返回 `std::common_type_t<A,B>`。

**参考答案：**

```cpp
#include <type_traits>

template <typename A, typename B>
std::common_type_t<A, B> max_any(A a, B b) {
    using R = std::common_type_t<A, B>;
    return (static_cast<R>(a) < static_cast<R>(b)) ? static_cast<R>(b) : static_cast<R>(a);
}
```

---

## 练习 3：模板 + 重载优先级（选哪个？）

```cpp
#include <iostream>

void show(int) { std::cout << "non-template\n"; }

template <typename T>
void show(T) { std::cout << "template\n"; }

int main() {
    show(10);
    show(3.14);
}
```

**答案：**

* `show(10)`：调用普通函数，输出 `non-template`
* `show(3.14)`：没有普通 `double` 版本，调用模板，输出 `template`

---

## 练习 4：用 `if constexpr` 区分整型与其他类型

补全下面函数：整型打印 `"int-like"`，否则打印 `"other"`。

```cpp
#include <iostream>
#include <type_traits>

template <typename T>
void tag(const T& x) {
    // TODO
}

int main() {
    tag(1);
    tag(3.14);
}
```

**参考答案：**

```cpp
template <typename T>
void tag(const T& x) {
    (void)x;
    if constexpr (std::is_integral_v<T>) {
        std::cout << "int-like\n";
    } else {
        std::cout << "other\n";
    }
}
```

输出：

```
int-like
other
```

---

## 练习 5（进阶）：写一个 `print_all`（可变参模板）

实现 `print_all(a,b,c,...)`，把所有参数按空格分隔输出，最后换行。

**参考答案：**

```cpp
#include <iostream>

template <typename... Args>
void print_all(const Args&... args) {
    ((std::cout << args << ' '), ...);
    std::cout << '\n';
}

int main() {
    print_all(1, 2.5, "hi");
}
```

输出示例：

```
1 2.5 hi 
```

---

如果你告诉我你当前的标准是  **C++11 / C++14 / C++17 / C++20** ，我可以把例子完全限定在你能用的语法范围内（比如没有 `if constexpr` 的话用 `enable_if` 版本）。
