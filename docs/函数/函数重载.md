## 1. 什么是 C++ 函数重载（Overload）

 **函数重载** ：在同一作用域中，允许存在 **同名函数** ，但它们的 **参数列表不同** （数量、类型、顺序不同）。编译器会在**编译期**根据实参决定调用哪一个，这叫  **重载决议（overload resolution）** 。

形象类比：

* 同一个“按钮”叫 `print`，但你给它的东西不同：给 `int` 就走“打印整数”的通道；给 `std::string` 就走“打印字符串”的通道。
* 像“同名窗口”：都叫“办理业务”，但你递上去的是“身份证/护照/驾驶证”，工作人员会把你导向不同流程。

---

## 2. 重载成立的条件：看“参数列表”，不看“返回类型”

### 2.1 允许的不同点（构成重载）

* 参数**个数**不同：`f(int)` vs `f(int, int)`
* 参数**类型**不同：`f(int)` vs `f(double)`
* 参数**顺序**不同：`f(int, double)` vs `f(double, int)`
* `const` 限定对**引用/指针形参**可形成重载（见后文）

### 2.2 不允许的不同点（不能仅靠这些重载）

* **只改返回值类型**不算重载：

```cpp
int  foo(int x);
double foo(int x); // 错：仅返回值不同，参数列表相同
```

原因：调用 `foo(1)` 时，光看实参无法确定你想要哪种返回值。

---

## 3. 最直观例子：同名函数处理不同类型

```cpp
#include <iostream>
#include <string>

void print(int x) {
    std::cout << "int: " << x << '\n';
}

void print(double x) {
    std::cout << "double: " << x << '\n';
}

void print(const std::string& s) {
    std::cout << "string: " << s << '\n';
}

int main() {
    print(42);                 // 调 print(int)
    print(3.14);               // 调 print(double)
    print(std::string("Hi"));  // 调 print(const std::string&)
}
```

---

## 4. 重载决议在干什么：编译器如何“选最合适的”

大体原则：**能匹配的候选函数**里选“转换代价最小”的那个。

常见转换从“更好”到“更差”（粗略理解）：

1. **精确匹配** （不需要转换）：`int -> int`
2. **提升** （promotion）：`char/short -> int`，`float -> double`
3. **一般标准转换** ：`int -> double`，`double -> int` 等
4. **用户自定义转换** （构造/类型转换运算符）
5. **省略号 `...`** （最差）

### 4.1 精确匹配优先：示例

```cpp
#include <iostream>

void f(int)    { std::cout << "f(int)\n"; }
void f(double) { std::cout << "f(double)\n"; }

int main() {
    f(10);    // 精确：f(int)
    f(2.5);   // 精确：f(double)
    f('A');   // 'A' 是 char，提升到 int：更偏向 f(int)
}
```

---

## 5. 容易混淆的点：`const` 与引用重载

### 5.1 `T&` vs `const T&` 可以重载

```cpp
#include <iostream>

void g(int& x) {
    std::cout << "g(int&)\n";
    ++x;
}

void g(const int& x) {
    std::cout << "g(const int&)\n";
    (void)x;
}

int main() {
    int a = 5;
    g(a);   // 非 const 左值：匹配 g(int&)
    g(10);  // 右值：不能绑定到 int&，匹配 g(const int&)
}
```

形象理解：

* `int&` 像“可改原件”的通道，只接收“可写的原件”（非 const 左值）。
* `const int&` 像“复印/只读”的通道，原件/复印件都能进，但不会修改。

### 5.2 仅 `int` vs `const int` 不能重载（值传递看不出 const）

```cpp
void h(int x);
void h(const int x); // 错：等价签名，不能重载
```

---

## 6. 默认参数 vs 重载：可能产生二义性

默认参数会让一个函数“看起来”像多个签名，容易和重载撞车。

```cpp
#include <iostream>

void p(int x, int y = 0) {
    std::cout << "p(int,int)\n";
}

void p(int x) {
    std::cout << "p(int)\n";
}

int main() {
    // p(1); // 错：二义性！两个都能匹配：p(int) 与 p(int,int=0)
}
```

经验法则：**默认参数**和**重载**二选一组织同一套接口，避免混用造成歧义。

---

## 7. 重载与模板：非模板优先、特化/更匹配优先（入门版）

```cpp
#include <iostream>

void q(int) {
    std::cout << "q(int)\n";
}

template <class T>
void q(T) {
    std::cout << "q(T)\n";
}

int main() {
    q(1);    // 选非模板 q(int)
    q(1.2);  // 只有模板更合适：q(T)
}
```

---

## 8. 常见“翻车现场”：二义性（ambiguous）

### 8.1 `long` 与 `double` 之间的二义性示例

```cpp
#include <iostream>

void r(long)   { std::cout << "r(long)\n"; }
void r(double) { std::cout << "r(double)\n"; }

int main() {
    // r(1); // 可能二义性：1 是 int，转 long 或转 double 都是标准转换，谁更好？编译器可能报 ambiguous
}
```

解决方法：

```cpp
r(1L);    // 指定 long
r(1.0);   // 指定 double
```

（是否二义性与具体重载集有关，但原则是： **别让编译器猜** 。）

---

# 小练习（含答案）

## 练习 1：判断能否构成重载（并说明原因）

下面每组声明是否能共存？

```cpp
void a(int);
void a(double);
```

```cpp
int  b(int);
double b(int);
```

```cpp
void c(int);
void c(const int);
```

```cpp
void d(int&);
void d(const int&);
```

### 答案

1. ✅ 能：参数类型不同。
2. ❌ 不能：只改返回值，参数列表相同。
3. ❌ 不能：按值传参时 `int` 与 `const int` 等价签名。
4. ✅ 能：`int&` 与 `const int&` 是不同参数类型，可重载。

---

## 练习 2：写出每次调用选中哪个重载（预测输出）

```cpp
#include <iostream>

void f(int)    { std::cout << "int\n"; }
void f(double) { std::cout << "double\n"; }

int main() {
    f(1);
    f(1.0);
    f('A');
}
```

### 答案

* `f(1)`：`int`
* `f(1.0)`：`double`
* `f('A')`：`int`（`char` 提升到 `int`）

输出：

```
int
double
int
```

---

## 练习 3：引用重载：分别调用哪一个？变量值如何变化？

```cpp
#include <iostream>

void g(int& x) { ++x; std::cout << "g(int&) x=" << x << '\n'; }
void g(const int& x) { std::cout << "g(const int&) x=" << x << '\n'; }

int main() {
    int a = 10;
    g(a);
    g(10);
    std::cout << "a=" << a << '\n';
}
```

### 答案

* `g(a)`：调用 `g(int&)`，`a` 被加 1，打印 `g(int&) x=11`
* `g(10)`：`10` 是右值，不能绑定到 `int&`，调用 `g(const int&)`，打印 `g(const int&) x=10`
* 最后 `a=11`

---

## 练习 4：修复二义性（写两种调用方式）

```cpp
void r(long);
void r(double);

int main() {
    r(1); // 让它不二义
}
```

### 答案（任意两种）

```cpp
r(1L);   // 选 long
r(1.0);  // 选 double
// 或者：
r(static_cast<long>(1));
r(static_cast<double>(1));
```

---

## 练习 5（综合）：设计一组合理的重载

需求：实现 `area(...)`：

* 圆：半径 `double r`
* 矩形：长宽 `double w, double h`
* 正方形：边长 `double a`（可复用矩形版本）

### 参考答案

```cpp
#include <iostream>

double area(double r) {
    // 圆面积：πr^2
    const double pi = 3.141592653589793;
    return pi * r * r;
}

double area(double w, double h) {
    return w * h;
}

double area_square(double a) {   // 也可以做成 area(double a, int /*tag*/)
    return area(a, a);
}

int main() {
    std::cout << area(2.0) << '\n';        // 圆
    std::cout << area(3.0, 4.0) << '\n';   // 矩形
    std::cout << area_square(5.0) << '\n'; // 正方形
}
```

如果你希望“正方形也叫 `area`”而不是 `area_square`，可以告诉我你是否接受用“标签参数”（如 `area(double a, SquareTag)`）或用类/结构体来区分（更类型安全）。
