
# 1. 递归函数讲义（优化版）

## 1.1 学习目标
学完本节课，你应能：
1. 理解递归函数的含义，并指出递归必须具备的两个要素。
2. 能读懂并编写常见的递归：斐波那契、网格路径（杨辉三角思想）。
3. 能发现并修复无限递归的问题。
4. 知道递归的优缺点：思路直观，但可能慢、可能栈溢出，需要控制规模。

---

## 1.2 重点与难点
- **重点**
  - 伪随机/真随机（背景理解）与递归的基本思想
  - 种子/边界条件（递归出口）的作用
  - 递推公式：把大问题拆成小问题
- **难点**
  - 退出条件与规模缩小的设计
  - 递归调用位置对执行顺序的影响
  - 大规模递归的性能与栈深风险

---

## 1.3 递归函数是什么
C++ 允许函数**调用它自身**。这种“自己调用自己”的嵌套调用称为**递归调用**，包含递归调用的函数称为**递归函数**。

> 约束提示：`main()` 一般不作为递归函数来写（课程/规范中通常要求递归发生在 `main` 之外的普通函数中）。

形象理解：递归像“套娃”。每一层把问题缩小一点，直到最小问题能直接解决，再一层层返回答案。

---

## 1.4 递归函数的基本结构
递归函数与普通函数形式相同，只是函数体内部出现对自身的调用。

### 1.4.1 无返回值（`void`）
```cpp
void f(...) {
    // 处理当前层的一些事情（可选）
    f(...);  // 递归调用
    // 处理返回后的事情（可选）
}
```

### 1.4.2 有返回值（`int / double / ...`）
```cpp
int f(...) {
    // 处理当前层的一些事情（可选）
    int a = f(...);  // 递归得到子问题结果
    // 利用 a 计算当前层结果
    return ...;
}
```

课堂提醒：递归调用位置会影响输出顺序。
- **递归前处理/输出**：先做当前层，再深入
- **递归后处理/输出**：先深入到最底，再回溯处理

---

## 1.5 递归的两个核心要素（缺一不可）
写递归时，必须同时满足：

### 1.5.1 递推公式（把大问题变小）
描述问题如何拆分为更小的子问题，例如 \(f(n)\) 与 \(f(n-1)\) 的关系。

### 1.5.2 退出条件（递归出口）
当问题小到可以直接得到答案时停止递归，防止无限递归。

> 口诀：**有递推，更要有出口。**

---

## 1.6 常见错误：无限递归
没有设置退出条件或规模没有变小，会导致递归永远停不下来，最终出现**栈溢出**。

### 1.6.1 错误示例：“从前有一座山……”
```cpp
#include <iostream>
using namespace std;

void f() {
    cout << "从前有一座山……\n";
    f(); // 无条件调用自身：永远不会停
}

int main() {
    f();
    return 0;
}
```

### 1.6.2 修正：加入参数并设置出口
```cpp
#include <iostream>
using namespace std;

void f(int t) {
    cout << "从前有一座山……\n";
    t++;
    if (t < 100) {  // 退出条件
        f(t);       // 递推：t 逐步增加，最终到达出口
    }
}

int main() {
    f(0);
    return 0;
}
```

---

## 1.7 经典案例 1：斐波那契数列（Fibonacci）
### 1.7.1 问题描述
数列：1, 1, 2, 3, 5, 8, 13, …  
求第 \(n\) 项。

### 1.7.2 递推公式与退出条件
\[
f(n)=
\begin{cases}
1, & n=1 \text{ 或 } n=2 \\
f(n-1)+f(n-2), & n>2
\end{cases}
\]

### 1.7.3 代码实现
```cpp
#include <iostream>
using namespace std;

int fib(int n) {
    if (n == 1 || n == 2) {      // 退出条件
        return 1;
    } else {                      // 递推公式
        return fib(n - 1) + fib(n - 2);
    }
}

int main() {
    int n;
    cin >> n;
    cout << fib(n) << endl;
    return 0;
}
```

### 1.7.4 课堂提示（性能）
该递归写法直观，但会产生大量重复计算，\(n\) 稍大就会变慢。后续可用循环或动态规划优化。

---

## 1.8 经典案例 2：网格路径数（杨辉三角思想）
### 1.8.1 问题描述
一只蚂蚁从 (1,1) 走到 (x,y)，只能**向右**或**向下**，求不同走法数量。

### 1.8.2 分析（边界 + 递推）
- **边界（退出条件）**：第一行或第一列都只有 1 种走法  
  \(f(1,y)=1,\ f(x,1)=1\)
- **递推公式**：到达某格子的走法 = 从上面来 + 从左边来  
  \(f(x,y)=f(x-1,y)+f(x,y-1)\)

### 1.8.3 代码实现
```cpp
#include <iostream>
using namespace std;

int paths(int x, int y) {
    if (x == 1 || y == 1) {      // 退出条件（边界）
        return 1;
    } else {                      // 递推公式
        return paths(x - 1, y) + paths(x, y - 1);
    }
}

int main() {
    int x, y;
    cin >> x >> y;
    cout << paths(x, y) << endl;
    return 0;
}
```

课堂提示：该写法同样会重复计算；当 \(x,y\) 较大时会很慢，后续可用表格法优化。

---

## 1.9 递归的优缺点（小结）
### 1.9.1 优点
- 思路自然：适合“结构相同、规模变小”的问题
- 代码简洁：贴合数学定义

### 1.9.2 缺点
- 可能很慢：重复计算多
- 可能栈溢出：递归层数过深
- 调试不直观：调用层级多

---

## 2. 课堂练习（含答案）

### 2.1 练习 1：阶乘 \(n!\)
**题目**：用递归计算 \(n!\)，规定 \(0!=1\)。

**参考答案：**
```cpp
#include <iostream>
using namespace std;

long long fact(int n) {
    if (n == 0) return 1;            // 退出条件
    return 1LL * n * fact(n - 1);    // 递推
}

int main() {
    int n;
    cin >> n;
    cout << fact(n) << endl;
    return 0;
}
```

---

### 2.2 练习 2：求和 \(1+2+\cdots+n\)
**参考答案：**
```cpp
#include <iostream>
using namespace std;

long long sumN(int n) {
    if (n == 1) return 1;         // 退出条件
    return sumN(n - 1) + n;       // 递推
}

int main() {
    int n;
    cin >> n;
    cout << sumN(n) << endl;
    return 0;
}
```

---

### 2.3 练习 3：倒序输出数字
**题目**：输入正整数 n（不含前导 0），递归输出其从右到左的每一位。  
例：输入 12345 输出 54321。

**参考答案：**
```cpp
#include <iostream>
using namespace std;

void printRev(int n) {
    cout << (n % 10);
    if (n >= 10) printRev(n / 10); // 出口：n<10 时停止递归
}

int main() {
    int n;
    cin >> n;
    printRev(n);
    cout << endl;
    return 0;
}
```

---

### 2.4 练习 4：网格路径数
**题目**：输入 m、n，输出从 (1,1) 到 (m,n) 只能向右/向下的路径数。  
**参考答案**：调用本讲 `paths(m,n)`（见 1.8.3）。

---

## 3. 递归写作自检清单
1. 出口条件是什么？（何时停止）
2. 每次递归规模是否变小？（是否保证能到达出口）
3. 子问题结果如何合成当前结果？（返回值怎么用）
4. 数据范围多大？（会不会慢/会不会栈溢出）
