
## 1. 什么是“函数静态变量”（static local variable）

在 **C++** 里，**函数内部用 `static` 修饰的局部变量**叫“函数静态变量”（更准确： *static storage duration 的局部变量* ）。

它的关键性质：

1. **作用域（scope）** ：仍然是局部的，只能在该函数（或该语句块）内访问。
2. **生命周期（lifetime）** ：具有静态存储期，程序结束才销毁（不是函数返回就销毁）。
3. **初始化** ：只初始化一次——**第一次执行到声明处**时进行初始化；之后每次调用沿用上一次的值。

* C++11 起：这种初始化是**线程安全**的（保证只初始化一次）。

形象类比：

* 普通局部变量像“一次性便签”：每次进函数重新写，出函数就没了。
* 函数静态变量像“抽屉里的本子”：只在这个房间（函数）里能拿到，但每次进来都会翻到同一本，内容会保留。

---

## 2. 最经典用途：记住上一次调用的状态

### C++ 示例：计数器（每调用一次就 +1）

```cpp
#include <iostream>

void visit() {
    static int count = 0;  // 只初始化一次
    ++count;
    std::cout << "visit count = " << count << '\n';
}

int main() {
    visit(); // 1
    visit(); // 2
    visit(); // 3
}
```

如果把 `static` 去掉：

```cpp
int count = 0;
```

那么每次进入 `visit()` 都会重新创建并初始化 `count`，输出永远是 1。

---

## 3. 作用域 vs 生命周期：容易混淆的点

### “看不见”但“还活着”

```cpp
#include <iostream>

void f() {
    static int x = 10;
    x += 5;
    std::cout << x << '\n';
}

int main() {
    // std::cout << x << '\n'; // 编译错误：x 在这里不可见（作用域只在 f 内）
    f(); // 15
    f(); // 20
}
```

---

## 4. 初始化细节（C++ 常考点）

### 4.1 默认初始化为 0（静态存储期的对象）

```cpp
#include <iostream>

void g() {
    static int a; // 静态存储期：零初始化 -> a 初始为 0
    ++a;
    std::cout << a << '\n';
}

int main() {
    g(); // 1
    g(); // 2
}
```

### 4.2 初始化只发生一次（C++11 起线程安全）

```cpp
#include <iostream>

int foo() {
    static int v = [] { return 100; }(); // 该 lambda 只会执行一次
    return v++;
}

int main() {
    std::cout << foo() << '\n'; // 100
    std::cout << foo() << '\n'; // 101
}
```

> C++11 起，函数内静态变量的初始化由标准保证“只初始化一次”，并且在多线程下是安全的（不会并发初始化多次）。

---

## 5. 和“全局变量”的区别

| 项目     | 函数静态变量（局部 `static`）        | 全局变量                     |
| -------- | -------------------------------------- | ---------------------------- |
| 可见范围 | 仅函数/块内部                          | 全局可见（取决于声明与链接） |
| 生命周期 | 程序全程                               | 程序全程                     |
| 典型用途 | 把状态封装在函数里（外部不可直接访问） | 共享状态（更容易耦合）       |

函数静态变量常用来 **封装状态** ：外部访问不到，更不容易被误改。

---

## 6. 更形象的例子：生成递增 ID（取号机）

```cpp
#include <iostream>

int next_id() {
    static int id = 1000;
    return id++; // 每次调用返回不同 id
}

int main() {
    std::cout << next_id() << '\n'; // 1000
    std::cout << next_id() << '\n'; // 1001
    std::cout << next_id() << '\n'; // 1002
}
```

---

## 7. 常见坑与最佳实践（C++ 视角）

### 坑 1：状态“忘了重置”

静态变量会一直保留，导致测试用例之间相互影响。

 **思路** ：提供显式重置函数/参数，或改为把状态放进对象里（由对象管理生命周期）。

### 坑 2：并发下的共享状态

初始化虽线程安全，但对静态变量的**读写操作**未必安全（例如 `++count` 不是原子操作）。

 **思路** ：用 `std::atomic<int>` 或互斥锁 `std::mutex` 保护。

### 坑 3：函数变得“不纯”

函数结果依赖历史调用，推理难、复用难。

 **思路** ：能用参数/返回值表达的状态，尽量别藏在静态变量里。

---

## 8. 小练习（C++ 版）

### 练习 1：预测输出

```cpp
#include <iostream>

void p() {
    static int x = 1;
    int y = 1;
    x += 2;
    y += 2;
    std::cout << "x=" << x << " y=" << y << '\n';
}

int main() {
    p();
    p();
    p();
}
```

问题：三次输出分别是什么？

---

### 练习 2：只在第一次打印欢迎语

需求：多次调用 `welcome()`，只有第一次打印 `Hello!`。

提示：`static bool printed = false;`

---

### 练习 3：实现一个“限流器”（每 3 次放行一次）

写函数 `bool allow()`：每调用一次计数 +1；到 3 返回 `true` 并清零，否则返回 `false`。

调用 7 次，返回序列应是：`false false true false false true false`

---

### 练习 4（进阶）：把静态状态改成外部传入

把练习 3 改写成：

```cpp
bool allow_with_state(int& state);
```

这样函数不依赖静态变量，更容易测试，也更利于并发场景下的状态隔离。




## 练习 1 答案：预测输出

第一次调用 `p()`：

* `x` 是静态变量：初值 1，执行 `x += 2` 后为 3
* `y` 是普通局部变量：每次进函数都从 1 开始，`y += 2` 后为 3

  输出：`x=3 y=3`

第二次调用：

* `x` 保留上次的 3，再加 2 变 5
* `y` 仍从 1 开始变 3

  输出：`x=5 y=3`

第三次调用：

* `x` 从 5 变 7
* `y` 仍为 3

  输出：`x=7 y=3`

所以三行依次是：

```
x=3 y=3
x=5 y=3
x=7 y=3
```

---

## 练习 2 参考答案：只在第一次打印欢迎语

```cpp
#include <iostream>

void welcome() {
    static bool printed = false;
    if (!printed) {
        std::cout << "Hello!\n";
        printed = true;
    }
}

int main() {
    welcome(); // 打印
    welcome(); // 不打印
    welcome(); // 不打印
}
```

---

## 练习 3 参考答案：“限流器”（每 3 次放行一次）

```cpp
#include <iostream>

bool allow() {
    static int c = 0;
    ++c;
    if (c == 3) {
        c = 0;
        return true;
    }
    return false;
}

int main() {
    for (int i = 0; i < 7; ++i) {
        std::cout << std::boolalpha << allow() << ' ';
    }
    std::cout << '\n';
}
```

输出应为：

```
false false true false false true false
```

---

## 练习 4 参考答案：把状态改成外部传入

```cpp
#include <iostream>

bool allow_with_state(int& state) {
    ++state;
    if (state == 3) {
        state = 0;
        return true;
    }
    return false;
}

int main() {
    int state = 0;
    for (int i = 0; i < 7; ++i) {
        std::cout << std::boolalpha << allow_with_state(state) << ' ';
    }
    std::cout << '\n';
}
```
