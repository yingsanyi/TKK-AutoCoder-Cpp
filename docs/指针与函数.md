- 指针做函数参数
- 指针返回值
- const 指针作为参数
- 指针的指针作为参数（修改指针本身）
- 函数指针（指向函数的指针）
- 指向函数的数组 / 把函数指针当参数传

---
一、指针作为函数参数：用地址“改外面”
1. 普通参数 vs 指针参数
概念：
- 普通值传参：函数拿到的是一份“拷贝”，在函数里改，不会影响外面的变量。
- 指针参数：传进去的是“地址”，函数可以通过这个地址直接改外面的变量。
例子：值传参改不掉外面的变量
#include <iostream>
using namespace std;

void setToZeroByValue(int x) {
    x = 0;  // 这里只是改了 x 的副本
}

int main() {
    int a = 10;
    setToZeroByValue(a);
    cout << a << endl; // 仍然是 10
}
解析：
- setToZeroByValue(a); 传进去的是 a 的值拷贝，比如 10。
- 函数内部的 x 是独立变量，和 main 里的 a 没有“绑在一起”。
- 所以在函数里改 x，不会影响 a。

---
例子：用指针参数改掉外面的变量
#include <iostream>
using namespace std;

void setToZeroByPointer(int *p) {
    *p = 0;  // 通过指针，直接改p指向的那个变量
}

int main() {
    int a = 10;
    setToZeroByPointer(&a);  // 传入 a 的地址
    cout << a << endl;       // 变成 0
}
解析：
- &a 是 a 的地址，比如“门牌号 1000”。
- 函数里 p 里装的就是这个地址。
- *p = 0; 的意思是“去地址 1000 这块内存，把那里的值改成 0”，也就是改 a。
一句话记：
想在函数里“真正改掉”外面的变量，就要传它的地址（指针），在函数里用 *p 来操作。

---
2. 常见用途：交换两个变量值
用指针写 swap（交换）
#include <iostream>
using namespace std;

void mySwap(int *a, int *b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

int main() {
    int x = 3, y = 5;
    mySwap(&x, &y);
    cout << x << " " << y << endl; // 5 3
}
解析：
- 传进来的是 x 和 y 的地址。
- 函数内部通过 *a / *b 访问、交换的是那两个地址上的值，因此外面的 x、y 被真正交换了。

---
二、指针作为函数返回值：从函数“带出地址”
3. 返回指向外部变量的指针（正确用法）
#include <iostream>
using namespace std;

int globalVar = 42;

int* getGlobalPointer() {
    return &globalVar;  // 返回全局变量的地址（有效）
}

int main() {
    int *p = getGlobalPointer();
    cout << *p << endl; // 42
    *p = 100;
    cout << globalVar << endl; // 100
}
解析：
- 全局变量 globalVar 在整个程序运行期间都存在。
- getGlobalPointer 返回它的地址是安全的。
- 主函数拿到这个指针，就可以读写这个全局变量。

---
4. 返回局部变量的地址（严重错误）
int* badFunction() {
    int x = 10;
    return &x;  // 严重错误：返回局部变量地址
}

int main() {
    int *p = badFunction();
    // 此时 x 已经“消失”，p 成为悬空指针
    // *p = 20; // 未定义行为：千万不要这样
}
解析：
- x 是 badFunction 的局部变量，函数结束后这块栈内存就不再属于 x。
- 返回 &x 等于是把一个“已经无主的房间的门牌号”给了别人，别人再去住就是事故。
- 这种指针叫“悬空指针”，解引用就是未定义行为：可能崩溃，可能打印出奇怪的值。
结论：
函数返回指针时，只能返回：
- 全局/静态变量的地址
- 动态分配（new）的内存地址
- 或者由调用者提供的有效内存地址
 绝不要返回局部变量的地址。

---
三、const 指针作为函数参数：只读/不改指针本身
5. 不允许通过指针修改值：const T*
场景：
 你写一个函数，只是“看”数组里的数据，不想让它修改数据，就可以用 const 限制。
例子：只读访问数组
#include <iostream>
using namespace std;

void printArray(const int *a, int n) {
    for (int i = 0; i < n; ++i) {
        cout << a[i] << " ";
        // a[i] = 10; // 这句会编译错误
    }
    cout << endl;
}

int main() {
    int arr[3] = {1, 2, 3};
    printArray(arr, 3);  // arr 自动退化为 int*
}
解析：
- const int *a：表示“指向常量 int 的指针”，通过 a 不能修改元素。
- 这样写，编译器帮你检查：函数不会把数组里的内容误改掉。

---
6. 不允许修改指针本身：T* const
场景：
 你希望函数内部不能把指针“指向别处”，但可以通过它改指向的内容。
#include <iostream>
using namespace std;

void foo(int *const p) {  // p 本身不能改指向
    *p = 100;             // 可以改内容
    // p = nullptr;      // 错误：p 是 const
}

int main() {
    int x = 10;
    int *px = &x;
    foo(px);
    cout << x << endl;    // 100
}
解析：
- 这个写法在参数里不太常见，更多是内部约束用。
- 一般更常用的是 const int*（保证内容不被改），指针本身能改无所谓。

---
四、指向指针的指针作为参数：修改指针本身
有时候你希望函数不仅能“改变量的值”，还要能“改指针本身指向哪”，比如把指针设成 nullptr，或者让它指向新的地址。
这时就需要“指向指针的指针”：T**。
7. 把指针重置为 nullptr
#include <iostream>
using namespace std;

void resetToNull(int **pp) {
    *pp = nullptr;  // 改的是外面的那个指针变量
}

int main() {
    int x = 10;
    int *p = &x;

    cout << boolalpha << (p == nullptr) << endl; // false
    resetToNull(&p);   // 传入的是 p 的地址（int**）
    cout << (p == nullptr) << endl;              // true
}
解析：
- &p 是 int**，函数中参数 pp 就是“指向 p 这个指针变量的指针”。
- *pp 就是 p 本身，*pp = nullptr; 相当于 p = nullptr;。

---
8. 在函数中“分配内存并返回给调用者”
不用 return 返回指针，也可以通过 T** 参数来“输出”一个新指针。
#include <iostream>
using namespace std;

void allocArray(int **pp, int n) {
    *pp = new int[n];       // 分配数组，把地址写进 *pp，也就是外面的指针变量
}

int main() {
    int *p = nullptr;
    allocArray(&p, 5);      // 现在 p 指向一块长度为 5 的 int 数组

    for (int i = 0; i < 5; ++i) {
        p[i] = (i + 1) * 10;
    }

    for (int i = 0; i < 5; ++i) {
        cout << p[i] << " ";
    }
    cout << endl;

    delete[] p;
    p = nullptr;
}
解析：
- 如果函数写成 int* allocArray(int n) 用返回值也行；
 用 int** 参数类似“多返回值”的写法，在 C 接口里很常见。
- 关键点：*pp 是“外面的那个指针变量”，可以给它赋值新地址。

---
五、函数指针：指针指向“可执行的函数”
现在来说“真正的函数指针”，就是“指向函数的指针”。
9. 函数指针是什么？
通俗理解：
- 普通指针：装“变量的地址” → 可以通过它读写变量
- 函数指针：装“函数的入口地址” → 可以通过它“调用”这个函数
基本语法：
返回类型 (*指针名)(形参类型列表);
例如函数：
int add(int a, int b) {
    return a + b;
}
对应的函数指针类型：
int (*pf)(int, int); // pf 是一个“指向函数”的指针，目标函数参数是 (int,int)，返回 int

---
10. 基本使用：定义、赋值、调用
#include <iostream>
using namespace std;

int add(int a, int b) {
    return a + b;
}

int main() {
    // 1. 声明一个函数指针 pf，指向“接收两个 int，返回 int 的函数”
    int (*pf)(int, int);

    // 2. 让 pf 指向 add
    pf = add;      // 或 pf = &add;

    // 3. 通过函数指针调用函数
    int result1 = pf(2, 3);     // 相当于 add(2, 3)
    int result2 = (*pf)(4, 5);  // 也可以显式解引用再调用

    cout << result1 << " " << result2 << endl; // 5 9
    return 0;
}
解析：
- 函数名 add 在大多数表达式里会“退化”为“指向该函数的指针”。
- pf = add; 和 pf = &add; 等价。
- 调用时 pf(2,3) 等价于 (*pf)(2,3)。

---
11. 函数指针作为参数（回调函数）
场景：
 写一个“通用”函数，让调用者把“具体该怎么处理元素”的逻辑传进来，这个逻辑本身就是个函数。
例子：把数组中的每个元素“处理一下”
#include <iostream>
using namespace std;

// 处理单个元素的函数：加 1
int addOne(int x) {
    return x + 1;
}

// 处理单个元素的函数：变成它的平方
int square(int x) {
    return x * x;
}

// 通用函数：对数组中每个元素套一遍“处理函数”
void transformArray(int *a, int n, int (*op)(int)) {
    for (int i = 0; i < n; ++i) {
        a[i] = op(a[i]);   // 相当于调用传进来的函数
    }
}

int main() {
    int arr[5] = {1, 2, 3, 4, 5};

    transformArray(arr, 5, addOne);
    // arr 变成 {2, 3, 4, 5, 6}

    transformArray(arr, 5, square);
    // arr 变成 {4, 9, 16, 25, 36}

    for (int x : arr) cout << x << " ";
}
解析：
- 形参 int (*op)(int) 表示“一个指向 int f(int) 这种函数的指针”。
- 调用 transformArray(arr, 5, addOne); 时，addOne 自动当作指针传进去。
- 在函数内部，op(a[i]) 调用的其实就是 addOne 或 square，由调用者决定。
这就叫“回调函数”（callback）：函数把“要做的事”交给别人写，自己只负责“何时、对谁做”。

---
12. 函数指针数组：一组“可选择的函数”
场景：
 写一个小菜单，不同选项对应不同函数，可以用函数指针数组来“存菜单”。
#include <iostream>
using namespace std;

int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }
int mul(int a, int b) { return a * b; }

int main() {
    // 函数指针数组：存了三个“运算函数”
    int (*ops[3])(int, int) = { add, sub, mul };

    int x = 10, y = 3;
    for (int i = 0; i < 3; ++i) {
        cout << ops[i](x, y) << endl;  // 相当于调用 add/sub/mul
    }
}
解析：
- ops 是“数组”，里面每个元素是“函数指针”： 
  - ops[0] 指向 add
  - ops[1] 指向 sub
  - ops[2] 指向 mul
- ops[i](x, y) 就是“调用第 i 个操作函数”。
这在写命令分派、状态机、简单解释器时很有用。

---
六、小结 & 建议
你现在应该能区分下面几类“与函数相关的指针玩法”：
1. 指针参数
  - 让函数可以“真正修改”外面的变量 / 数组
  - 典型写法：void foo(int *p); → foo(&x);
2. 指针返回值
  - 从函数中“带出”一个指向某块内存的地址
  - 注意：不能返回局部变量地址；可以返回全局 / 静态 / 动态内存地址
3. const + 指针参数
  - const T *p：不允许通过 p 改指向对象（只读）
  - T *const p：不允许改指针本身指向（位置固定）
4. 指向指针的指针参数 T**
  - 用于在函数里“改指针本身”——比如给它赋一个新分配的地址、或置为空
5. 函数指针
  - 让指针“指向函数”，可以通过它调用函数
  - 可作为参数（回调函数）、数组元素（函数指针数组）

---
