课后习题
下面是 20 道“指针与函数”相关的选择题

---
1. 指针作为参数
题目：
void foo(int *p) {
    *p = 100;
}

int main() {
    int x = 10;
    foo(&x);
    return 0;
}
程序执行结束时，x 的值是：
A. 10
 B. 0
 C. 100
 D. 未定义
 E. 编译错误
答案： C
解析：
- foo(&x); 把 x 的地址传给形参 p。
- p 指向 x，*p = 100; 就是把 x 改成 100。

---
2. 值传参与指针传参
题目：
void setZero1(int x) {
    x = 0;
}

void setZero2(int *x) {
    *x = 0;
}

int main() {
    int a = 5;
    setZero1(a);
    int b = 5;
    setZero2(&b);
    // 此时 a 和 b 的值分别是？
}
正确的是：
A. a = 0, b = 0
 B. a = 5, b = 0
 C. a = 0, b = 5
 D. a = 5, b = 5
 E. 编译错误
答案： B
解析：
- setZero1(a)：值传递，函数里改的是形参 x 的副本，a 不变，仍为 5。
- setZero2(&b)：传的是 b 的地址，*x = 0; 直接修改 b。

---
3. 返回指针的函数
题目：
int a = 10;

int* getPtr() {
    return &a;
}

int main() {
    int *p = getPtr();
    *p = 20;
    return 0;
}
执行结束时，全局变量 a 的值是：
A. 10
 B. 20
 C. 未定义
 D. 程序崩溃
 E. 编译错误
答案： B
解析：
- a 是全局变量，生命周期覆盖整个程序运行。
- getPtr 返回 &a 合法且安全。
- p 指向 a，*p = 20; 把 a 改为 20。

---
4. 返回局部变量地址
题目：
int* func() {
    int x = 10;
    return &x;
}

int main() {
    int *p = func();
    // ...
}
关于这段代码，下列说法正确的是：
A. 完全安全，不存在问题
 B. 可能返回错误的值，但不会崩溃
 C. 返回了悬空指针，后续使用是未定义行为
 D. 只有在多线程时才会有问题
 E. 无法通过编译
答案： C
解析：
- x 是局部变量，func 返回后栈帧销毁，x 的存储空间不再有效。
- 返回 &x 得到的是悬空指针，后续一旦解引用就是未定义行为。

---
5. 指针的指针作为参数
题目：
void reset(int **pp) {
    *pp = nullptr;
}

int main() {
    int x = 5;
    int *p = &x;
    reset(&p);
    // ...
}
调用 reset 之后，下列说法正确的是：
A. x 变为 0，p 不变
 B. x 不变，p 为 nullptr
 C. x 和 p 都为 0
 D. x 和 p 都为 nullptr
 E. 编译错误
答案： B
解析：
- &p 的类型是 int**，与形参 int **pp 匹配。
- 函数里 *pp 就是 p 本身，*pp = nullptr; 等价于 p = nullptr;。
- 没有改 x，所以 x 仍为 5。

---
6. const 指针参数（指向常量）
题目：
void print(const int *p) {
    //*p = 10; // 位置①
}
关于位置①那一行，下列说法正确的是：
A. 可以编译通过，且行为定义良好
 B. 可以编译通过，但行为未定义
 C. 无法通过编译，因为 *p 是只读的
 D. 只有在 p 指向常量时才会编译错误
 E. 运行时抛出异常
答案： C
解析：
- const int *p：通过 p 不能修改它指向的 int。
- *p = 10; 违反 const 限制，编译阶段就报错。

---
7. const 指针参数（常量指针）
题目：
void foo(int *const p) {
    *p = 10;      // 位置①
    //p = nullptr; // 位置②
}
关于位置①和位置②，下列说法正确的是：
A. ① 通过，② 通过
 B. ① 通过，② 编译错误
 C. ① 编译错误，② 通过
 D. ①、② 都编译错误
 E. 仅在开启优化时 ② 才错误
答案： B
解析：
- int *const p：p 本身是常量（不能改指向），但指向的内容可变。
- 位置①：*p = 10; 修改的是所指向的 int，合法。
- 位置②：p = nullptr; 修改指针本身，非法，编译错误。

---
6. 函数指针的声明
题目：
有一个函数：
int add(int a, int b) { return a + b; }
下列哪一行正确定义了一个可以指向 add 的函数指针 pf？
A. int pf(int, int) = add;
 B. int *pf(int, int) = add;
 C. int (*pf)(int, int) = add;
 D. int &pf(int, int) = add;
 E. int pf = add(int, int);
答案： C
解析：
- int (*pf)(int, int)：pf 是“指向参数为 (int,int)、返回 int 的函数”的指针类型。
- 其他选项要么是函数声明，要么类型根本不对。

---
7. 函数指针的调用
题目：
int mul(int a, int b) { return a * b; }

int main() {
    int (*pf)(int, int) = mul;
    int x = pf(2, 3);
    int y = (*pf)(4, 5);
}
执行后，x 和 y 的值分别是：
A. x = 2, y = 4
 B. x = 5, y = 9
 C. x = 6, y = 20
 D. x = 9, y = 20
 E. 编译错误
答案： C
解析：
- pf 指向 mul。
- pf(2,3) 等价于 mul(2,3)，结果为 6。
- (*pf)(4,5) 也是调用 mul(4,5)，结果为 20。

---
8. 函数指针作为参数（回调）
题目：
int inc(int x) { return x + 1; }

void apply(int *a, int n, int (*op)(int)) {
    for (int i = 0; i < n; ++i) {
        a[i] = op(a[i]);
    }
}
关于 apply 函数，下列说法正确的是：
A. op 是一个 int*
 B. op 是一个“指向函数”的指针
 C. op 是一个“返回指针的函数”
 D. op 不能被调用
 E. op 的类型是 void (*)(int)
答案： B
解析：
- int (*op)(int) 说明 op 是一个函数指针，指向“接受一个 int，返回 int 的函数”。

---
9. 函数指针数组
题目：
int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }

int main() {
    int (*ops[2])(int, int) = { add, sub };
    int x = ops[0](10, 3);
    int y = ops[1](10, 3);
}
执行后，x 和 y 的值分别为：
A. x = 13, y = 7
 B. x = 7, y = 13
 C. x = 10, y = 3
 D. x = 3, y = 10
 E. 编译错误
答案： A
解析：
- ops[0] 指向 add：add(10,3) = 13，所以 x = 13。
- ops[1] 指向 sub：sub(10,3) = 7，所以 y = 7。

---
10. 函数名与函数指针
题目：
int func(double x) { return (int)x; }

int main() {
    int (*pf)(double) = nullptr;
    pf = func;
}
关于 pf = func; 这一句，下列说法正确的是：
A. 非法，函数名不能赋给函数指针
 B. 非法，类型不匹配
 C. 合法，函数名会自动转为函数指针
 D. 合法，但需要强制类型转换
 E. 只能写成 pf = &func;
答案： C
解析：
- 函数名在大多数表达式中会退化为“指向该函数的指针”。
- func 的类型与 pf 一致（int(double)），可直接赋值。
- pf = func; 与 pf = &func; 等价。

---
11. 函数指针与 nullptr
题目：
int foo(int x) { return x; }

int main() {
    int (*pf)(int) = nullptr;
    pf = foo;
    // ...
}
下列关于 pf 的说法正确的是：
A. pf 只能被赋值一次
 B. pf 初始化为 nullptr 是非法的
 C. pf 只能指向返回 void 的函数
 D. pf 可以先为 nullptr，再指向 foo
 E. pf 必须在定义时立即指向函数
答案： D
解析：
- 函数指针可以初始化为 nullptr，表示当前不指向任何函数。
- 之后再赋值为 foo 合法且常见。

---
12. 函数指针类型匹配
题目：
int f1(int x) { return x + 1; }
double f2(double x) { return x + 0.5; }

int main() {
    int (*pf)(int);
    // 下面哪一句是合法的？
}
下列哪一句是合法的赋值语句？
A. pf = f1;
 B. pf = f2;
 C. pf = &f2;
 D. pf = (int (*)(int))f2;
 E. 以上都不合法
答案： A
解析：
- pf 类型是 int (*)(int)。
- f1 类型是 int(int)，与之匹配，可赋值。
- f2 类型为 double(double)，与 pf 不匹配。

---
13. 用函数指针做“选择操作”
题目：
int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }

int calc(int a, int b, int (*op)(int, int)) {
    return op(a, b);
}
下列哪一种调用方式是合法的？
A. calc(3, 2, add(3,2));
 B. calc(3, 2, &add);
 C. calc(3, 2, *add);
 D. B 和 C
 E. A、B、C 都合法
答案： D
解析：
- A：add(3,2) 的结果是 int，不是函数指针，类型不符 → 非法。
- B：&add 是函数指针，类型为 int (*)(int,int)，合法。
- C：*add 在此表达式环境中也退化为指向 add 的指针，语法上等价于 add/&add。
- 合法的是 B 和 C。

---
14. 函数返回函数指针（原型）
题目：
有函数：
int func(int);
下列哪一个是“返回指向该函数的函数指针”的函数声明？（只考虑语法）
A. int (*g(int))(int);
 B. int *g(int)(int);
 C. int g(int)(int*);
 D. int g(*int)(int);
 E. int (*g(int*))(int);
答案： A
解析：
- 从里往外读： 
  - g(int) 表示 g 是一个函数，参数是 int；
  - (*g(int)) 表示返回的是一个指针；
  - int (*g(int))(int) 表示这个指针指向“接受 int 返回 int 的函数”。
- 即：g 返回一个与 func 类型相同的函数指针。

---
15. 用函数指针实现“通用比较函数”原型
题目：
假设你要写一个函数 sortIntArray，排序一个整型数组，并允许调用者指定“比较规则”（升序或降序）。下面哪一种比较函数原型比较合理？
A. bool cmp(int, int);
 B. int cmp(int, int);
 C. void cmp(int*, int*);
 D. int* cmp(int*, int*);
 E. void cmp(void);
答案： A
解析：
- 常见做法：bool cmp(int a, int b);
  - 返回 true 表示“a 应该排在 b 前面”。
- 这是标准库排序函数常用的比较函数形式。

---
16. 指针作为输出参数（返回多个值）
题目：
void split(int x, int *high, int *low) {
    *high = x / 10;
    *low  = x % 10;
}

int main() {
    int h, l;
    split(57, &h, &l);
}
执行 split(57, &h, &l); 之后，h 和 l 的值分别为：
A. h = 5, l = 7
 B. h = 57, l = 0
 C. h = 7, l = 5
 D. h = 0, l = 57
 E. 编译错误
答案： A
解析：
- x = 57
- *high = 57 / 10 = 5
- *low  = 57 % 10 = 7
- 所以 h = 5, l = 7。

---
17. 函数指针与 typedef 简化写法
题目：
int add(int a, int b) { return a + b; }

typedef int (*Op)(int, int);

int main() {
    Op pf = add;
    int x = pf(1, 2);
}
关于上述代码，下列说法正确的是：
A. Op 是一个函数，而不是类型
 B. Op 是一个“指向函数的指针类型”
 C. pf 不是指针，不能调用
 D. pf(1, 2) 非法，必须用 (*pf)(1, 2)
 E. 无法通过编译
答案： B
解析：
- typedef int (*Op)(int, int); 定义了类型别名 Op，表示“指向 int(int,int) 函数的指针”。
- Op pf = add; → pf 是函数指针，可以像函数一样 pf(1,2) 调用。

---
18. 函数指针默认参数
题目：
int add(int a, int b) { return a + b; }
int mul(int a, int b) { return a * b; }

int calc(int a, int b, int (*op)(int, int) = add) {
    return op(a, b);
}
关于 calc 的调用，下列说法正确的是：
A. calc(2, 3); 非法，必须传第三个参数
 B. calc(2, 3); 等价于 calc(2, 3, add);
 C. calc(2, 3); 等价于 calc(2, 3, mul);
 D. 不能给函数指针参数设置默认值
 E. 只有在 C 语言中才允许这样写
答案： B
解析：
- 第三个参数是函数指针，默认值为 add。
- 当调用 calc(2, 3); 时，没有显式给第三个参数，就使用默认值：
 等价于 calc(2, 3, add);。

---

编程题

---
题 1：用指针参数实现两个整数交换
题目：
编写函数 swapInt，使用指针参数交换两个 int 变量的值。
函数原型：
void swapInt(int *a, int *b);
示例：
- 输入：a = 3, b = 5
- 调用：swapInt(&a, &b);
- 输出：a = 5, b = 3
参考代码：
#include <iostream>
using namespace std;

void swapInt(int *a, int *b) {
    if (a == nullptr || b == nullptr) return; // 简单防御
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

int main() {
    int x = 3, y = 5;
    swapInt(&x, &y);
    cout << x << " " << y << endl; // 5 3
    return 0;
}
要点：
- 用指针参数修改外部变量：*a、*b。
- 注意不要把普通变量名(x,y)直接传进去，要传地址(&x,&y)。

---
题 2：用指针参数求数组最大值
题目：
编写函数 maxInArray，接收一个整型数组及其长度，用指针遍历数组，返回最大值。如果数组长度为 0，可以自行约定行为（例如返回 0 或不调用该函数）。
函数原型：
int maxInArray(const int *a, int n);
示例：
- 输入：a = {3, 8, 2, 9, 4}, n = 5
- 返回：9
参考代码：
#include <iostream>
using namespace std;

int maxInArray(const int *a, int n) {
    if (n <= 0) return 0;  // 简单约定

    const int *p = a;
    const int *end = a + n;

    int maxVal = *p;   // 先假设第一个是最大
    ++p;

    while (p != end) {
        if (*p > maxVal) {
            maxVal = *p;
        }
        ++p;
    }
    return maxVal;
}

int main() {
    int arr[5] = {3, 8, 2, 9, 4};
    cout << maxInArray(arr, 5) << endl; // 9
    return 0;
}
要点：
- 使用指针 p 和 end 遍历 [a, a+n)。
- 参数用 const int*，表示函数不修改数组内容。

---
题 3：用指针参数统计数组中某个值出现次数
题目：
编写函数 countValue，统计一个整型数组中某个值出现的次数。要求使用指针遍历数组。
函数原型：
int countValue(const int *a, int n, int value);
示例：
- 输入：a = {1, 2, 3, 2, 2}, n = 5, value = 2
- 返回：3
参考代码：
#include <iostream>
using namespace std;

int countValue(const int *a, int n, int value) {
    int count = 0;
    const int *p = a;
    const int *end = a + n;

    while (p != end) {
        if (*p == value) {
            ++count;
        }
        ++p;
    }
    return count;
}

int main() {
    int arr[5] = {1, 2, 3, 2, 2};
    cout << countValue(arr, 5, 2) << endl; // 3
    return 0;
}
要点：
- 标准的“线性扫描 + 计数”。
- 对比题 2：熟悉用指针遍历数组的模式。

---
题 4：用函数指针选择运算（加法或乘法）
题目：
编写一个函数 calc，可以对两个整数执行“加法”或“乘法”。
- 写两个普通函数 add 和 mul： 
  - add(a,b) 返回 a+b
  - mul(a,b) 返回 a*b
- calc 接收两个整数和一个函数指针参数 op，通过 op 来调用具体运算。
函数原型：
int add(int a, int b);
int mul(int a, int b);
int calc(int a, int b, int (*op)(int, int));
示例：
- calc(2, 3, add) 返回 5
- calc(2, 3, mul) 返回 6
参考代码：
#include <iostream>
using namespace std;

int add(int a, int b) { return a + b; }
int mul(int a, int b) { return a * b; }

int calc(int a, int b, int (*op)(int, int)) {
    return op(a, b);  // 通过函数指针调用
}

int main() {
    cout << calc(2, 3, add) << endl; // 5
    cout << calc(2, 3, mul) << endl; // 6
    return 0;
}
要点：
- 体会“把函数当成参数传进去”的写法：int (*op)(int,int)。
- op(a,b) 就是调用传进来的那个函数。

---
题 5：用函数指针数组实现简单“菜单”
题目：
实现一个简单的“计算器菜单”，支持三种运算：加法、减法、乘法。
- 写三个函数：add, sub, mul。
- 用函数指针数组保存这三个运算。
- 输入一个选项（0 表示加、1 表示减、2 表示乘）和两个整数，调用对应运算函数并输出结果。
函数原型示例：
int add(int a, int b);
int sub(int a, int b);
int mul(int a, int b);
参考代码：
#include <iostream>
using namespace std;

int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }
int mul(int a, int b) { return a * b; }

int main() {
    int (*ops[3])(int, int) = { add, sub, mul };

    int choice;
    int x, y;
    cin >> choice >> x >> y; // 例如: 0 3 5

    if (choice < 0 || choice > 2) {
        cout << "invalid choice" << endl;
        return 0;
    }

    int result = ops[choice](x, y);
    cout << result << endl;
    return 0;
}
要点：
- ops 是“函数指针数组”：ops[0] 指向 add，ops[1] 指向 sub，ops[2] 指向 mul。
- ops[choice](x,y) 就是调用对应函数。

---
题 6：使用指针参数把一个整数拆成高位和低位
题目：
编写函数 splitNumber，把两位数 x 拆成“十位”和“个位”，通过指针参数返回。
 例如：x = 57，应得到 high = 5, low = 7。
函数原型：
void splitNumber(int x, int *high, int *low);
示例：
- 调用：splitNumber(57, &h, &l);
- 结果：h == 5, l == 7
参考代码：
#include <iostream>
using namespace std;

void splitNumber(int x, int *high, int *low) {
    if (high) *high = x / 10;
    if (low)  *low  = x % 10;
}

int main() {
    int h, l;
    splitNumber(57, &h, &l);
    cout << h << " " << l << endl; // 5 7
    return 0;
}
要点：
- 演示“一个函数通过指针参数返回多个结果”的常见写法。
- 简单的判空（if (high)）是个好习惯，防止传入空指针时崩溃。