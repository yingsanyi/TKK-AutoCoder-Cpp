

---
第二部分：指针与数组（Lesson 26）
1）指针与一维数组
讲法（课堂好讲版）
数组名 a 在大多数表达式里，会“自动变成”指向首元素 &a[0] 的地址，因此你经常会听到一句话：数组名像指针。但要提醒学生：数组名本体不是普通指针变量，它不能被赋值、不能自增。[ref:2,6]
a[i] 这件事，本质就是“从首地址往后走 i 个元素，再取值”：
- a[i] 等价于 *(a + i)
- 如果 p = a，那 a[i] 也等价于 *(p + i)、p[i][ref:5,6]
代码 A：用指针遍历（你的例1升级：不破坏原指针）
#include <iostream>
using namespace std;

int main() {
    int a[5] = {1, 2, 3, 4, 5};

    for (int* p = a; p < a + 5; ++p) { // a 等价于 &a[0]
        cout << *p << ' ';
    }
    cout << "\n";
}
代码 B：指针方式赋值 + 输出（对应例3）
#include <iostream>
using namespace std;

int main() {
    int a[10];
    int* pa = a;

    for (int i = 0; i < 10; i++) {
        *(pa + i) = 2 * i + 2;
        cout << *(pa + i) << " ";
    }
    cout << "\n";
}
代码 C：求和（把 <= &a[4] 改成更稳的“尾后指针”写法）
#include <iostream>
using namespace std;

int main() {
    int a[5] = {4, 5, 6, 7, 8};
    int sum = 0;

    for (int* p = a; p != a + 5; ++p) { // a+5 是尾后指针
        sum += *p;
    }
    cout << sum << "\n";
}
练习题（含答案要点）
选择题
1. int a[5]; 中表达式 a 在大多数场景下等价于：
 A. a[0]  B. &a[0]  C. &a  D. *a
答案：B。[ref:6]
2. 已知 int* p = a;，则 p[3] 等价于：
 A. *(p + 3)  B. *p + 3  C. &(p + 3)  D. *(a) + 3
答案：A。[ref:5]
判断题 3. 数组名 a 可以写 a++。(T/F)
答案：F（数组名不是可修改的指针变量）。[ref:6]
4. sizeof(a) 在 int a[10] 的同一作用域里，得到的是整个数组大小。(T/F)
答案：T（注意传参后会退化）。[ref:6]
填空题 5. a[i] 的指针形式是 *(___ + ___)。
答案：*(a + i)。[ref:5]
编程题 6. 写函数 int sumArr(const int* a, int n)，用指针遍历求和（禁止下标）。
要点：用 for (const int* p=a; p!=a+n; ++p)。[ref:5]
高发坑
- 数组退化：void f(int a[]) 里 sizeof(a) 得到的是指针大小，不是数组大小。[ref:6]
- 边界写法：用 p != a+n 比用 p <= &a[n-1] 更不容易写错。[ref:5]

---
2）指针类型与字符数组（char* 的“输出特性”）
讲法
int* 往前走一步是跨一个 int 的宽度；char* 往前走一步就是 1 字节。
 更关键的是：cout << char* 会把它当成 C 字符串来输出，从当前位置一路打印到 '\0' 为止，而不是打印地址。[ref:5,6]
代码：从中间开始打印字符串 + 单字符访问
#include <iostream>
using namespace std;

int main() {
    char a[10] = "ABCDE";
    char* p = &a[2]; // 指向 'C'
    p++;             // 指向 'D'

    cout << p << "\n";       // 输出 "DE"
    cout << *(p + 1) << "\n"; // 输出 'E'
}
练习题（含答案要点）
选择题
1. 执行 cout << p; 时，若 p 是 char*，默认行为更像：
 A. 输出地址  B. 输出一个字符  C. 输出从 p 开始的字符串直到 '\0'  D. 编译错误
答案：C。[ref:5]
判断题 2. 若想输出 char* 的地址，写 cout << (void*)p; 可以避免把它当字符串。(T/F)
答案：T。[ref:6]
编程题 3. 写程序：输入一行字符串到 char a[100]，用 char* 统计长度（遇到 '\0' 停）。
要点：for (char* p=a; *p!='\0'; ++p) ++len;。[ref:5]
高发坑
- 忘了 '\0'：手写字符数组如果没有正确终止符，cout << p 可能一直打印到内存里碰巧遇到 0 为止。[ref:5,6]

---
3）指针与二维数组
讲法
二维数组 int a[R][C] 在内存里通常是按行连续摆放的。
- a[i] 可以理解成“第 i 行的行首地址”，类型是“长度为 C 的 int 数组”再退化出来的指针。[ref:6]
 访问元素 a[i][j] 常见等价写法：
- ((a + i) + j)（课堂上用这个最清楚）[ref:5,6]
方法一：当成一维“拉平”遍历（你的 flat 指针）
#include <iostream>
using namespace std;

int main() {
    int a[2][3] = {{1,2,3},{4,5,6}};
    int* p = &a[0][0];

    for (int i = 0; i < 6; ++i) {
        cout << *p++ << " ";
    }
    cout << "\n";
}
方法二：数组指针（保留列宽信息，最“类型正确”）
#include <iostream>
using namespace std;

int main() {
    int a[2][3] = {};
    int (*p)[3] = a; // 指向“含 3 个 int 的数组”的指针

    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 3; j++) {
            p[i][j] = 2 * i + j;
            cout << p[i][j] << " ";
        }
    }
    cout << "\n";
}
练习题（含答案要点）
选择题
1. int a[2][3]; 中 a 更接近哪种类型？
 A. int*  B. int (*)[3]  C. int**  D. int[2]
答案：B。[ref:6]
2. a[i][j] 的等价指针写法是：
 A. *(a + i + j)  B. ((a + i) + j)  C. **(a + i) + j  D. *(a[i] + j)（注意：D 也对）
答案：B 和 D 都对（D 是 B 的简写）。[ref:5,6]
编程题 3. 写函数 void fill(int (*p)[3], int r)：把 r x 3 的数组填成从 1 开始递增。
要点：形参列数必须写死（这里是 3）。[ref:6]
高发坑
- 把二维数组当 int** 传参：int a[2][3] 不是 int**，类型不匹配。[ref:6]

---
4）动态数组（高级应用）
讲法
动态一维数组最简单：new[] 申请，delete[] 释放。
 动态二维常见有两种：
 1）“指针数组 + 每行 new”：int**（写起来直观，但内存不一定连续）
 2）“一块连续内存 + 手动映射”：更高效更安全（后面可以当提高讲）[ref:2,6]
一维动态：斐波那契（你的例7补上边界）
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    if (n <= 0) return 0;

    int* p = new int[n];

    if (n >= 1) p[0] = 1;
    if (n >= 2) p[1] = 1;
    for (int i = 2; i < n; i++) p[i] = p[i-1] + p[i-2];

    for (int i = 0; i < n; i++) cout << p[i] << " ";
    cout << "\n";

    delete[] p;
    p = nullptr;
}
二维动态（方式 A：int**）
#include <iostream>
using namespace std;

int main() {
    int r = 2, c = 3;

    int** a = new int*[r];
    for (int i = 0; i < r; ++i) a[i] = new int[c];

    int val = 1;
    for (int i = 0; i < r; ++i)
        for (int j = 0; j < c; ++j)
            a[i][j] = val++;

    for (int i = 0; i < r; ++i) {
        for (int j = 0; j < c; ++j) cout << a[i][j] << " ";
        cout << "\n";
    }

    for (int i = 0; i < r; ++i) delete[] a[i];
    delete[] a;
}
练习题（含答案要点）
判断题
1. int* p = new int[m]; 释放必须用 delete[] p;。(T/F)
答案：T。[ref:2]
编程题 2. 写动态数组版本的“输入 n 个数，输出最大值”。
要点：申请 new int[n]，遍历取 max，最后 delete[]。[ref:2]
3. 二维 r x c：写一个函数创建并返回 int**，并写对应的释放函数。
要点：创建与释放必须成对；释放顺序：先每行，再行指针数组。[ref:2]
高发坑
- new[] 对应 delete[]，配错会出大事。[ref:2]
- n=1 还写 p[1]=...：斐波那契这种题边界最爱坑学生。[ref:2]

---
5）易错定义辨析：数组指针 vs 指针数组
讲法（给学生一个“读法”）
看括号：括号里先结合。
- int (*p)[50]：p 是指针，指向“50 个 int 的数组”（数组指针）。
- int* q[50]：q 是数组，里面装着 50 个 int*（指针数组）。[ref:6]
练习题（含答案要点）
选择题
1. int* q[50]; 更像：
 A. 50 个 int  B. 50 个指针  C. 指向 50 个 int 的指针  D. 指向指针的数组
答案：B。[ref:6]
2. int (*p)[50]; 解读正确的是：
 A. p 是数组  B. p 是指针，指向一个 50 长度的 int 数组  C. p 是指向 int 的指针数组  D. p 是二级指针
答案：B。[ref:6]
编程题 3. 声明一个 3x4 的二维数组 a，用数组指针遍历输出（要求显式写出 int (*p)[4]）。
要点：列宽 4 写在类型里。[ref:6]

---
第三部分：函数指针与 main（Lesson 26/27 衔接）
1）函数指针
讲法
函数也有“入口地址”。函数指针就是“保存函数入口地址的变量”，常用于：把“做什么”当参数传进去（回调/策略）。[ref:2,6]
代码：斜边（你的例8，补头文件）
#include <iostream>
#include <cmath>
using namespace std;

double hyp(double a, double b) {
    return sqrt(a * a + b * b);
}

int main() {
    double (*p)(double, double) = hyp;
    cout << (*p)(3.0, 4.0) << "\n";
}
代码：策略传递（你的例9做成可跑版）
#include <iostream>
using namespace std;

struct Card { int hp; int atk; };

void attack(Card& c1, Card& c2) { c2.hp -= c1.atk; }
void heal(Card& c1, Card& c2)   { c2.hp += 1; (void)c1; }

void action(void (*fun)(Card&, Card&), Card& c1, Card& c2) {
    fun(c1, c2);
}

int main() {
    Card a{10, 3}, b{8, 2};
    action(attack, a, b);
    cout << "b.hp=" << b.hp << "\n";
    action(heal, a, b);
    cout << "b.hp=" << b.hp << "\n";
}
练习题（含答案要点）
选择题
1. double (*p)(double,double); 中 p 是：
 A. 函数  B. 函数指针  C. 返回 double 的指针  D. 二级指针
答案：B。[ref:6]
编程题 2. 写三个函数 add/sub/mul，用函数指针根据用户输入选择运算。
要点：函数签名一致；指针变量指向不同函数再调用。[ref:6]
高发坑
- 忘记括号：double *p(double,double) 变成“函数声明”，不是函数指针。[ref:6]

---
2）带参数的 main：argc/argv
讲法
命令行像“启动程序时顺便塞进来的小纸条”：
- argc：纸条数量（包括程序名）
- argv：每张纸条的内容（字符串），argv[0] 永远是程序名。[ref:2,5]
代码：打印参数
#include <iostream>
using namespace std;

int main(int argc, char* argv[]) {
    cout << "程序名：" << argv[0] << "\n";
    for (int i = 1; i < argc; i++) {
        cout << "参数" << i << "：" << argv[i] << "\n";
    }
}
练习题（含答案要点）
判断题
1. argc 至少为 1。(T/F)
答案：T（至少有程序名）。[ref:2,5]
编程题 2. 写程序：如果参数是 sum 3 4 5，输出 12（提示：把 argv[i] 转整数）。
要点：用 std::stoi；循环从 i=2 开始累加。[ref:2]
高发坑
- argv 是“字符串数组”（更准确说是字符指针数组），别直接当数字用；要转型/解析。[ref:2,5]

---

下面是 教师版（逐题答案 + 解析 + 课堂提问引导语 + 易错选项为什么错），覆盖你 Lesson 26 的“指针与数组”+“函数指针/argc argv”。我按“题目 → 正确答案 → 解析 → 易错项 → 课堂引导”给你一套可以直接拿去讲的脚本式内容[ref:4,6]。

---
A. 指针与一维数组
题 1（选择）
题目：int a[5]; 中表达式 a 在大多数场景下等价于：
 A. a[0]  B. &a[0]  C. &a  D. *a
答案：B[ref:4,6]
解析（你讲的时候这样说）：
 数组名 a 在大多数表达式里会发生“退化”，变成指向首元素的指针，也就是 &a[0][ref:4,6]。
易错选项为什么错：
- A a[0] 是首元素的“值”，不是地址。
- C &a 是“整个数组”的地址，类型是 int (*)[5]，不是 int*。
- D *a 等价于 a[0]，仍是值，不是地址。[ref:4,6]
课堂引导一句话：
 “我问你：a 像不像‘首元素地址’？那 &a 又像不像‘整个数组的地址’？这俩差在哪儿？”[ref:6]

---
题 2（选择）
题目：已知 int* p = a;，则 p[3] 等价于：
 A. *(p + 3)  B. *p + 3  C. &(p + 3)  D. *(a) + 3
答案：A[ref:4]
解析：
 下标运算本质是指针运算：p[i] == *(p + i)[ref:4]。
易错选项为什么错：
- B 是“首元素值 + 3”，不是第 4 个元素。
- C 是地址（而且还多取了一层地址），类型不对。
- D 还是“首元素值 + 3”。[ref:4]
课堂引导：
 “把 p[3] 翻译成一句话：从 p 出发走 3 格，拿到那格里的值——这句话对应哪一项？”[ref:4]

---
题 3（判断）
题目：数组名 a 可以写 a++。(T/F)
答案：F[ref:4,6]
解析：
 数组名不是普通指针变量，它不能被赋值/自增；只有真正的指针变量（如 int* p）才能 p++[ref:4,6]。
常见学生反问（你可以顺势讲）：
 “那为什么 a+1 又可以？”——因为 a+1 只是表达式结果，不是修改 a 本体。[ref:6]
课堂引导：
 “a 不是变量吗？为什么不能 ++？谁能用‘数组名不是指针变量’解释一下？”[ref:6]

---
题 4（判断）
题目：sizeof(a) 在 int a[10] 的同一作用域里，得到的是整个数组大小。(T/F)
答案：T[ref:6]
解析：
 在数组本体还没退化成指针的地方，sizeof(a) 是数组总字节数（10 个 int 的总大小）[ref:6]。
易错点（重点提示）：
 一旦数组作为函数参数传进去，会退化成指针，sizeof 就变成“指针大小”了[ref:6]。
课堂引导：
 “同学们：同一个 a，为什么在 main 里 sizeof(a) 是一坨，在函数参数里 sizeof(a) 变小了？到底发生了什么？”[ref:6]

---
题 5（填空）
题目：a[i] 的指针形式是 *(___ + ___)。
答案：*(a + i)[ref:4]
解析（讲法）：
 “先定位，再取值”：a+i 定位到第 i 个元素地址，* 取出值。[ref:4]
课堂引导：
 “如果我把 i 换成 2，你能用手比划出指针走了几步吗？每步跨几个字节？”[ref:4]

---
题 6（编程）
题目：写 int sumArr(const int* a, int n)，用指针遍历求和（禁止下标）。
参考答案
int sumArr(const int* a, int n) {
    int sum = 0;
    for (const int* p = a; p != a + n; ++p) sum += *p;
    return sum;
}
评分点：
- 用 p != a+n 这种“尾后指针”边界；
- const int* 不改数组；
- 先判 n 是否可能为 0（可加分）。[ref:4]
常见错误与当场纠正话术：
- 写成 p <= a+n：越界访问尾后元素（尾后只能比较不能解引用）。
- 忘了 const：不致命，但提醒“接口语义更清晰”。[ref:4]

---
B. 指针类型与字符数组（char* 输出）
题 1（选择）
题目：cout << p; 若 p 是 char*，默认行为更像：
 A. 输出地址  B. 输出一个字符  C. 输出从 p 开始的字符串直到 '\0'  D. 编译错误
答案：C[ref:4]
解析：
 标准库对 char* 有专门的输出重载，会把它当 C 风格字符串输出，直到遇到 '\0'[ref:4]。
易错选项为什么错：
- A 是 int* / void* 更像的行为；char* 特殊。
- B 输出单字符要用 *p。
- D 不会编译错，反而是“太能跑所以容易坑”。[ref:4]
课堂引导：
 “同样是指针，为什么 int* 输出像地址，char* 输出像字符串？这就是‘类型决定解释方式’。”[ref:4]

---
题 2（判断）
题目：想输出 char* 的地址，写 cout << (void*)p; 可以避免把它当字符串。(T/F)
答案：T[ref:4]
解析：
 转成 void* 后走“输出地址”的通道，而不是按字符串打印。[ref:4]
课堂引导：
 “你们写调试日志时，什么时候应该转 (void*)？什么时候应该直接输出字符串？”[ref:4]

---
题 3（编程）
题目：输入一行到 char a[100]，用 char* 统计长度（遇 '\0' 停）。
参考答案
int len(const char* s) {
    int n = 0;
    for (const char* p = s; *p != '\0'; ++p) ++n;
    return n;
}
评分点：
- 终止条件是 '\0'；
- 指针移动 ++p；
- 不要把 cout<<p 当“地址输出”。[ref:4]
常见错误：
 没终止符的数组会导致一直读下去（“跑到内存里碰运气”）。[ref:4]

---
C. 指针与二维数组
题 1（选择）
题目：int a[2][3]; 中 a 更接近哪种类型？
 A. int*  B. int (*)[3]  C. int**  D. int[2]
答案：B[ref:4]
解析：
a 退化后指向“第一行”，而“一行”的类型是 int[3]，所以是指向数组的指针：int (*)[3][ref:4]。
易错选项为什么错：
- A 忽略了“每行有 3 个元素”的列宽信息。
- C int** 适用于“指针数组分配的二维”，不是这种真正的二维数组。
- D int[2] 是两元素的一维数组类型，不对。[ref:4]
课堂引导：
 “二维数组里，a+1 是跳到下一个元素，还是跳到下一行？为什么？”[ref:4]

---
题 2（选择，允许多选）
题目：a[i][j] 的等价指针写法是：
 A. *(a + i + j)
 B. ((a + i) + j)
 C. **(a + i) + j
 D. *(a[i] + j)
答案：B、D[ref:4]
解析：
a+i 到第 i 行，*(a+i) 取到这一行的首地址（退化为 int*），再 +j，再 * 取值[ref:4]。D 是把 a[i] 当行首指针的写法。
易错选项为什么错：
- A 把二维当一维乱加，跳步不对。
- C 少了括号，本质变成“取一个值再 +j”，不是取第 j 个元素。[ref:4]
课堂引导：
 “谁能把 ((a+i)+j) 读成一句中文？读得通，就不会写错。”[ref:4]

---
题 3（编程）
题目：写 void fill(int (*p)[3], int r)，填 r x 3 从 1 递增。
参考答案
void fill(int (*p)[3], int r) {
    int v = 1;
    for (int i = 0; i < r; ++i)
        for (int j = 0; j < 3; ++j)
            p[i][j] = v++;
}
评分点：
- 形参必须写列数 3（否则类型不完整）；
- 用 p[i][j] 或 ((p+i)+j) 均可。[ref:4]
常见错法：
 写成 void fill(int** p, ...)：类型不匹配，概念错。[ref:4]

---
D. 动态数组（new[]/delete[]，二维 int**）
题 1（判断）
题目：int* p = new int[m]; 释放必须用 delete[] p;。(T/F)
答案：T[ref:6]
解析：
new[] 必须对应 delete[]，否则行为不对（尤其有对象构造析构时更明显）[ref:6]。
课堂引导：
 “为什么数组要 delete[]？它到底要多做什么？”（引到“成对匹配、析构次数”）[ref:6]

---
题 2（编程）
题目：动态数组版：输入 n 个数，输出最大值。
参考答案
#include <iostream>
using namespace std;

int main() {
    int n; cin >> n;
    if (n <= 0) return 0;

    int* a = new int[n];
    for (int i = 0; i < n; ++i) cin >> a[i];

    int mx = a[0];
    for (int i = 1; i < n; ++i) if (a[i] > mx) mx = a[i];
    cout << mx << "\n";

    delete[] a;
}
评分点：
- n<=0 边界；
- delete[]；
- 不访问越界。[ref:6]
常见错法：
- delete a;（少了 []）；
- mx 初始化为 0 导致全负数时错误。[ref:6]

---
题 3（编程）
题目：写创建并返回 int** 的函数 + 对应释放函数。
参考答案
int** make2D(int r, int c) {
    int** a = new int*[r];
    for (int i = 0; i < r; ++i) a[i] = new int[c]{};
    return a;
}

void free2D(int** a, int r) {
    for (int i = 0; i < r; ++i) delete[] a[i];
    delete[] a;
}
评分点：
- 释放顺序：先每行，再行指针数组；
- 创建和释放严格配对。[ref:6]
课堂引导：
 “int** 的二维为什么说‘不一定连续’？它到底连续的是哪一段？”[ref:6]

---
E. 易错定义：数组指针 vs 指针数组
题 1（选择）
题目：int* q[50]; 更像：
 A. 50 个 int  B. 50 个指针  C. 指向 50 个 int 的指针  D. 指向指针的数组
答案：B[ref:6]
解析：
q 先和 [50] 结合，所以它是数组；数组元素类型是 int*，所以是“装了 50 个指针”的数组。[ref:6]
易错选项为什么错：
- C 描述的是 int (*p)[50] 那种。
- D 说法太绕且不精确（它是“指针数组”，不是“指向指针的数组”这种含混表述）。[ref:6]
课堂引导：
 “看声明只做一件事：先找变量名，再看它先跟 [] 还是先跟 * 结合。”[ref:6]

---
题 2（选择）
题目：int (*p)[50]; 解读正确的是：
 A. p 是数组
 B. p 是指针，指向一个 50 长度的 int 数组
 C. p 是指向 int 的指针数组
 D. p 是二级指针
答案：B[ref:6]
易错选项为什么错：
- A 没看到 *p 在括号里，说明 p 本体是指针。
- C 把 (*p)[50] 看成 *p[50] 了（括号决定含义）。
- D 虽然“看起来很像复杂指针”，但它指向的是数组，不是指针。[ref:6]

---
F. 函数指针
题 1（选择）
题目：double (*p)(double,double); 中 p 是：
 A. 函数  B. 函数指针  C. 返回 double 的指针  D. 二级指针
答案：B[ref:6]
解析：
(*p) 把 p 说明成“指针”，后面的 (double,double) 说明它指向的东西是“可调用的函数”。[ref:6]
易错点（你可以板书对比）：
- double (*p)(...) ✅ 函数指针
- double *p(...) ❌ 这是“返回 double* 的函数声明”[ref:6]
课堂引导：
 “括号的重要性：没有括号，声明就变味。你能说出它变成了什么吗？”[ref:6]

---
题 2（编程）
题目：写 add/sub/mul，用函数指针根据输入选择运算。
参考答案（简洁可讲版）
#include <iostream>
using namespace std;

int add(int a,int b){ return a+b; }
int sub(int a,int b){ return a-b; }
int mul(int a,int b){ return a*b; }

int main() {
    char op; int x,y;
    cin >> op >> x >> y;

    int (*f)(int,int) = nullptr;
    if (op=='+') f = add;
    else if (op=='-') f = sub;
    else if (op=='*') f = mul;

    if (!f) return 0;
    cout << f(x,y) << "\n";
}
评分点：
- 三个函数签名一致；
- 指针变量 f 选中目标再调用；
- 判空防止非法操作。[ref:6]

---
G. main 的参数：argc/argv
题 1（判断）
题目：argc 至少为 1。(T/F)
答案：T[ref:1]
解析：
argv[0] 是程序名，所以参数个数至少包含它。[ref:1]
课堂引导：
 “你不传任何参数，argv[0] 里有什么？为什么必须有它？”[ref:1]

---
题 2（编程）
题目：参数形如 sum 3 4 5，输出 12（把 argv[i] 转整数）。
参考答案
#include <iostream>
#include <string>
using namespace std;

int main(int argc, char* argv[]) {
    if (argc < 3) return 0; // 至少: 程序名 sum 以及一个数字

    long long s = 0;
    for (int i = 2; i < argc; ++i) s += stoll(argv[i]);
    cout << s << "\n";
}
评分点：
- 从 argv[2] 开始累加（argv[1] 是命令 sum）；
- 使用 stoi/stoll 做字符串转数；
- argc 检查避免越界。[ref:1]
易错点：
- 直接 s += argv[i];（把指针/字符串当数）
- 循环从 1 开始导致把 "sum" 也拿去转数字报错。[ref:1]

---
