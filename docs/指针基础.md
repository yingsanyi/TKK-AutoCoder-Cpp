
---
Lesson 25｜指针基础（讲义版）
本节课我们只做一件事：把“指针”从抽象名词变成你脑子里能看见、手上能写对的东西。你会发现：指针其实就是“地址标签”，引用就是“别名贴纸”，一旦画面对了，代码就顺了[ref:2,6]。

---
1）变量的地址与内存
先把画面立起来
把内存想成一条长走廊，走廊上是一格一格的柜子，每格柜子都有自己的编号（地址）。一个柜子装 1 字节。
 你声明一个变量，相当于在走廊里“占了一段连续柜子”。变量的地址，说白了就是：这段柜子的第一个编号。[ref:2,6]
代码：看看“占了几格”和“从哪一格开始”
#include <iostream>
using namespace std;

int main() {
    char c = 'A';
    int x = 10;
    double d = 2.5;

    cout << "c: sizeof=" << sizeof(c) << " addr=" << (void*)&c << "\n";
    cout << "x: sizeof=" << sizeof(x) << " addr=" << &x << "\n";
    cout << "d: sizeof=" << sizeof(d) << " addr=" << &d << "\n";
    return 0;
}
练习题
选择题
1. 变量的地址通常指的是：
 A. 最后一个字节的地址  B. 第一个字节的地址  C. 变量的值  D. 寄存器编号
2. sizeof(char) 一定是多少？
 A. 1  B. 2  C. 4  D. 不确定
填空题 3. 取地址运算符是 ____。
 4. sizeof(x) 的单位是 ____。
判断题 5. 同一个变量在同一次运行中，它的地址通常不变。(T/F)
 6. cout << &c 一定会打印出一个“类似 0x...” 的地址。(T/F)
编程题 7. 定义 char/int/double 各一个，打印它们的地址与 sizeof，观察地址之间的差值。
容易踩的坑
- int 经常是 4 字节，但不要背成“语言规定”，能确定的只有 char 是 1 字节这一点[ref:2]。
- &c（c 是 char）有时会被当作字符串起始地址去打印，输出会很怪；想稳就转 (void*)&c[ref:2]。

---
2）指针变量的定义与使用
先把画面立起来
指针可以理解成“地址标签”：它不装数据本体，它装的是数据在哪。
int* p 就是：这张标签上写的是“某个 int 住在哪里”。标签自己也是变量，所以它也占内存、也有大小（32 位常见 4 字节，64 位常见 8 字节）[ref:2,6]。
代码：标签写上地址，再按地址去取值
#include <iostream>
using namespace std;

int main() {
    int a = 123;
    int* p = &a;

    cout << "p=" << p << "\n";     // 地址标签上的内容
    cout << "*p=" << *p << "\n";   // 去地址处把值拿出来
    return 0;
}
练习题
选择题
1. int* p; 的含义是：
 A. p 是 int 变量  B. p 保存 int 的地址  C. p 保存 double 的地址  D. p 是引用
2. 哪个表达式是在“取值”（解引用）？
 A. &a  B. *p  C. sizeof(p)  D. new int
填空题 3. 把 a 的地址交给 p：p = ____;
 4. 指针变量的大小通常和 ____（平台位数/所指类型）更相关。
判断题 5. double* 可以直接指向 int 的地址且完全没问题。(T/F)
编程题 6. 声明 int* / double* / char* 各一个，打印 sizeof，看看是否相同。
容易踩的坑
- int* p, q; 只有 p 是指针，q 是普通 int。建议拆开写，少吃亏[ref:2]。
- 指针类型要对上：别把“double 的地址标签”当成“int 的地址标签”用，强转更是埋雷[ref:2]。

---
3）通过指针修改值与空指针
先把画面立起来
*p = 12 就像：你拿着地址标签找到那个柜子，直接把柜子里的东西换成 12。
nullptr 就是：标签上写着“没地址”。你还去 *q，等于闭眼开门——不是你家门，必出事[ref:2,6]。
代码：改值 + 判空
#include <iostream>
using namespace std;

int main() {
    int x = 10;
    int* p = &x;

    *p = 12;
    cout << "x=" << x << ", *p=" << *p << "\n";

    int* q = nullptr;
    if (q != nullptr) cout << *q << "\n";
    else cout << "q is null\n";
    return 0;
}
练习题
选择题
1. *p = 12; 的意思是：
 A. 改 p 的地址  B. 改 p 指向位置的值  C. 让 p 为空  D. 创建新变量
2. 推荐表示空指针的是：
 A. 0  B. NULL  C. nullptr  D. -1
判断题 3. 未初始化指针如果“碰巧”指到有效地址，解引用就没问题。(T/F)
 4. delete nullptr; 会崩溃。(T/F)
填空题 5. “野指针/悬空指针”常见来源：____（未初始化 / 指向已释放内存 / 两者都有）
编程题 6. 写 void safePrint(const int* p)：为空打印 "null"，不为空打印 *p。
容易踩的坑
- 最常见崩溃：野指针、悬空指针、空指针解引用[ref:2]。
- 判空是习惯问题：只要参数允许为空，就必须在使用前检查（或在接口约定里明确“不允许为空”）[ref:2]。

---
4）指针作为函数参数（让函数“改得动外面的变量”）
先把画面立起来
值传递像“给你一张复印件”；你在复印件上涂改，不影响原件。
 把地址传进去像“把钥匙/门牌号给你”；你一改，改的是原来的那份。[ref:2,6]
代码：交换 + 三数排序
#include <iostream>
using namespace std;

void mySwap(int* x, int* y) {
    int t = *x;
    *x = *y;
    *y = t;
}

void sort3(int* a, int* b, int* c) {
    if (*a > *b) mySwap(a, b);
    if (*a > *c) mySwap(a, c);
    if (*b > *c) mySwap(b, c);
}

int main() {
    int a = 3, b = 1, c = 2;
    sort3(&a, &b, &c);
    cout << a << " " << b << " " << c << "\n";
    return 0;
}
练习题
选择题
1. mySwap(&a, &b) 传进去的是：A 值  B 地址  C 引用  D 常量
2. void f(int* p) 中的 p 是：
 A 外部变量本体  B 外部变量别名  C 地址的一份拷贝（但指向同一处） D 临时对象
判断题 3. 用指针做参数，函数内部可以修改外部变量。(T/F)
 4. mySwap(nullptr, &b) 一定安全。(T/F)
编程题 5. 写 void inc(int* p)：如果不为空就自增。
 6. 写 void clampMin(int* p, int minVal)：把 *p 至少变成 minVal（判空）。
容易踩的坑
- 忘了取地址：把 sort3(a,b,c) 写成值传递，函数里改不动外面[ref:2]。
- 指针参数到底允不允许为 nullptr，要在题目/接口里讲清楚，不然学生容易“偶尔崩溃”[ref:2]。

---
5）动态内存（new/delete）
先把画面立起来
局部变量像“临时桌面”：用完（离开作用域）自动收走。
new 像“去仓库租一个格子长期放东西”：你得自己 delete 归还，不还就越积越多，叫内存泄漏[ref:2,6]。
代码：申请—使用—释放—置空
#include <iostream>
using namespace std;

int main() {
    int* p = new int(10);
    cout << *p << "\n";

    delete p;
    p = nullptr; // 养成习惯：避免悬空指针
    return 0;
}
练习题
选择题
1. delete 应该用于：
 A 任意指针  B 指向栈变量的指针  C new 得到的指针或空指针  D 任何地址
2. 忘记 delete 的结果通常是：
 A 编译失败  B 内存泄漏  C 自动回收  D 程序更快
判断题 3. 同一个指针 delete 两次也没关系。(T/F)
 4. new 失败一定返回 nullptr。(T/F)
编程题 5. 动态申请一个 int，读入值，输出两倍，释放。
 6. 进阶：动态申请 n 个 int（数组），读入并求和。（提示：new[]/delete[]）
容易踩的坑
- new 配 delete，new[] 配 delete[]，不要混用[ref:2]。
- 三大事故：忘记释放、重复释放、释放后继续用（悬空）[ref:2]。
- 课堂可以顺带提一句：实际项目更推荐 vector/unique_ptr，少手写 new/delete，出错率会低很多[ref:2]。

---
6）指针运算与强制类型转换
先把画面立起来
指针往前走一步，不是“地址 +1”，而是“跨过一个完整元素”。
 比如 int* p，p+1 就像从第 1 个整型格子跳到第 2 个整型格子，中间跨过 sizeof(int) 个字节。[ref:2]
强制类型转换就像：同一张地址标签，你硬要把它贴成“另一种柜子类型”的标签——可能暂时能用，但很容易不稳、不可移植[ref:2]。
代码：用数组演示“跳格子”
#include <iostream>
using namespace std;

int main() {
    int a[4] = {10, 20, 30, 40};
    int* p = a;

    cout << *p << "\n";        // 10
    cout << *(p + 2) << "\n";  // 30
    cout << (p + 1) - p << "\n"; // 1（相差的元素个数）
    return 0;
}
代码：低层强转（课堂演示即可，别鼓励滥用）
#include <iostream>
using namespace std;

int main() {
    int x = 0x12345678;
    unsigned char* q = reinterpret_cast<unsigned char*>(&x);
    cout << (int)q[0] << "\n"; // 受大小端影响
    return 0;
}
练习题
选择题
1. int* p; p+1 实际移动：A 1 字节  B sizeof(int) 字节  C 4 位  D 不移动
2. p - q（同一数组内）通常表示：A 字节数  B 元素个数差  C 随机  D 指针拼接
判断题 3. 指针 + 指针 是合法运算。(T/F)
 4. 通过强转读“第一个字节”的结果在所有机器上都一样。(T/F)
编程题 5. 不用下标，用指针遍历数组并输出。
 6. 实现 int distance(int* first, int* last)，要求 last 是尾后指针，返回元素个数。
容易踩的坑
- 指针相减、比较、走动，尽量只在**同一数组（含尾后）**里做，越界就危险[ref:2]。
- 读字节会受大小端影响，强转的结果很多时候并不“通用正确”[ref:2]。

---
7）扩展：引用（Reference）
先把画面立起来
引用你可以当成“外号”：人还是同一个人，只是多了个叫法。
int& r = a; 之后，r 和 a 动的是同一块内存。它不像指针那样拿着“地址标签”，它更像“直接把名字贴过去”。[ref:2]
右值引用可以先简单理解成：专门用来接“临时对象”的，把资源“搬家”搬得更快（后面讲移动语义再深入）[ref:2,6]。
代码：用引用做交换（更不容易传错）
#include <iostream>
using namespace std;

void swapRef(int& x, int& y) {
    int t = x;
    x = y;
    y = t;
}

int main() {
    int a = 1, b = 2;
    swapRef(a, b);
    cout << a << " " << b << "\n";
    return 0;
}
代码：右值引用最小示意
#include <iostream>
using namespace std;

int main() {
    int a = 10;
    int&& r = a + 1;
    cout << r << "\n";
    return 0;
}
练习题
选择题
1. int& r = a; 中 r 是：A 拷贝  B 别名  C 指针  D 临时变量
2. 哪句合法：
 A int& r = 10;  B const int& r = 10;  C int&& r = a;  D int&& r = 10;
判断题 3. 引用必须初始化。(T/F)
 4. 引用可以为空，像 nullptr 那样。(T/F)
编程题 5. 用引用实现 sort3(int&, int&, int&)。
 6. 写 void add1(int&)：传进来就自增并输出。
容易踩的坑
- 引用必须初始化，而且一般不能“改绑”到别的对象；这点和指针差别很大[ref:2]。
- 右值引用先别乱用，把它当成“性能工具”，等讲到移动语义再系统吃透[ref:2]。

---
课堂最后 1 分钟：高频雷区清单
1. 未初始化指针、空指针/悬空指针解引用（最常见崩溃）[ref:2]
2. new/delete、new[]/delete[] 配错；重复释放；释放后继续用[ref:2]
3. 指针越界走动、跨数组比较/相减[ref:2]
4. &char 打印地址的“像字符串”陷阱（记得 (void*)）[ref:2]
5. 滥用强转（特别是为了“能编过”去强转）[ref:2]

---

教师版（含答案 + 解析要点 + 常见误区提醒）[ref:2,6]
说明：涉及“地址输出”的题，不要要求学生给出具体地址值；只考“会不会用 & / * / 判空 / 配对释放 / 指针运算含义”。地址会随运行变化，属于正常现象[ref:2]。

---
1）变量的地址与内存
选择题答案
1. B。变量地址通常指首字节地址。[ref:2]
2. A。标准保证 sizeof(char)==1。[ref:2]
填空题答案
3. &。[ref:2]
4. 字节（bytes）。[ref:2]
判断题答案
5. T（同一次运行里通常不变；跨运行/ASLR 可能变）。[ref:2]
6. F（&c 可能被当 C 字符串指针打印；需 (void*)&c 更稳）。[ref:2]
编程题评分点（题 7）
- 必须打印 sizeof 和 &变量；char 地址建议强转 (void*)。
- 观察“地址差值 ≈ sizeof”只做现象讨论，不作为硬性判分（受对齐、布局影响）。[ref:2]
常见误区提醒
- 把“常见：int 4 字节”当“永远 4”。应提醒：大小与实现有关。[ref:2]

---
2）指针变量的定义与使用
选择题答案
1. B。[ref:2]
2. B（*p 解引用取值）。[ref:2]
填空题答案
3. &a。[ref:2]
4. 平台位数（更准确：与地址宽度相关；与所指类型无关）。[ref:2]
判断题答案
5. F（类型不匹配；强转也可能引入未定义/实现相关问题）。[ref:2]
编程题评分点（题 6）
- sizeof(int*) sizeof(double*) sizeof(char*) 在同一平台通常相同。
- 允许学生写“32 位常见 4、64 位常见 8”，但不要要求固定数值。[ref:2]
常见误区提醒
- int* p, q; 只有 p 是指针：这是典型低级坑。[ref:2]

---
3）通过指针修改值与空指针
选择题答案
1. B。[ref:2]
2. C（nullptr 更类型安全）。[ref:2]
判断题答案
3. F（未初始化指针解引用是未定义行为，“运气好”不算正确）。[ref:2]
4. F（delete nullptr; 安全，无效果）。[ref:2]
填空题答案
5. 两者都有（未初始化、或指向已释放内存都可能）。[ref:2]
编程题参考答案（题 6）
#include <iostream>
using namespace std;

void safePrint(const int* p) {
    if (p == nullptr) cout << "null";
    else cout << *p;
}
评分点：判空在解引用之前；参数可写 const int*。[ref:2]
常见误区提醒
- 把 nullptr 当“可用地址 0”：强调“可以比较/传递/删除，但不能解引用”。[ref:2]

---
4）指针作为函数参数（地址传递）
选择题答案
1. B。[ref:2]
2. C（形参 p 是地址的拷贝，但指向同一处）。[ref:2]
判断题答案
3. T。[ref:2]
4. F（nullptr 解引用会出问题；交换函数需判空或约定不允许空）。[ref:2]
编程题参考答案
题 5：inc
void inc(int* p) {
    if (p) ++(*p);
}
题 6：minmax
void minmax(int* a, int* b) {
    if (!a || !b) return;
    if (*a > *b) {
        int t = *a; *a = *b; *b = t;
    }
}
评分点：先判空再解引用；交换用临时变量。[ref:2]
常见误区提醒
- 学生常把 swap(a,b) 写成值传递；要强调调用时 &a。[ref:2]

---
5）动态内存（new/delete）
选择题答案
1. C（应删除 new 得到的指针；delete nullptr 安全）。[ref:2]
2. B（内存泄漏）。[ref:2]
判断题答案
3. F（重复 delete 是未定义行为）。[ref:2]
4. F（C++ 的 new 默认抛异常 std::bad_alloc；不一定返回 nullptr）。[ref:2]
编程题参考答案
题 5
#include <iostream>
using namespace std;

int main() {
    int* p = new int;
    cin >> *p;
    cout << (*p) * 2 << "\n";
    delete p;
    p = nullptr;
}
题 6（数组版）
#include <iostream>
using namespace std;

int main() {
    int n; 
    cin >> n;
    int* a = new int[n];
    long long sum = 0;
    for (int i = 0; i < n; ++i) { cin >> a[i]; sum += a[i]; }
    cout << sum << "\n";
    delete[] a;
    a = nullptr;
}
评分点：数组必须 delete[]；释放后置空是加分项。[ref:2]
常见误区提醒
- new[]/delete 混用、new/delete[] 混用。
- 释放后继续用（悬空指针）与重复释放。[ref:2]

---
6）指针运算与强制类型转换
选择题答案
1. B（移动 sizeof(int) 字节）。[ref:2]
2. B（同一数组内相差的“元素个数”）。[ref:2]
判断题答案
3. F（指针 + 指针非法）。[ref:2]
4. F（受大小端、对齐等影响；不可移植）。[ref:2]
编程题参考答案
题 5：指针遍历输出
void printArr(const int* a, int n) {
    for (const int* p = a; p < a + n; ++p) {
        cout << *p << " ";
    }
    cout << "\n";
}
题 6：distance（尾后指针）
int distanceInt(const int* first, const int* last) {
    return static_cast<int>(last - first);
}
评分点：last-first 表示元素个数差；强调仅在同一数组/尾后范围内。[ref:2]
常见误区提醒
- 允许 p+1、p- q（同一数组），不允许 p+p。
- 指针越界走动属于未定义行为（不要鼓励“刚好没崩就算对”）。[ref:2]

---
7）引用（Reference）
选择题答案
1. B（别名）。[ref:2]
2. B、D（const int& r=10; 合法；int&& r=10; 合法）。[ref:2]
判断题答案
3. T（引用必须初始化）。[ref:2]
4. F（引用不能为“空”，没有 nullptr 引用）。[ref:2]
编程题参考答案
题 5：引用版 sort3
void swapRef(int& x, int& y) { int t = x; x = y; y = t; }

void sort3(int& a, int& b, int& c) {
    if (a > b) swapRef(a, b);
    if (a > c) swapRef(a, c);
    if (b > c) swapRef(b, c);
}
题 6：add1
#include <iostream>
using namespace std;

void add1(int& x) { ++x; cout << x << "\n"; }
评分点：引用形参能直接改外部变量；无需取地址与解引用。[ref:2]
常见误区提醒
- 把引用当成“隐藏指针”：强调语义是别名、必须绑定到有效对象。[ref:2]

---
教师用“课堂口头强调”清单（建议最后 1 分钟）[ref:2]
1. 先判空再解引用（能救命）。
2. new/delete 与 new[]/delete[] 必须配对。
3. 指针运算只在**同一数组（含尾后）**里做。
4. &char 打印地址要 (void*)。
5. 强转不是“让它能跑”的工具；越强转越可能越界到未定义行为。