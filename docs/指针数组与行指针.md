

---

# 一、指针数组：数组的每个元素都是指针

## 1. 什么是“指针数组”？

**通俗理解：**

- 正常的一维数组：一排“整数格子”  
  `int a[3];` → 三个 `int`：a[0], a[1], a[2]
- **指针数组**：一排“指针格子”  
  `int *p[3];` → 三个 `int*`：p[0], p[1], p[2]，每个元素自己又可以指向一个 `int`

**定义形式：**

```cpp
int *p[3];    // “指针数组”：含 3 个 int* 元素
//           // p[0], p[1], p[2] 都是 int* 类型
```

注意：`*` 靠近变量名：`p` 是数组，数组元素是 `int*`。

---

## 2. 最常见例子：让数组里的每个指针指向不同变量

```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 10, y = 20, z = 30;

    int *p[3];   // 指针数组：里面放 3 个 int*
    p[0] = &x;
    p[1] = &y;
    p[2] = &z;

    cout << "通过指针数组访问：" << endl;
    cout << *p[0] << " " << *p[1] << " " << *p[2] << endl;

    // 也可以通过指针改原变量：
    *p[0] = 100;
    *p[1] = 200;
    *p[2] = 300;

    cout << "修改后 x,y,z：" << endl;
    cout << x << " " << y << " " << z << endl;

    return 0;
}
```

**解析：**

- `p` 是一个长度为 3 的数组：
  - `p[0]` 是 `int*`，存的是 `x` 的地址
  - `p[1]` 是 `int*`，存的是 `y` 的地址
  - `p[2]` 是 `int*`，存的是 `z` 的地址
- `*p[i]` 就是“去 `p[i]` 里存的地址那儿，拿/改那个 `int` 的值”：
  - `*p[0] = 100;` 等价于 `x = 100;`

这就是“指针数组”：**数组本身是连续的，只不过每个格子里装的不是 int，而是 int 的地址**。

---

## 3. 指针数组 + 字符串常量（经典用法）

经常看到这样的写法：

```cpp
#include <iostream>
using namespace std;

int main() {
    const char *words[3] = {
        "hello",
        "world",
        "C++"
    };

    for (int i = 0; i < 3; ++i) {
        cout << words[i] << endl;
    }

    return 0;
}
```

**解析：**

- `"hello"` 是字符串常量，对应类型大致是 `const char[6]`，在表达式中会衰变成 `const char*`
- `const char *words[3];` 说明：  
  `words` 是一个数组，里面有 3 个 `const char*`
- `words[0]` 是指向 `"hello"` 的指针，`words[1]` 是 `"world"`，`words[2]` 是 `"C++"`

**所以：**

- `words` 是“指针数组”
- 每个指针指向一个以 `\0` 结尾的 C 风格字符串
- 遍历时 `cout << words[i];` 就会依次打印这些字符串

---

## 4. 用指针数组操作多个一维数组

有时候你会有多行数据，但每行用一个普通一维数组存：

```cpp
#include <iostream>
using namespace std;

int main() {
    int row1[3] = {1, 2, 3};
    int row2[3] = {4, 5, 6};
    int row3[3] = {7, 8, 9};

    // 指针数组，每个元素指向一行的一维数组
    int *rows[3] = { row1, row2, row3 };

    // 打印“3 行 3 列”的内容
    for (int i = 0; i < 3; ++i) {       // 第 i 行
        for (int j = 0; j < 3; ++j) {   // 第 j 列
            cout << rows[i][j] << " ";
            // rows[i] 是 int*，rows[i][j] 等价于 *(rows[i] + j)
        }
        cout << endl;
    }

    return 0;
}
```

**解析：**

- `rows` 是长度为 3 的 `int*` 数组：
  - `rows[0] = row1`（退化为 `&row1[0]`）
  - `rows[1] = row2`
  - `rows[2] = row3`
- `rows[i]` 是“指向某一行首元素的指针”
- `rows[i][j]` 相当于：先用 `rows[i]` 找到这行的起点，再根据 j 找这一行的第 j 个元素

**从使用效果看，它有点像一个“二维数组”，但实际上是：**

> 一个“指针的一维数组”，每个指针指向一个“一维数组”。

这一点和真正的 `int a[3][3];` 有差别，后面讲 “行指针” 时会对比。

---

## 5. 指针数组的小坑：和“数组指针”容易搞混

- 指针数组：`int *p[3];`  
  “p 是**数组**，数组元素是 `int*`”
- 数组指针（行指针）：`int (*p)[3];`  
  “p 是**指针**，指向一个含 3 个 int 的数组”

差别只是括号位置不一样，但含义完全不同：

```cpp
int *p[3];     // 指针数组
int (*q)[3];   // 数组指针（行指针）
```

后面会重点讲 `int (*q)[3];` 这种“行指针”。

---

# 二、行指针（数组指针）：指向整个一维数组的指针

很多教材会这么说：**“行指针”**  
其实就是：**指向一整行（一个一维数组）的指针**，对应的标准叫法是“数组指针”。

以一个二维数组为例最直观：

```cpp
int a[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
```

这里：

- `a[0]` 是一维数组：`int[3]`，可以叫“第 0 行”
- `a[1]` 也是一维数组：`int[3]`，叫“第 1 行”

**所谓“行指针”**：就是指向这些 `int[3]` 的指针。

---

## 1. 行指针（数组指针）的定义和含义

### 基本形式

```cpp
int a[2][3];
int (*p)[3] = a;  // p 是“行指针”：指向含 3 个 int 的数组
```

**通俗理解：**

- `a`：有 2 行，每行 3 列  
- `a` 在表达式中大部分地方会退化成 `int (*)[3]`，即“指向一行”的指针  
- `p` 的类型是 `int (*)[3]`：
  - `*p` 的类型是 `int[3]`（一行）
  - `(*p)[0]` 是这一行的第 0 个元素，即 `int`

---

## 2. 用行指针遍历二维数组（不涉及结构体）

```cpp
#include <iostream>
using namespace std;

int main() {
    int a[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };

    int (*p)[3] = a;    // 指向“每行有 3 个 int 的数组”的指针

    // 遍历：p 从 a 到 a+2
    for (int i = 0; i < 2; ++i) {      // i 行
        // p + i 指向第 i 行
        int *row = *(p + i);          // row 是 int*，指向这一行的第一个元素
        for (int j = 0; j < 3; ++j) { // j 列
            cout << row[j] << " ";    // row[j] == a[i][j]
        }
        cout << endl;
    }
}
```

**解析：**

- `a` 在赋值给 `p` 时退化为 `int (*)[3]`，即行指针
- `p + i`：指向第 i 行（一维数组）
- `*(p + i)`：是一个 `int[3]`，在表达式中又退化为 `int*`，即这一行的首元素地址
- 所以 `row[j]` == `a[i][j]`

**大白话：**

> 行指针 `p` 不是指向单个 `int`，而是指向“一整行的 3 个 int”。  
> 每次 `p++`，就跳过一整行，指向下一行。

---

## 3. 行指针作为函数参数：处理二维数组

当你写函数处理二维数组时，经常会看到这样的写法：

```cpp
void print2D(int (*p)[3], int rows) {
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < 3; ++j) {
            cout << p[i][j] << " ";
        }
        cout << endl;
    }
}
```

调用：

```cpp
int a[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
print2D(a, 2);   // a 自动退化为 int (*)[3]
```

**解析：**

- 形参 `int (*p)[3]`：说明 `p` 是行指针，每行有 3 个 `int`
- `p[i]` 是第 i 行（一维数组），类型是 `int[3]`，在表达式里退化为 `int*`
- `p[i][j]` 等价于 `*(*(p + i) + j)`，就是典型的二维数组访问

**为什么要写 `int (*p)[3]`，而不是 `int **p`？**

- `int **p` 是“指向 `int*` 的指针”，和二维数组的内存布局不一定兼容，容易出错  
- 真正的 `int a[M][N]` 在内存里是连续的，行指针能正确描述它的布局

---

## 4. 行指针 VS 指针数组：内存布局和用法的区别

用一个例子对比：

### （1）二维数组 + 行指针

```cpp
int a[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};

int (*p)[3] = a;  // 行指针
```

- `a` 整块连续内存：6 个 int  
- `p` 是指向第 0 行（3 个 int）的指针
- `p + 1` 指向第 1 行（又 3 个 int）

### （2）指针数组模拟“二维”

```cpp
int r1[3] = {1, 2, 3};
int r2[3] = {4, 5, 6};
int *rows[2] = { r1, r2 };  // 指针数组
```

- `rows` 是一个数组，里面有两个 `int*`
- `rows[0]` 指向 `r1`，`rows[1]` 指向 `r2`
- `r1` 和 `r2` 可能不是连在一起的（栈上一般也是分开分配的）

**使用方式上看：**

- `a[i][j]`  
- `p[i][j]`（行指针）  
- `rows[i][j]`（指针数组）

这三种写法表面一模一样，但背后的内存结构不一样：

| 写法         | 内存是否一整块连续 | 第 0 维是什么 | 第 1 维如何访问        |
|--------------|--------------------|---------------|------------------------|
| `int a[2][3]`    | 是                  | 真数组        | `a[i][j]`              |
| `int (*p)[3]`    | 是（指向 a）        | 行指针        | `p[i][j]`              |
| `int *rows[2]`   | 不一定              | 指针数组      | `rows[i][j]`（先取指针，再偏移） |

**记忆方式：**

- 想要“真二维数组”的连续内存 → 用二维数组 + 行指针  
- 想要“每行长度可以不一样”或“行是单独创建的” → 用指针数组

---

## 5. 行指针也可以指向“一维数组”

二维数组只是一个例子，本质是：

```cpp
int a[3] = {1, 2, 3};
int (*p)[3] = &a;  // p 指向“这个一维数组”
```

你可以这样访问：

```cpp
#include <iostream>
using namespace std;

int main() {
    int a[3] = {10, 20, 30};
    int (*p)[3] = &a;  // p 指向整个数组 a

    // (*p) 是 a，本身是 int[3]，在表达式里可当作 int*
    cout << (*p)[0] << " " << (*p)[1] << " " << (*p)[2] << endl;

    // 甚至可以用指针算术：
    int *q = *p;      // q 指向 a[0]
    cout << q[0] << " " << q[1] << " " << q[2] << endl;

    return 0;
}
```

**解析：**

- `p` 是“数组指针”；`*p` 表示它指向的数组本身
- `(*p)[i]` 和 `a[i]` 是同一个东西

这种写法不算非常常用，但在更复杂的多维参数传递中会出现，有必要看懂。

---

# 三、如何不再混淆：指针数组 vs 行指针

用一句话总结这两种东西：

- **指针数组**：`int *p[3];`  
  “p 是数组，元素是指针”，适合：  
  > 有很多东西（变量/一维数组/字符串），我想用一堆指针把它们都记下来。

- **行指针（数组指针）**：`int (*p)[3];`  
  “p 是指针，指向一整行（3 个 int 的数组）”，适合：  
  > 我已经有一块连续的二维/一维数组，希望用一个指针按“行”为单位去走。

### 一眼看懂的口诀：

- `int *p[3];`：看成“`p[3]` 是 `int*`” → 数组里装着指针  
- `int (*p)[3];`：看成“`*p` 是 `int[3]`” → 指针指向一整行数组

