
---
C++指针与引用综合练习题
一、选择题（共30题）
题目1 函数参数传递与交换
以下哪几个函数能实现交换？
void swap1(int a, int b) {   
    int p; p = a; a = b; b = p;   
}  
void swap2(int* a, int* b) {   
    int p; p = *a; *a = *b; *b = p;   
}  
void swap3(int &a, int &b) {   
    int p; p = a; a = b; b = p;   
}  
void swap4(int* a, int* b) {   
    int* p; *p = *a; *a = *b; *b = *p;   
}
- (A) swap1, swap2
- (B) swap2, swap3
- (C) swap3, swap4
- (D) swap1, swap4
答案：B
解析：
- swap1：值传递，形参的改变不影响实参，无法实现交换。
- swap2：指针传递，通过解引用修改实参的值，能实现交换。
- swap3：引用传递，直接操作实参，能实现交换。
- swap4：指针p未初始化就使用*p，会导致未定义行为（野指针），无法正确交换。

---
题目2
设有一个 double 类型的变量 a，需要定义一个指针 p 指向该变量，下面关于指针 p 的语句正确的是（ ）
- (A) int p = &a;
- (B) double p; p = &a;
- (C) int* p; p = a;
- (D) double* p = &a;
答案：D
解析：
- (A) 类型不匹配，int变量不能存储地址
- (B) double变量不能存储地址
- (C) 类型不匹配，且p=a是将值赋给指针
- (D) 正确，double*类型指针指向double变量的地址

---
题目3
设 p 是指向类型 a 的指针，以下哪个表示变量 a 的地址（ ）
- (A) p
- (B) &p
- (C) a
- (D) *p
答案：A
解析：
- (A) p存储的就是a的地址
- (B) &p是指针p自身的地址
- (C) a是变量的值
- (D) *p是解引用，得到a的值

---
题目4
有如下语句：int a; int* p; 则 &a 和 p 的数据类型分别是（ ）
- (A) int* , int*
- (B) int &, int*
- (C) int* , int
- (D) int &, int
答案：A
解析：
- &a 是取地址运算符，结果是 int* 类型
- p 是指针变量，类型是 int*
- 注意：int& 是引用类型的声明语法，不是&运算符的结果类型

---
题目5
设 p 为指向 char 型变量的指针，指针 q 为指向 int 型变量的指针，则 sizeof(p) 和 sizeof(q) 的值分别为（ ）
- (A) 1，1
- (B) 1，4
- (C) 4，1
- (D) 4，4
答案：D
解析： 在32位系统中，所有指针的大小都是4字节；在64位系统中都是8字节。指针的大小与其指向的类型无关，只与系统的地址总线宽度有关。

---
题目6
在 32 位操作系统中，下面几个 sizeof 的运行结果是（ ）
int intValue = 1024; char charValue = 'C';  
int* intPointer = &intValue; char* charPointer = &charValue;  
sizeof(intValue) = a; sizeof(charValue) = b;  
sizeof(intPointer) = c; sizeof(charPointer) = d;
- (A) a=1, b=1, c=1, d=1
- (B) a=4, b=1, c=4, d=1
- (C) a=4, b=1, c=4, d=4
- (D) a=4, b=4, c=4, d=4
答案：C
解析：
- int类型占4字节
- char类型占1字节
- 32位系统中所有指针都占4字节

---
题目7
以下代码的输出结果是（ ）
int a = 2, *p; p = &a;  
(*p)++;  
cout << *p;
- (A) 2
- (B) 0
- (C) 一个十六位内存地址编号
- (D) 3
答案：D
解析：(*p)++ 先解引用得到a的值2，然后自增，a变为3，输出*p即a的值，结果为3。

---
题目8
下列函数定义中，有语法错误的是（ ）
- (A) int fun(int x, int* y) { x *= *y; return x; }
- (B) int fun(int x, int* y) { *y *= *y; return x; }
- (C) int fun(int* x, int y) { *x += y; return *x; }
- (D) int fun(int x, int y) { return x + y; }
答案：无语法错误，如果必须选则选B（逻辑上可能有问题）
解析： 从纯语法角度，四个函数都没有语法错误。但如果考虑函数重载和命名冲突，四个函数名相同会导致问题。如果单独看每个函数，都是合法的。

---
题目9 代码阅读
以下程序的输出结果是（ ）
int a = 5;
int *p = &a;
int **pp = &p;
**pp = 10;
cout << a;
- (A) 5
- (B) 10
- (C) 地址值
- (D) 编译错误
答案：B
解析： pp是指向指针的指针，**pp等价于a，赋值为10后，a的值变为10。

---
题目10 代码阅读
以下程序的输出结果是（ ）
int arr[5] = {1, 2, 3, 4, 5};
int *p = arr;
cout << *(p + 2);
- (A) 1
- (B) 2
- (C) 3
- (D) 4
答案：C
解析： 数组名arr可以隐式转换为指向首元素的指针，p+2指向arr[2]，*(p+2)即arr[2]的值3。

---
题目11 代码阅读
以下程序的输出结果是（ ）
int a = 10, b = 20;
int *p = &a;
*p = 30;
p = &b;
*p = 40;
cout << a << " " << b;
- (A) 10 20
- (B) 30 20
- (C) 30 40
- (D) 40 30
答案：C
解析：
- *p = 30 使a变为30
- p = &b 使p指向b
- *p = 40 使b变为40
- 输出a=30, b=40

---
题目12
关于NULL指针和nullptr，下列说法正确的是（ ）
- (A) NULL和nullptr完全相同
- (B) nullptr是C++11引入的空指针字面值，类型安全性更好
- (C) NULL只能用于指针，不能用于整数
- (D) nullptr可以隐式转换为int类型
答案：B
解析： nullptr是C++11引入的关键字，类型为nullptr_t，提供更好的类型安全。NULL通常定义为0或((void*)0)，可能导致重载决议的问题。

---
题目13 代码阅读
以下程序的输出结果是（ ）
int a[5] = {1, 2, 3, 4, 5};
int *p = a + 1;
cout << p[-1] << " " << p[1];
- (A) 1 2
- (B) 1 3
- (C) 2 3
- (D) 编译错误
答案：B
解析： p指向a[1]，p[-1]等价于*(p-1)即a[0]=1，p[1]等价于*(p+1)即a[2]=3。

---
题目14
下列关于引用的说法，错误的是（ ）
- (A) 引用必须在定义时初始化
- (B) 引用一旦绑定就不能改变绑定的对象
- (C) 可以定义指向引用的指针
- (D) 引用本身不是对象
答案：C
解析： 引用不是对象，没有实际地址，不能定义指向引用的指针。但可以定义引用的引用（在某些上下文中会被折叠）。

---
题目15 代码阅读
以下程序的输出结果是（ ）
int x = 5;
int &ref = x;
ref = 10;
int y = 20;
ref = y;
cout << x << " " << y;
- (A) 5 20
- (B) 10 20
- (C) 20 20
- (D) 10 10
答案：C
解析：
- ref = 10 使x变为10
- ref = y 是赋值操作（不是重新绑定），使x的值变为y的值20
- x=20, y=20

---
题目16
const指针和指向const的指针，下列定义正确的是（ ）
- (A) const int* p; 表示p是常量指针
- (B) int* const p; 表示p指向的内容不可修改
- (C) const int* const p; 表示p和p指向的内容都不可修改
- (D) 以上都不对
答案：C
解析：
- const int* p：指向常量的指针，指向可变，内容不可通过p修改
- int* const p：常量指针，指向不可变，内容可修改
- const int* const p：都不可变

---
题目17 代码阅读
以下程序的输出结果是（ ）
int arr[3] = {10, 20, 30};
int *p = arr;
cout << *p++ << " " << *p;
- (A) 10 10
- (B) 10 20
- (C) 20 20
- (D) 编译错误
答案：B
解析：*p++ 由于后置++的优先级，先取*p的值10，然后p自增指向arr[1]，再输出*p为20。

---
题目18 代码阅读
以下程序的输出结果是（ ）
int a = 5;
int *p = &a;
int *q = p;
*q = 20;
cout << a;
- (A) 5
- (B) 20
- (C) 地址值
- (D) 不确定
答案：B
解析： q和p都指向a，通过*q=20修改a的值为20。

---
题目19
动态内存分配，下列说法正确的是（ ）
- (A) new分配的内存必须用delete[]释放
- (B) delete释放空指针会导致程序崩溃
- (C) new[]分配的数组必须用delete[]释放
- (D) malloc和new可以混用
答案：C
解析：
- new配delete，new[]配delete[]
- delete空指针是安全的
- malloc/free与new/delete不应混用

---
题目20 代码阅读
以下程序的输出结果是（ ）
int a = 10;
int &ref = a;
int *p = &ref;
*p = 20;
cout << a << " " << ref;
- (A) 10 10
- (B) 10 20
- (C) 20 20
- (D) 编译错误
答案：C
解析： ref是a的引用，&ref得到a的地址，p指向a，*p=20修改a为20，a和ref都输出20。

---
题目21 代码阅读
以下程序的输出结果是（ ）
char str[] = "hello";
char *p = str;
p += 2;
cout << p;
- (A) hello
- (B) llo
- (C) ello
- (D) lo
答案：B
解析： p初始指向'h'，p+=2后指向'l'（第3个字符），输出从该位置到字符串结尾："llo"。

---
题目22
关于指针运算，下列说法错误的是（ ）
- (A) 两个指针可以相减
- (B) 指针可以加上整数
- (C) 两个指针可以相加
- (D) 指针可以进行关系运算
答案：C
解析： 指针可以相减（得到元素个数）、加减整数、进行比较，但不能相加（无实际意义）。

---
题目23 代码阅读
以下程序的输出结果是（ ）
int arr[4] = {1, 2, 3, 4};
int *p1 = &arr[0];
int *p2 = &arr[3];
cout << p2 - p1;
- (A) 3
- (B) 12
- (C) 4
- (D) 编译错误
答案：A
解析： 指针相减得到元素个数差，arr[3]与arr[0]相差3个元素。

---
题目24
函数参数中的const引用，下列说法正确的是（ ）
- (A) 可以接受临时对象和字面值
- (B) 可以修改传入的参数
- (C) 不能绑定到非const对象
- (D) 效率低于值传递
答案：A
解析： const引用可以绑定到临时对象、字面值和非const对象，且避免拷贝，效率高，但不能修改参数。

---
题目25 代码阅读
以下程序的输出结果是（ ）
int a = 5;
const int *p = &a;
a = 10;
cout << *p;
- (A) 5
- (B) 10
- (C) 编译错误
- (D) 不确定
答案：B
解析：const int* p表示不能通过p修改a，但可以直接修改a。a变为10后，*p也是10。

---
题目26 代码阅读
以下程序的输出结果是（ ）
void func(int *p) {
    static int a = 10;
    p = &a;
}
int main() {
    int b = 5;
    int *ptr = &b;
    func(ptr);
    cout << *ptr;
}
- (A) 5
- (B) 10
- (C) 不确定
- (D) 编译错误
答案：A
解析： func中的p=&a只改变了形参p的指向，不影响实参ptr，ptr仍指向b，输出5。

---
题目27
关于数组名和指针，下列说法错误的是（ ）
- (A) 数组名在大多数情况下会退化为指向首元素的指针
- (B) sizeof(数组名)返回整个数组的大小
- (C) 数组名可以被赋值
- (D) &数组名得到指向整个数组的指针
答案：C
解析： 数组名是常量，不能被赋值或自增。

---
题目28 代码阅读
以下程序的输出结果是（ ）
int a[5] = {1, 2, 3, 4, 5};
int (*p)[5] = &a;
cout << (*p)[2];
- (A) 1
- (B) 2
- (C) 3
- (D) 编译错误
答案：C
解析： p是指向含有5个int元素数组的指针，*p得到数组a，(*p)[2]即a[2]=3。

---
题目29 代码阅读
以下程序的输出结果是（ ）
int a = 10, b = 20;
int *p = &a, *q = &b;
*p = *p + *q;
cout << a << " " << b;
- (A) 10 20
- (B) 30 20
- (C) 30 30
- (D) 10 30
答案：B
解析：*p = *p + *q 即 a = a + b = 30，b不变仍为20。

---
题目30
关于野指针，下列说法正确的是（ ）
- (A) 野指针是指向NULL的指针
- (B) 野指针是未初始化或指向已释放内存的指针
- (C) 野指针可以安全使用
- (D) 所有指针默认都是野指针
答案：B
解析： 野指针指向不确定的内存位置，使用会导致未定义行为，应避免使用未初始化的指针或释放后继续使用的指针。

---
二、编程题（共5题）
编程题1 指针实现数组逆序
编写函数 void reverse(int *arr, int n)，使用指针将长度为n的数组逆序。
答案：
void reverse(int *arr, int n) {
    int *left = arr;
    int *right = arr + n - 1;
    while (left < right) {
        int temp = *left;
        *left = *right;
        *right = temp;
        left++;
        right--;
    }
}
解析： 使用双指针法，left指向首元素，right指向尾元素，交换后向中间移动，直到相遇。

---
编程题2 引用实现最大值最小值查找
编写函数 void findMinMax(int arr[], int n, int &minVal, int &maxVal)，使用引用参数返回数组的最小值和最大值。
答案：
void findMinMax(int arr[], int n, int &minVal, int &maxVal) {
    minVal = maxVal = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] < minVal) minVal = arr[i];
        if (arr[i] > maxVal) maxVal = arr[i];
    }
}
解析： 通过引用参数直接修改调用者的变量，避免返回值只能返回一个值的限制。

---
编程题3 动态数组操作
编写函数 int* createArray(int n)，动态分配长度为n的整型数组并初始化为1到n的值，返回指针。再编写函数 void deleteArray(int *arr) 释放内存。
答案：
int* createArray(int n) {
    int *arr = new int[n];
    for (int i = 0; i < n; i++) {
        arr[i] = i + 1;
    }
    return arr;
}

void deleteArray(int *arr) {
    delete[] arr;
}
解析： 使用new[]动态分配数组，必须用delete[]释放。注意返回局部指针是安全的，因为指向的是堆内存。

---
编程题4 字符串长度计算（指针实现）
编写函数 int myStrlen(const char *str)，使用指针遍历计算字符串长度（不使用strlen）。
答案：
int myStrlen(const char *str) {
    const char *p = str;
    while (*p != '\0') {
        p++;
    }
    return p - str;
}
解析： 指针p从字符串开始遍历到'\0'，p-str得到长度。使用const保证不修改字符串。

---
编程题5 指针数组排序
编写函数 void sortPointers(int *arr[], int n)，对指针数组按其指向的值进行升序排序（冒泡排序）。
答案：
void sortPointers(int *arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - 1 - i; j++) {
            if (*arr[j] > *arr[j + 1]) {
                int *temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
解析： 指针数组的每个元素是指针，比较时需要解引用（*arr[j]）获取值，交换时交换指针本身。

---
