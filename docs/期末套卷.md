一、选择题（50 题，五选一，代码阅读）
1.1 递归终止条件
#include <iostream>
using namespace std;

int f(int n){
    if(n==0) return 0;
    return f(n-1) + n;
}
int main(){
    cout << f(4);
}
A. 6  B. 8  C. 10  D. 12  E. 无限递归
答案：C
解析： 递归求和 (1+2+3+4=10)，终止条件 n==0。

---
1.2 递归返回值
#include <iostream>
using namespace std;

int g(int n){
    if(n<=1) return 1;
    return n * g(n-2);
}
int main(){
    cout << g(6);
}
A. 36  B. 48  C. 72  D. 120  E. 240
答案：C
解析： (g(6)=6g(4)=64g(2)=642g(0)=481=48)？注意 n<=1 return 1，所以 (g(0)=1)，结果 (642=48)。但 g(2)=2*g(0)=2，最终 (64*2=48)。选项里无 48？有 B=48，应选 B。
答案：B
解析： 同上，递归步长为 2[ref:2,5]。

---
1.3 递归与栈深度（读输出）
#include <iostream>
using namespace std;

void p(int n){
    if(n==0) return;
    cout << n;
    p(n-1);
    cout << n;
}
int main(){ p(3); }
A. 123321  B. 321123  C. 123123  D. 332211  E. 321321
答案：A
解析： 先序输出 3 2 1，回溯再输出 1 2 3[ref:2,5]。

---
1.4 重载：仅返回值不同？
#include <iostream>
using namespace std;

int h(int x){ return x; }
double h(int x){ return x + 0.5; }

int main(){
    cout << h(3);
}
A. 输出 3
 B. 输出 3.5
 C. 编译通过但运行时二义性
 D. 编译错误：无法仅以返回值重载
 E. 编译错误：main 里调用非法
答案：D
解析： C++ 不能只靠返回值区分重载，参数列表需不同[ref:2,5]。

---
1.5 参数个数不同
#include <iostream>
using namespace std;

int add(int a,int b){ return a+b; }
int add(int a,int b,int c){ return a+b+c; }

int main(){ cout << add(1,2) << " " << add(1,2,3); }
A. 3 6
 B. 6 3
 C. 3 5
 D. 5 6
 E. 编译二义性
答案：A
解析： 参数个数不同可重载，分别调用对应版本[ref:7,5]。

---
1.6 嵌套调用：返回值作实参
#include <iostream>
using namespace std;

int inc(int x){ return x+1; }
int mul(int a,int b){ return a*b; }

int main(){
    cout << mul(inc(2), inc(3));
}
A. 9  B. 12  C. 16  D. 20  E. 24
答案：B
解析： inc(2)=3,inc(3)=4，乘积 12[ref:2,5]。

---
1.7 嵌套调用与可读性
#include <iostream>
using namespace std;

int a(){ cout<<"A"; return 1; }
int b(){ cout<<"B"; return 2; }
int add(int x,int y){ return x+y; }

int main(){
    cout << add(a(), b());
}
A. AB3  B. BA3  C. AB12  D. BA12  E. 输出顺序不确定
答案：E
解析： 函数实参求值顺序在标准中可能不保证固定（不同标准/实现差异），但结果数值为 3[ref:2,5]。

---
1.8 静态局部变量（只初始化一次）
#include <iostream>
using namespace std;

int foo(){
    static int x = 0;
    return ++x;
}
int main(){
    cout << foo() << foo() << foo();
}
A. 000  B. 111  C. 123  D. 321  E. 234
答案：C
解析： static 局部变量生命周期贯穿程序，仅初始化一次，连续累加[ref:2,5]。

---
1.9 非静态局部变量（每次重建）
#include <iostream>
using namespace std;

int foo(){
    int x = 0;
    return ++x;
}
int main(){
    cout << foo() << foo() << foo();
}
A. 123  B. 111  C. 000  D. 321  E. 222
答案：B
解析： 每次调用 x 都重新创建并初始化为 0[ref:2,5]。

---
1.10 一维数组访问
#include <iostream>
using namespace std;

int main(){
    int a[5] = {1,2,3};
    cout << a[3] << a[4];
}
A. 00  B. 30  C. 03  D. 12  E. 未定义
答案：A
解析： 部分初始化，剩余元素自动置 0（同一声明中显式初始化）[ref:2,5]。

---
1.11 自动存储期未初始化
#include <iostream>
using namespace std;

int main(){
    int a[3];
    cout << a[0];
}
A. 一定是 0
 B. 一定是 1
 C. 一定是 -1
 D. 未定义值（不确定）
 E. 编译错误
答案：D
解析： 自动存储期的未初始化局部变量/数组元素值不确定。

---
1.12 数组名退化为指针（读输出）
#include <iostream>
using namespace std;

int main(){
    int a[3]={10,20,30};
    int* p=a;
    cout << *(p+1);
}
A. 10  B. 20  C. 30  D. 地址值  E. 未定义
答案：B
解析： p+1 指向 a[1]，解引用为 20[ref:2,5]。

---
1.13 下标与指针等价
#include <iostream>
using namespace std;

int main(){
    int a[4]={5,6,7,8};
    int* p=a;
    cout << p[2];
}
A. 5  B. 6  C. 7  D. 8  E. 编译错误
答案：C
解析： p[i] 等价 *(p+i)[ref:2,5]。

---
1.14 越界访问
#include <iostream>
using namespace std;

int main(){
    int a[2]={1,2};
    cout << a[2];
}
A. 0  B. 1  C. 2  D. 3  E. 未定义行为
答案：E
解析： 越界访问导致未定义行为[ref:2,5]。

---
1.15 二维数组内存按行连续
#include <iostream>
using namespace std;

int main(){
    int a[2][3]={{1,2,3},{4,5,6}};
    cout << *(*(a+1)+2);
}
A. 3  B. 4  C. 5  D. 6  E. 未定义
答案：D
解析： a+1 指向第 2 行，+2 到该行第 3 列元素。

---
1.16 二维数组部分初始化的默认值
#include <iostream>
using namespace std;

int main(){
    int a[2][3]={{1},{4,5}};
    cout << a[0][2] << a[1][2];
}
A. 15  B. 10  C. 00  D. 05  E. 未定义
答案：C
解析： 同一声明中部分初始化，其余元素补 0[ref:2,5]。

---
1.17 行指针类型
#include <iostream>
using namespace std;

int main(){
    int a[2][3]={{1,2,3},{4,5,6}};
    int (*p)[3] = a;
    cout << p[1][0];
}
A. 1  B. 2  C. 3  D. 4  E. 编译错误
答案：D
解析： p 是指向“含 3 个 int 的数组”的指针，p[1] 为第 2 行。

---
1.19 通过指针修改外部变量
#include <iostream>
using namespace std;

void setv(int* p){ *p = 9; }

int main(){
    int x=1;
    setv(&x);
    cout << x;
}
A. 1  B. 9  C. 0  D. 未定义  E. 编译错误
答案：B
解析： 传入地址，函数内解引用修改原变量[ref:2,5]。

---

---
1.21 string 拼接
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s="ab";
    s += "cd";
    cout << s;
}
A. ab  B. cd  C. abcd  D. 编译错误  E. 未定义
答案：C
解析： std::string 支持 += 追加拼接[ref:2,5]。

---
1.23 substring 越界参数
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s="abcd";
    cout << s.substr(2, 10);
}
A. cd  B. c  C. 空  D. 抛异常  E. 编译错误
答案：A
解析： substr(pos,len) 会截到字符串末尾（pos 合法时）[ref:2,5]。

---
1.27 find 未找到
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s="abcd";
    cout << (s.find("e")==string::npos);
}
A. 0  B. 1  C. -1  D. npos  E. 编译错误
答案：B
解析： 未找到返回 string::npos，比较为真输出 1。

---
1.28 从指定位置查找
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s="ababa";
    cout << s.find("ba", 2);
}
A. 1  B. 2  C. 3  D. 4  E. npos
答案：C
解析： 从下标 2 开始找，"ba" 出现在位置 3[ref:2,5]。

---
1.29 反向查找 rfind
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s="ababa";
    cout << s.rfind("aba");
}
A. 0  B. 1  C. 2  D. 3  E. npos
答案：C
解析： 最后一次出现 "aba" 起点为 2[ref:2,5]。

---
1.30 rand 区间映射（概念结果）
int x = rand() % 6 + 1;
x 的可能范围是：
 A. [0,6]  B. [1,6]  C. [1,7]  D. [0,5]  E. 不确定
答案：B
解析： rand()%6 得 0..5，加 1 得 1..6（均匀性仍可能受取模影响。

---
1.31 srand 作用
#include <iostream>
#include <cstdlib>
using namespace std;

int main(){
    srand(1);
    cout << rand() << " " << rand();
}
A. 每次运行都不同
 B. 每次运行相同序列
 C. rand() 恒为 1
 D. 编译错误
 E. 未定义
答案：B
解析： 固定种子会产生可复现的伪随机序列[ref:10,1]。

---
1.33 a>b 的区间映射（读输出）
#include <iostream>
using namespace std;

int main(){
    int a=10,b=3;
    if(a>b){ int t=a; a=b; b=t; }
    cout << a << " " << b;
}
A. 10 3  B. 3 10  C. 13  D. 7  E. 未定义
答案：B
解析： 交换确保区间端点有序，便于生成 [a,b][ref:10,1]。

---
1.34 指针算术与输出
#include <iostream>
using namespace std;

int main(){
    int a[]={1,4,9,16};
    int* p=a+3;
    cout << *(p-2);
}
A. 1  B. 4  C. 9  D. 16  E. 未定义
答案：C
解析： p 指向 a[3]，p-2 指向 a[1]？等等：3-2=1，是 4。应选 B。
答案：B
解析： *(a+1)=4[ref:2,5]。

---
1.35 指针修改数组元素
#include <iostream>
using namespace std;

int main(){
    int a[3]={1,2,3};
    int* p=a;
    *(p+1)=9;
    cout << a[1];
}
A. 2  B. 3  C. 9  D. 未定义  E. 编译错误
答案：C
解析： 指针指向数组，修改第二个元素[ref:2,5]。

---
1.37 二维数组传参：列数必须固定
#include <iostream>
using namespace std;

void print(int a[][]){ cout << a[0][0]; }

int main(){
    int x[2][3]={{1,2,3},{4,5,6}};
    print(x);
}
A. 输出 1
 B. 输出 4
 C. 编译错误
 D. 运行错误
 E. 未定义
答案：C
解析： 形参二维数组必须给出第二维（列数）以确定寻址[ref:2,5]。

---
1.39 正确的行指针形参
#include <iostream>
using namespace std;

void print(int (*a)[3]){ cout << a[1][2]; }

int main(){
    int x[2][3]={{1,2,3},{4,5,6}};
    print(x);
}
A. 3  B. 4  C. 5  D. 6  E. 编译错误
答案：D
解析： 访问第 2 行第 3 列元素 6[ref:2,5]。

---
1.41 string 内容比较
#include <iostream>
#include <string>
using namespace std;

int main(){
    string a="hi", b="hi";
    cout << (a==b);
}
A. 0  B. 1  C. hi  D. 编译错误  E. 未定义
答案：B
解析： std::string 的 == 比较内容。

---
1.42 getline 读取空格
#include <iostream>
#include <string>
using namespace std;

int main(){
    string s;
    getline(cin,s);
    cout << s.size();
}
输入：a b
 A. 1  B. 2  C. 3  D. 4  E. 5
答案：C
解析： 包含空格整行读取，"a␠b" 长度 3[ref:2,5]。

---
1.43 递归：缺少终止条件
#include <iostream>
using namespace std;

int f(int n){
    return f(n-1) + 1;
}
int main(){ cout << f(3); }
A. 3  B. 0  C. 4  D. 编译错误  E. 运行时无限递归/栈溢出
答案：E
解析： 无终止条件，递归不会停止，导致栈溢出[ref:2,5]。

---

---
1.45 数组遍历边界
#include <iostream>
using namespace std;

int main(){
    int a[3]={1,2,3};
    for(int i=0;i<=3;i++) cout<<a[i];
}
A. 123  B. 1230  C. 1233  D. 未定义行为  E. 编译错误
答案：D
解析： i==3 时越界访问[ref:2,5]。

---
1.49 嵌套调用与重载（返回类型匹配）
#include <iostream>
using namespace std;

int t(double x){ return (int)(x*2); }
double t(int x){ return x/2.0; }

int main(){
    cout << t(t(3));
}
A. 1  B. 2  C. 3  D. 6  E. 12
答案：B
解析： 内层 t(3) 选 double t(int) 得 1.5；外层 t(1.5) 选 int t(double) 得 3，但输出为 3？选项 C。重新算：(int)(1.5*2)=(int)3.0=3，应选 C。
答案：C
解析： 嵌套时关注返回类型触发的重载选择[ref:2,5]。

---
二、编程题（10 题，给出题目要求；可按需再要参考答案）
1. 数组逆序输出（无尾随空格）：输入 n 与 n 个整数，按逆序输出，元素间空格分隔，末尾无多余空格[ref:2,5]。
2. 二维数组行列输出格式：输入 r,c 与矩阵，按原矩阵输出，每行元素空格分隔、行末换行[ref:2,5]。
3. 统计大小写与转换：输入一行字符串，统计大写/小写个数，并输出转换后字符串（大写转小写、小写转大写）[ref:2,5]。
4. 模板函数：交换与最大值：实现 swapT(T&,T&) 与 maxT(T,T)，并用 int/double/string 各测试一次[ref:2,5]。
5. 顺序查找第一次出现位置：输入 n、数组与目标 x，输出第一次出现下标；不存在输出 -1[ref:2,5]。
6. 字符串查找最后一次出现：输入一行 s 与模式 p，输出 p 在 s 中最后一次出现位置；没有输出 -1[ref:2,5]。
7. 生成闭区间随机数并格式输出：输入 a,b,k（允许 a>b），生成 k 个 [a,b] 随机整数，空格分隔、末尾无空格；要求用时间种子[ref:10,1]。
8. 求和/均值/最大最小：输入 n 和 n 个数，输出 sum、avg（保留 2 位）、max、min[ref:2,5]。
9. 质数判断与计数：输入 n，输出 1..n 中质数个数；要求用 (\sqrt{n}) 优化[ref:2,5]。
10. 冒泡排序（含提前结束）：输入 n 与数组，升序冒泡排序，若某一趟无交换则提前结束；输出排序后数组
下面把 10 道编程题都写成标准输入输出 + 参考代码 + 解释。代码只用基础语法与基础头文件（主要 iostream，第 7 题用 cstdlib/ctime，第 9 题用 cmath）[ref:1,2,10]。

---
2. 数组逆序输出（无尾随空格）[ref:1,2]
输入：
 第一行 n（1 ≤ n ≤ 100000）
 第二行 n 个整数
输出：
 按逆序输出这 n 个整数，元素间一个空格分隔，末尾不加空格，最后换行。
参考代码：
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    int* a = new int[n];
    for (int i = 0; i < n; i++) cin >> a[i];

    for (int i = n - 1; i >= 0; i--) {
        if (i != n - 1) cout << ' ';
        cout << a[i];
    }
    cout << '\n';

    delete[] a;
    return 0;
}
解释：
 先读入数组，再从 n-1 到 0 逆序输出；用 if (i != n-1) 控制空格避免尾随空格[ref:1,2]。

---
2. 二维数组原样输出（格式控制）[ref:1,2]
输入：
 r c（1 ≤ r,c ≤ 500）
 接着 r 行，每行 c 个整数
输出：
 按矩阵原样输出：每行 c 个数，数之间一个空格，行末换行。
参考代码：
#include <iostream>
using namespace std;

int main() {
    int r, c;
    cin >> r >> c;

    int* a = new int[r * c];
    for (int i = 0; i < r; i++) {
        for (int j = 0; j < c; j++) {
            cin >> a[i * c + j];
        }
    }

    for (int i = 0; i < r; i++) {
        for (int j = 0; j < c; j++) {
            if (j) cout << ' ';
            cout << a[i * c + j];
        }
        cout << '\n';
    }

    delete[] a;
    return 0;
}
解释：
 用一维数组模拟二维（行优先连续存储），元素位置是 i*c + j；每行用 if(j) 控空格[ref:1,2]。

---
3. 统计大小写并互换大小写（读整行）[ref:1,2]
输入：
 一行字符串（可包含空格）
输出：
 第一行：大写字母个数 小写字母个数
 第二行：将所有字母互换大小写后的整行
参考代码：
#include <iostream>
using namespace std;

int main() {
    const int MAXN = 10005;
    char s[MAXN];

    cin.getline(s, MAXN);

    int upper = 0, lower = 0;
    for (int i = 0; s[i] != '\0'; i++) {
        if (s[i] >= 'A' && s[i] <= 'Z') upper++;
        else if (s[i] >= 'a' && s[i] <= 'z') lower++;
    }

    cout << upper << ' ' << lower << '\n';

    for (int i = 0; s[i] != '\0'; i++) {
        if (s[i] >= 'A' && s[i] <= 'Z') s[i] = char(s[i] - 'A' + 'a');
        else if (s[i] >= 'a' && s[i] <= 'z') s[i] = char(s[i] - 'a' + 'A');
    }
    cout << s << '\n';
    return 0;
}
解释：
 用 ASCII 范围判断大写/小写；大小写转换用字符码差值实现；getline 读整行含空格[ref:1,2]。

---
4. 模板函数：交换与最大值（测试 int/double/字符串）[ref:1,2]
输入：
 无
输出：
 按程序内置测试打印结果（见代码）。
参考代码：
#include <iostream>
using namespace std;

template <typename T>
void swapT(T& a, T& b) {
    T t = a;
    a = b;
    b = t;
}

template <typename T>
T maxT(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    int a = 3, b = 7;
    swapT(a, b);
    cout << a << ' ' << b << '\n';      // 7 3
    cout << maxT(a, b) << '\n';         // 7

    double x = 2.5, y = 2.25;
    swapT(x, y);
    cout << x << ' ' << y << '\n';      // 2.25 2.5
    cout << maxT(x, y) << '\n';         // 2.5

    // 用基础字符数组模拟“字符串”比较/交换（不使用 std::string）
    char s1[100] = "abc";
    char s2[100] = "ab";
    // 仅演示：用 maxT 需要支持 '>'，对 char[] 不适用，所以这里不调用 maxT
    // 交换：逐字符交换（等长上限）
    for (int i = 0; i < 100; i++) { char t = s1[i]; s1[i] = s2[i]; s2[i] = t; }
    cout << s1 << '\n' << s2 << '\n';

    return 0;
}
解释：
 模板让同一逻辑适配多类型；char[] 不是可直接用 > 比较的“字符串对象”，因此只演示了固定容量的字符数组交换（逐字节交换）[ref:1,2]。

---
5. 顺序查找第一次出现位置[ref:1,2]
输入：
 n
 n 个整数
 x
输出：
 x 第一次出现的下标（0 开始），不存在输出 -1。
参考代码：
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    int* a = new int[n];
    for (int i = 0; i < n; i++) cin >> a[i];
    int x;
    cin >> x;

    int pos = -1;
    for (int i = 0; i < n; i++) {
        if (a[i] == x) { pos = i; break; }
    }
    cout << pos << '\n';

    delete[] a;
    return 0;
}
解释：
 从头到尾线性扫描，第一次匹配就 break；没找到保持 -1[ref:1,2]。

---
6. 字符串中模式最后一次出现位置（不使用 string/find）[ref:1,2]
输入：
 第一行：字符串 s（可含空格）
 第二行：模式 p（可含空格）
输出：
 p 在 s 中最后一次出现的起始下标（0 开始），没有输出 -1。
参考代码：
#include <iostream>
using namespace std;

int myLen(const char* s) {
    int n = 0;
    while (s[n] != '\0') n++;
    return n;
}

int main() {
    const int MAXN = 10005;
    char s[MAXN], p[MAXN];
    cin.getline(s, MAXN);
    cin.getline(p, MAXN);

    int ns = myLen(s), np = myLen(p);
    if (np == 0) { // 约定：空模式匹配在末尾之前的最后位置，这里输出 ns
        cout << ns << '\n';
        return 0;
    }
    if (np > ns) {
        cout << -1 << '\n';
        return 0;
    }

    int ans = -1;
    for (int i = 0; i + np <= ns; i++) {
        int j = 0;
        while (j < np && s[i + j] == p[j]) j++;
        if (j == np) ans = i; // 记录最后一次
    }
    cout << ans << '\n';
    return 0;
}
解释：
 用朴素匹配：对每个起点 i 比较 p；每次匹配成功就更新 ans，最终就是最后一次位置[ref:1,2]。

---
7. 生成闭区间随机数并输出（允许 a>b）[ref:10,1]
输入：
 a b k
输出：
 k 个随机整数，落在闭区间 [min(a,b), max(a,b)]，空格分隔，末尾无空格，最后换行。
参考代码：
#include <iostream>
#include <cstdlib>
#include <ctime>
using namespace std;

int main() {
    int a, b, k;
    cin >> a >> b >> k;
    if (a > b) { int t = a; a = b; b = t; }

    srand((unsigned)time(0));

    int range = b - a + 1;
    for (int i = 0; i < k; i++) {
        int x = a + rand() % range;
        if (i) cout << ' ';
        cout << x;
    }
    cout << '\n';
    return 0;
}
解释：
 先保证 a≤b；用 a + rand()%range 映射到闭区间；srand(time(0)) 让每次运行序列通常不同（取模可能有轻微偏差，但满足基础题）[ref:10,1]。

---
8. 求和/均值/最大最小[ref:1,2]
输入：
 n
 n 个整数
输出：
 sum avg max min
 其中 avg 保留 2 位小数。
参考代码：
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    int n;
    cin >> n;

    long long sum = 0;
    int x;
    cin >> x;
    int mx = x, mn = x;
    sum += x;

    for (int i = 1; i < n; i++) {
        cin >> x;
        sum += x;
        if (x > mx) mx = x;
        if (x < mn) mn = x;
    }

    double avg = (double)sum / n;
    cout << sum << ' ' << fixed << setprecision(2) << avg << ' ' << mx << ' ' << mn << '\n';
    return 0;
}
解释：
sum 用 long long 防溢出；首个数用于初始化 max/min；均值用浮点除法并格式化输出两位小数[ref:1,2]。

---
9. 统计 1..n 中质数个数（(\sqrt{n}) 优化）[ref:1,2]
输入：
 n（n ≥ 1）
输出：
 1..n 中质数个数
参考代码：
#include <iostream>
#include <cmath>
using namespace std;

bool isPrime(int x) {
    if (x < 2) return false;
    if (x == 2) return true;
    if (x % 2 == 0) return false;
    int r = (int)sqrt((double)x);
    for (int i = 3; i <= r; i += 2) {
        if (x % i == 0) return false;
    }
    return true;
}

int main() {
    int n;
    cin >> n;

    int cnt = 0;
    for (int i = 1; i <= n; i++) {
        if (isPrime(i)) cnt++;
    }
    cout << cnt << '\n';
    return 0;
}
解释：
 质数判定：小于 2 不是质数；偶数快速排除；只试除到 (\sqrt{x})，并只检查奇数因子降低复杂度[ref:1,2]。

---
10. 冒泡排序（含提前结束）[ref:1,2]
输入：
 n
 n 个整数
输出：
 升序排列后的数组，空格分隔，末尾无空格，最后换行。
参考代码：
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    int* a = new int[n];
    for (int i = 0; i < n; i++) cin >> a[i];

    for (int pass = 0; pass < n - 1; pass++) {
        bool swapped = false;
        for (int i = 0; i < n - 1 - pass; i++) {
            if (a[i] > a[i + 1]) {
                int t = a[i];
                a[i] = a[i + 1];
                a[i + 1] = t;
                swapped = true;
            }
        }
        if (!swapped) break;
    }

    for (int i = 0; i < n; i++) {
        if (i) cout << ' ';
        cout << a[i];
    }
    cout << '\n';

    delete[] a;
    return 0;
}
解释：
 每一趟把当前最大值“冒”到末尾；若某一趟无交换说明已有序，提前结束节省时间[ref:1,2]。

---


好的，收到。根据您的要求，我将把50道选择题全部设计为代码阅读理解题（分析输出结果、编译情况或运行行为），并附上10道编程题。内容涵盖您指定的C++知识点。

---
C++ 专项练习题集
第一部分：选择题（50道，代码阅读类）
每题均为五选一，请分析代码段的行为或输出。
A. 函数与调用 (递归、重载、嵌套)
1. 阅读以下代码，输出结果是？
C++
void f(int x) { cout << "INT"; }
void f(double x) { cout << "DBL"; }
int main() {
    f(5);
    f(5.0);
    return 0;
}
A. INT INT
B. DBL DBL
C. INT DBL
D. DBL INT
E. 编译错误
答案：C
解析： 函数重载。5 是 int 字面量匹配第一个，5.0 是 double 字面量匹配第二个。
2. 阅读以下递归代码，输出结果是？
C++
int func(int n) {
    if (n == 0) return 0;
    return n + func(n - 1);
}
int main() { cout << func(5); }
A. 10
B. 15
C. 5
D. 0
E. 120
答案：B
解析： 计算 $5+4+3+2+1+0 = 15$。
3. 阅读以下代码，分析输出：
C++
int x = 1;
int func(int a) { return a + x; }
int main() {
    int x = 5;
    cout << func(x);
}
A. 2
B. 6
C. 10
D. 5
E. 1
答案：B
解析： main 中的局部变量 x 为5，作为参数传给 func 的形参 a。func 内部使用的全局变量 x 为1。返回 $5+1=6$。
4. 如下代码的运行结果是？
C++
void foo(int n) {
    if (n > 0) {
        foo(n - 1);
        cout << n << " ";
    }
}
int main() { foo(3); }
A. 3 2 1
B. 1 2 3
C. 3 2 1 0
D. 0 1 2 3
E. 死循环
答案：B
解析： 递归调用在 cout 之前，因此先深入到最底层 n=0（不输出），回溯时依次输出 1, 2, 3。
5. 关于函数重载的匹配，以下代码会发生什么？
C++
void t(int a, float b) {}
void t(float a, int b) {}
int main() {
    t(10, 10);
}
A. 调用第一个
B. 调用第二个
C. 编译错误（二义性）
D. 运行时崩溃
E. 随机调用
答案：C
解析： 两个参数都是 int，两个重载版本都需要进行一次隐式类型转换，编译器无法判断哪个更优，报二义性错误。
6. 阅读嵌套调用代码：
C++
int sq(int x) { return x * x; }
int add(int a, int b) { return a + b; }
int main() {
    cout << sq(add(2, 3));
}
A. 13
B. 25
C. 10
D. 5
E. 36
答案：B
解析： 先计算 add(2,3) 得到 5，再计算 sq(5) 得到 25。
7. 若函数定义如下，main 中的调用结果是？
C++
int f(int n) {
    return (n <= 1) ? 1 : n * f(n-1);
}
int main() { cout << f(4); }
A. 10
B. 24
C. 12
D. 4
E. 1
答案：B
解析： 计算阶乘 $4! = 4 \times 3 \times 2 \times 1 = 24$。
B. 随机数
8. 假设 rand() 最大值为 32767，以下代码输出值的范围？
C++
cout << rand() % 20 + 10;
A. [0, 19]
B. [10, 30]
C. [10, 29]
D. [10, 20]
E. [11, 30]
答案：C
解析： rand() % 20 范围是 $[0, 19]$，加上 10 后范围是 $[10, 29]$。
9. 连续运行两次以下程序的输出结果是？
C++
int main() {
    srand(1);
    cout << rand();
}
A. 两次输出不同的随机数
B. 两次输出相同的数
C. 第一次输出0，第二次输出1
D. 编译错误
E. 无法确定
答案：B
解析： 种子固定为 1，每次运行程序生成的伪随机序列相同。
10. 阅读代码，分析 x 的可能值：
C++
int x = rand() % 5;
if (x == 5) cout << "Yes";
else cout << "No";
A. 一定输出 Yes
B. 一定输出 No
C. 可能输出 Yes
D. 编译错误
E. 运行时错误
答案：B
解析： % 5 的结果范围是 $[0, 4]$，永远不可能是 5。
C. 变量存储期与生命周期
11. 如下代码输出什么？
C++
void f() {
    static int i = 0;
    cout << ++i << " ";
}
int main() { f(); f(); f(); }
A. 1 1 1
B. 0 0 0
C. 1 2 3
D. 0 1 2
E. 编译错误
答案：C
解析： static 局部变量只初始化一次，后续调用会保留上次的值。
12. 阅读代码，输出结果是？
C++
int a = 10;
int main() {
    int a = 20;
    {
        int a = 30;
        cout << a << " ";
    }
    cout << a;
}
A. 10 10
B. 30 30
C. 30 20
D. 20 20
E. 30 10
答案：C
解析： 块作用域遮蔽。最内层 {} 输出 30，退出内层块后，main 的局部变量 a (20) 恢复可见。
13. 关于静态变量的默认值，以下代码输出？
C++
static int arr[5];
int main() { cout << arr[0]; }
A. 0
B. 垃圾值
C. 编译错误
D. null
E. 1
答案：A
解析： 静态存储期的变量（全局或静态局部）若未显式初始化，编译器自动将其初始化为 0。
14. 以下代码中，变量 y 的生命周期何时结束？
C++
void func() {
    int y = 10; 
    cout << y;
}
A. 程序结束时
B. main 函数结束时
C. func 函数被调用时
D. func 函数返回时
E. 文件关闭时
答案：D
解析： y 是自动变量（栈变量），函数执行完毕弹栈销毁。
D. 数组（默认值 + 访问）
15. 阅读代码，输出结果是？
C++
int a[5] = {1, 2};
cout << a[3];
A. 1
B. 2
C. 0
D. 垃圾值
E. 编译错误
答案：C
解析： 聚合初始化部分元素后，其余元素自动补零。
16. 以下代码会发生什么？
C++
int arr[] = {1, 2, 3};
cout << sizeof(arr) / sizeof(int);
A. 1
B. 3
C. 4
D. 8
E. 编译错误
答案：B
解析： 计算数组元素个数。数组总大小(12) / 单个int大小(4) = 3。
17. 阅读代码，输出是什么？
C++
int a[3][2] = {{1, 2}, {3, 4}, {5, 6}};
cout << a[1][1];
A. 2
B. 3
C. 4
D. 5
E. 6
答案：C
解析： 索引从0开始。a[1] 是第二行 {3, 4}，a[1][1] 是该行第二个元素 4。
18. 如下代码中 p 指向哪里？
C++
int a[4] = {10, 20, 30, 40};
int *p = a + 2;
cout << *p;
A. 10
B. 20
C. 30
D. 40
E. 编译错误
答案：C
解析： 数组名 a 是首地址，+2 偏移两个 int 大小，指向 30。
19. 阅读代码，分析输出：
C++
int arr[5];
// 假设 arr 内存地址是 1000 (十进制), int 占 4 字节// cout << arr + 1; 输出多少？
A. 1001
B. 1004
C. 1000
D. 1005
E. 1008
答案：B
解析： 指针算术运算单位是元素类型的大小。1000 + 1 * 4 = 1004。
20. 二维数组访问，代码如下：
C++
int m[2][3] = {1, 2, 3, 4, 5, 6};
cout << m[0][3]; 
A. 3
B. 4
C. 0
D. 编译错误
E. 尽管越界，但通常输出4（取决于内存布局）
答案：E
解析： 这是一个典型的数组越界（Undefined Behavior）。但在连续内存布局中，m[0][3] 越过了第一行的末尾，恰好访问到了第二行的开头 4。虽然结果通常是4，但这是不安全代码。
21. 未初始化的局部数组：
C++
int main() {
    int arr[5];
    cout << arr[0];
}
A. 0
B. 1
C. 随机值（垃圾值）
D. null
E. 编译错误
答案：C
解析： 局部变量未初始化，内容未定义。
22. 遍历数组的逻辑：
C++
int a[] = {1, 2, 3};
for(int i=0; i<=3; i++) cout << a[i];
A. 123
B. 1230
C. 123 + 垃圾值
D. 编译错误
E. 死循环
答案：C
解析： 循环条件 i<=3 导致访问下标 0, 1, 2, 3。下标 3 越界，输出未定义值。
23. 二维数组部分初始化：
C++
int a[2][2] = {{1}, {2}};
cout << a[0][1] << a[1][1];
A. 1 2
B. 0 0
C. 垃圾值 垃圾值
D. 1 0
E. 0 2
答案：B
解析： 每行只初始化了第一个元素，每行剩余元素补0。
E. 字符串（string & char[]）
24. 阅读代码：
C++
string s = "123";
s += '4';
cout << s;
A. 123
B. 7 (数值相加)
C. 1234
D. 编译错误
E. 127
答案：C
解析： string 重载了 +=，支持字符追加。
26. cin 读取行为：
C++
string s;
// 输入: Hello World
cin >> s;
cout << s;
A. Hello World
B. Hello
C. World
D. Hello\n
E. 编译错误
答案：B
解析： cin 遇空格停止。
28. string 子串操作：
C++
string s = "ABCDEF";
cout << s.substr(2, 2);
A. AB
B. BC
C. CD
D. CDE
E. DE
答案：C
解析： 从索引2 ('C') 开始，截取长度2，得到 "CD"。
25. 查找子串：
C++
string s = "banana";
cout << s.find("na");
A. 1
B. 2
C. 3
D. 4
E. 0
答案：B
解析： 第一次出现 "na" 是在索引 2。
26. 字符串比较：
C++
string s1 = "apple";
string s2 = "banana";
cout << (s1 > s2);
A. 1
B. 0
C. true
D. 编译错误
E. -1
答案：B
解析： 字典序比较，'a' 小于 'b'，所以 s1 > s2 为假（0）。
31. getline 混合使用：
C++
int n; string s;
// 输入:// 10// Hellocin >> n;
getline(cin, s);
cout << s.length();
A. 5
B. 0
C. 1
D. 10
E. 6
答案：B
解析： cin >> n 留下换行符，getline 读到换行符立即结束，读入空串，长度0。
33. string 修改：
C++
string s = "Top";
s[0] = 'P';
cout << s;
A. Pop
B. Top
C. pop
D. 编译错误
E. P
答案：A
解析： 字符串可变，直接修改索引0。
27. 字符拼接：
C++
// string s = "A" + "B"; // 这样写会如何？
A. s为 "AB"
B. 编译错误
C. s为 "BA"
D. 运行时错误
E. s为数字求和
答案：B
解析： 两个C风格字符串字面量不能直接相加。必须至少有一个是 std::string 对象。
28. 访问字符串最后一位：
C++
string s = "Code";
cout << s[s.size() - 1];
A. d
B. e
C. \0
D. 越界
E. o
答案：B
解析： 长度为4，最后一位下标是3，即 'e'。
F. 指针（修改变量、与数组/二维数组关系）
29. 指针基本操作：
C++
int a = 50;
int *p = &a;
*p = 20;
cout << a;
A. 50
B. 20
C. 编译错误
D. 随机值
E. 地址值
答案：B
解析： 通过指针解引用修改了原变量的值。
30. 指针与数组关系：
C++
int a[] = {1, 2, 3};
int *p = a;
cout << *(p + 1);
A. 1
B. 2
C. 3
D. a[0]的地址
E. 编译错误
答案：B
解析： p 指向 1，p+1 指向 2，解引用得到 2。
31. 指针自增操作：
C++
int a[] = {10, 20};
int *p = a;
cout << *p++; 
A. 11
B. 20
C. 10
D. 21
E. 编译错误
答案：C
解析： *p++ 相当于 *(p++)。先取 *p 的值（10），然后指针 p 自增指向下一个元素。输出的是自增前的值。
32. 空指针解引用：
C++
int *p = nullptr;
// cout << *p; // 运行这行会发生什么？
A. 输出 0
B. 输出 null
C. 运行时崩溃 (Segfault)
D. 编译错误
E. 输出随机值
答案：C
解析： 访问非法内存。
33. 指针比较：
C++
int a[5];
int *p1 = &a[1];
int *p2 = &a[3];
cout << (p2 > p1);
A. 0
B. 1
C. false
D. 编译错误
E. 无法确定
答案：B
解析： 同一数组中，高下标元素的地址大于低下标元素的地址。
34. 指针减法：
C++
int a[] = {1, 2, 3, 4, 5};
int *p1 = a;
int *p2 = a + 4;
cout << p2 - p1;
A. 16
B. 4
C. 3
D. 5
E. 编译错误
答案：B
解析： 指针相减返回的是两个指针之间的元素个数，不是字节数。
35. 常量指针：
C++
int a = 10;
const int *p = &a;
// *p = 20; // 这行会怎样？
A. a 变成 20
B. p 变成指向20
C. 编译错误
D. 运行时错误
E. 无效操作但无报错
答案：C
解析： const int * 表示指针指向的内容不可通过该指针修改。
36. 引用与指针区别：
C++
int a = 10;
int &r = a;
r = 20;
cout << a;
A. 10
B. 20
C. 30
D. 编译错误
E. 地址
答案：B
解析： 引用是别名，修改引用即修改原变量。
37. 数组名作函数参数的退化：
C++
void f(int a[100]) {
    // 这里的 a 是什么类型？
}
A. int 数组，大小100
B. int*
C. const int*
D. int&
E. int
答案：B
解析： 函数参数中的数组声明自动退化为指向首元素的指针。

---
第二部分：编程题（10道）
说明： 请根据题目要求编写C++代码。
1. 数组求和与平均值 (基础数值运算)
题目： 输入一个整数 $n$ ($1 \le n \le 100$) 和 $n$ 个整数，计算并输出这些数的总和与平均值（平均值保留一位小数或直接输出浮点数）。
解析：
1. 定义 sum 为 double 或 long long 防止溢出。
2. 循环累加。
3. 平均值为 sum / n，注意隐式类型转换。
C++
#include <iostream>using namespace std;
int main() {
    int n;
    double sum = 0;
    cin >> n;
    int val;
    for(int i=0; i<n; i++) {
        cin >> val;
        sum += val;
    }
    cout << "Sum: " << sum << endl;
    cout << "Avg: " << sum / n << endl;
    return 0;
}
2. 查找特定元素 (线性搜索)
题目： 定义一个包含10个整数的数组 {12, 45, 23, 6, 78, 90, 34, 11, 5, 67}。输入一个数，判断该数是否存在于数组中。若存在，输出其下标（第一次出现）；若不存在，输出 -1。
解析： 遍历数组，比较每个元素。使用标志位或直接 return / break。
C++
#include <iostream>using namespace std;
int main() {
    int arr[10] = {12, 45, 23, 6, 78, 90, 34, 11, 5, 67};
    int target, pos = -1;
    cin >> target;
    for(int i=0; i<10; i++) {
        if(arr[i] == target) {
            pos = i;
            break;
        }
    }
    cout << pos << endl;
    return 0;
}
3. 统计字符串中的数字个数 (字符判断)
题目： 输入一行包含空格的字符串，统计其中数字字符 ('0'-'9') 的个数并输出。
解析： 使用 getline 读取整行，isdigit() 函数或 c >= '0' && c <= '9' 判断。
C++
#include <iostream>#include <string>using namespace std;
int main() {
    string s;
    getline(cin, s);
    int count = 0;
    for(char c : s) {
        if(c >= '0' && c <= '9') {
            count++;
        }
    }
    cout << count << endl;
    return 0;
}
4. 冒泡排序 (排序)
题目： 输入5个整数，使用冒泡排序将其从小到大排序后输出。
解析： 双层循环，外层控制轮数，内层比较相邻元素。
C++
#include <iostream>using namespace std;
int main() {
    int a[5];
    for(int i=0; i<5; i++) cin >> a[i];
    
    for(int i=0; i<4; i++) { // 轮数for(int j=0; j<4-i; j++) { // 比较次数if(a[j] > a[j+1]) {
                int temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
            }
        }
    }
    
    for(int i=0; i<5; i++) cout << a[i] << " ";
    return 0;
}
5. 质数判断 (数学判断)
题目： 输入一个整数 $n$，编写函数 bool isPrime(int n) 判断其是否为质数。如果是输出 "Yes"，否则输出 "No"。
解析： 排除 $\le 1$ 的数。循环从 2 到 $\sqrt{n}$，若能整除则不是质数。
C++
#include <iostream>using namespace std;
bool isPrime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) return false;
    }
    return true;
}
int main() {
    int n;
    cin >> n;
    if (isPrime(n)) cout << "Yes";
    else cout << "No";
    return 0;
}
6. 随机生成不重复的数 (随机数与数组)
题目： 生成 5 个 $[1, 10]$ 之间的随机整数。（简化版：允许重复） 如果要求不重复，需要检查已生成的数。这里请写出允许重复的版本即可，要求设定时间种子。
解析： srand(time(0))，rand() % 10 + 1。
C++
#include <iostream>#include <cstdlib>#include <ctime>using namespace std;
int main() {
    srand(time(0));
    for(int i=0; i<5; i++) {
        cout << (rand() % 10 + 1) << " ";
    }
    return 0;
}
7. 矩阵转置 (二维数组)
题目： 定义一个 2行3列 的数组并初始化，输出其转置矩阵（3行2列）。
解析： b[j][i] = a[i][j]。
C++
#include <iostream>using namespace std;
int main() {
    int a[2][3] = {{1, 2, 3}, {4, 5, 6}};
    for(int j=0; j<3; j++) {
        for(int i=0; i<2; i++) {
            cout << a[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
8. 字符串反转 (字符串操作)
题目： 输入一个字符串，不使用 reverse 库函数，利用双指针或循环将其反转并输出。
解析： left 指向头，right 指向尾，交换并向中间移动。
C++
#include <iostream>#include <string>using namespace std;
int main() {
    string s;
    cin >> s;
    int n = s.length();
    for(int i=0; i < n/2; i++) {
        char temp = s[i];
        s[i] = s[n-1-i];
        s[n-1-i] = temp;
    }
    cout << s << endl;
    return 0;
}
9. 模板函数实现数组打印 (模板)
题目： 编写一个模板函数 printArray，接收数组指针和长度，能够打印 int 数组或 double 数组。
解析： template <typename T> void printArray(T arr[], int n)。
C++
#include <iostream>using namespace std;
template <typename T>
void printArray(T arr[], int n) {
    for(int i=0; i<n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}
int main() {
    int a[] = {1, 2, 3};
    double b[] = {1.1, 2.2};
    printArray(a, 3);
    printArray(b, 2);
    return 0;
}
10. 递归求斐波那契数列 (函数与递归)
题目： 输入 $n$，输出斐波那契数列的第 $n$ 项。约定 $F(1)=1, F(2)=1$。
解析： $F(n) = F(n-1) + F(n-2)$。
C++
#include <iostream>using namespace std;
int fib(int n) {
    if (n <= 2) return 1;
    return fib(n-1) + fib(n-2);
}
int main() {
    int n;
    cin >> n;
    cout << fib(n);
    return 0;
}
