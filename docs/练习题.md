第一阶段：基础概念篇（规则与原理）

---
1. 隐式转换的一般原则
1. C++ 中，当不同类型的数据进行混合运算时，编译器会自动进行类型转换。这种转换通常遵循什么原则？
A. 向占用内存更小的方向转换，以节省空间。
 B. 向精度更高、范围更大的方向转换，以避免溢出和精度丢失。
 C. 全部转换为 int 类型。
 D. 全部转换为 double 类型。
 E. 不进行任何转换，直接报错。
答案：B
解析：
 隐式类型转换的核心原则是：宁可浪费一点空间，也要尽量少丢信息。
 所以会从“低精度 / 小范围”的类型往“高精度 / 大范围”的类型提升，比如 int 在和 double 混合时会先转为 double。

---
2. 在 C++ 的整型提升规则中，char 和 short 在参与算术运算前，通常会被提升为哪种类型？
A. long
 B. float
 C. int
 D. double
 E. unsigned int
答案：C
解析：
 这是 整型提升（Integral Promotion）：
char / short / bool 等小整数类型在表达式中会自动提升为 int 再参与运算。

---
3. 以下哪种写法属于 C++ 推荐的显式转换方式？
A. (int)3.14
 B. int(3.14)
 C. [int]3.14
 D. static_cast<int>(3.14)
 E. convert_to_int(3.14)
答案：D
解析：
- A / B 都是 C 风格或“函数风格”强制转换。
- C 语法错误。
- static_cast<类型>(表达式) 是 C++ 提供的 类型安全、更显眼 的转换方式，建议在教学和项目中使用。

---
4. 当我们将一个 double 类型的数据赋值给 int 类型的变量时，会发生什么？
A. 四舍五入。
 B. 截断（直接丢弃小数部分）。
 C. 向上取整。
 D. 抛出运行时错误。
 E. 无法编译。
答案：B
解析：
 浮点数转整数时，执行的是 截断（Truncation）：
- 3.99 -> 3
- -3.99 -> -3
 只是“扔掉小数部分”，与数学上的“取整”不同。

---
2. 字符与整数、浮点与整数
5. 关于 ASCII 码与整数、字符之间的关系，下列说法错误的是？
A. char 本质上可以看作存储了一个小整数。
 B. 可以把 int 赋值给 char（只要在 char 可表示的范围内）。
 C. 字符 '0' 对应的整数值是 0。
 D. 表达式 'A' + 1 的结果是整数 66（假设 'A' 的编码为 65）。
 E. (int)'a' 可以得到字符 'a' 的编码。
答案：C
解析：
- '0' 的 ASCII 码是 48，不是数值 0。
- 数值 0 对应的是空字符 '\0'。
 其他选项均是对的。

---
6. 下列关于 sizeof 的说法正确的是？
A. sizeof(char) 的结果类型是 char。
 B. sizeof(int) 的结果类型是 int。
 C. sizeof 的结果类型是 size_t，一种无符号整数类型。
 D. sizeof 在运行时才能计算。
 E. sizeof 只对基本类型有效。
答案：C
解析：
sizeof 的结果类型是 size_t，一般是 unsigned int 或 unsigned long，用来表示“大小 / 长度”。

---
7. 已知在某平台上 int 占 4 字节，double 占 8 字节，表达式 5 * 2.0 的结果占用多少字节？
A. 4
 B. 8
 C. 12
 D. 16
 E. 2
答案：B
解析：
- 5 是 int，2.0 是 double。
- 运算前 5 会被提升为 double，结果类型是 double。
- double 占 8 字节。

---
8. 下列哪个基础类型转换最容易导致“精度丢失”？
A. float -> double
 B. int -> long
 C. int -> double
 D. double -> float
 E. char -> int
答案：D
解析：
double（双精度，大约 15 位有效数字）→ float（单精度，大约 6–7 位）时，可能丢失小数位甚至出现溢出。
 A / B / C / E 都是从“小”往“大”装，一般更安全。

---
3. 隐式转换发生的场景
9. 以下关于隐式类型转换（自动转换）的说法中，哪一项是错误的？
A. 在赋值语句中，当右值类型与左值不同时，会发生隐式转换。
 B. 在算术运算中，不同类型一起运算会触发隐式转换。
 C. 函数调用时，实参类型与形参类型不完全匹配时可能发生隐式转换。
 D. 在 if 条件中，把 int 等非 bool 类型用作条件，会转成 bool。
 E. 所有类型转换都必须写 static_cast，C++ 不会自动转换。
答案：E
解析：
 A / B / C / D 都是典型的 隐式转换场景。
 E 与事实相反——C++ 中隐式转换是非常普遍存在的。

---
10. 关于 static_cast 在本节课涉及的用途，下列不属于它的作用的是：
A. 在基础类型之间显式转换（如 int 转 char）。
 B. 把 int 转成 double，用于修正整数除法精度。
 C. 把一个整数看作字符来输出（如 static_cast<char>(65)）。
 D. 去掉一个变量的 const 属性。
 E. 在类的继承层次中，基类指针和派生类指针之间的安全转换。
答案：D
解析：
- 去掉 const 需要 const_cast，不在本节重点。
- A / B / C / E 都是 static_cast 的合法用途。

---
第二阶段：代码实战篇（计算与分析）

---
4. 整数 / 浮点除法与截断
11. 执行代码：
cout << 10 / 4;
输出结果是？
A. 2.5
 B. 2
 C. 2.0
 D. 3
 E. 2.50
答案：B
解析：
10 和 4 都是 int，执行 整数除法：(10 / 4 = 2)，小数部分被直接丢掉。

---
12. 执行代码：
cout << 10 / 4.0;
输出结果是？
A. 2
 B. 2.0
 C. 2.5
 D. 3
 E. 编译错误
答案：C
解析：
- 4.0 是 double，10 会先提升为 double。
- 执行浮点除法，结果 (10.0 / 4.0 = 2.5)。

---
13. 阅读代码并写出 c 的值：
double a = 5.6;
int b = 2;
int c = a + b;
c 的最终值是？
A. 7.6
 B. 8
 C. 7
 D. 5
 E. 0
答案：C
解析：
1. 表达式 a + b：double + int -> double，结果为 7.6。
2. 赋值给 int c 时发生截断：7.6 -> 7。

---
14. 阅读代码，判断输出结果：
cout << (int)3.8 + 3.2;
输出为？
A. 7
 B. 7.0
 C. 6
 D. 6.2
 E. 6.0
答案：D
解析：
1. (int)3.8 先执行，结果是 3（截断）。
2. 3 + 3.2：int + double -> double，结果 6.2。

---
15. 已知 char ch = 'C';（假设 'C' 的编码是 67），执行：
ch = ch + 2;
之后 ch 中存的字符是？
A. 'C'
 B. 'D'
 C. 'E'
 D. 69
 E. 编译错误
答案：C
解析：
1. ch + 2：char 先提升为 int，67 + 2 = 69。
2. 赋值回 char：69 被当作编码，对应字符 'E'。

---
16. 阅读代码，判断输出：
int a = 65;
cout << static_cast<char>(a);
输出是？
A. 65
 B. A
 C. a
 D. 编译错误
 E. 运行异常
答案：B
解析：
static_cast<char>(65) 把整数 65 当作 ASCII 编码输出，即 'A'。

---
17. 已知：
int a = 3, b = 4;
float f = a / b;
f 的值是？
A. 0
 B. 0.0f
 C. 0.75f
 D. 1.0f
 E. 0.8f
答案：B
解析：
1. a / b 是 整数除法 → 结果是 0。
2. 0 赋给 float f，得到 0.0f。

---
18. 若要让上题中 f 的值正确为 0.75f，下列表达式哪一个是正确的修改方式？
A. float f = (float)(a / b);
 B. float f = a / (float)b;
 C. float f = (a + b) / 4;
 D. float f = (int)a / (int)b;
 E. float f = (double)a / (double)b;
答案：B
解析：
- 需要“先把其中一个数变成浮点，再做除法”：
a / (float)b ： 3 / 4.0f -> 0.75f。
- A 仍然是整数除法后再转型，结果还是 0。
- E 也可以算正确值，但类型是 double，而不是题目中的 float。

---
2. auto 推导与混合类型
19. 阅读代码：
auto v1 = 3 + 2.0;
auto v2 = 'A' + 1;
下列说法正确的是？
A. v1 是 int，v2 是 char。
 B. v1 是 double，v2 是 int。
 C. v1 是 float，v2 是 char。
 D. v1 和 v2 都是 double。
 E. v1 和 v2 都是 int。
答案：B
解析：
- 3 + 2.0：int + double -> double，所以 v1 是 double。
- 'A' + 1：char 先整型提升为 int（65），再加 1 还是 int，值为 66。

---
20. 阅读代码并判断输出（假设默认输出格式）：
int x = 5;
double y = x / 2;
cout << y;
输出更接近哪一项？
A. 2.5
 B. 2
 C. 2.0
 D. 3
 E. 0
答案：B（数值为 2.0，通常显示为 2）
解析：
1. x / 2 是整数除法 → 结果为 2。
2. 2 赋值给 double y，变成 2.0。
3. 默认格式下 cout 可能显示成 2（但底层值是 2.0）。

---
21. 阅读代码，判断输出：
float f = 1.23456789f;
cout << (int)f;
输出为？
A. 1
 B. 1.23456
 C. 123456789
 D. 0
 E. 随机值
答案：A
解析：
(int)f 进行截断，只保留整数部分 → 1。

---
22. 阅读代码，分析执行步骤：
int i = 5;
float f = 2.5f;
double d = (double)(i + f);
关于转换顺序，下列说法正确的是？
A. 先把 f 转成 int，再 i + f，结果再转成 double。
 B. 先把 i 转成 float，i + f 得到 float，最后转 double。
 C. 先把 i 和 f 都转成 double，再相加。
 D. 不发生任何隐式转换，直接相加后转 double。
 E. 先把 i 转成 double，再与 f 相加。
答案：B
解析：
- i + f：int 会隐式提升为 float，结果是 float。
- 最后外层 (double)(...) 把该 float 结果转为 double。

---
23. 阅读代码，判断 avg 的值：
int total = 10;
int count = 4;
double avg = static_cast<double>(total) / count;
avg 的值为？
A. 2
 B. 2.0
 C. 2.5
 D. 4.0
 E. 1.0
答案：C
解析：
- static_cast<double>(total) 让 10 先变成 10.0。
- 10.0 / 4 → 浮点除法，得到 2.5。

---
第三阶段：进阶陷阱篇（复杂场景与易错点）

---
5. 有符号 / 无符号与溢出
24. 阅读代码：
unsigned int u = 10;
int i = -20;
cout << (u + i > 0);
输出是 1（true）还是 0（false）？
A. 0
 B. 1
 C. 编译错误
 D. 程序崩溃
 E. -10
答案：B
解析（可简略讲）：
- u 是 unsigned int，i 是 int。
- 表达式 u + i 时，i 会被转换为 unsigned int，-20 变成一个很大的正数。
- “很大的正数 + 10” 当然大于 0，所以条件为真，输出 1。

---
25. 计算百分比时，初学者常写出这样的代码：
int score = 80;
int total = 100;
double rate = score / total;
rate 的实际值是？
A. 0.8
 B. 80.0
 C. 0.0
 D. 1.0
 E. 0.80
答案：C
解析：
- score / total 是整数除法：80 / 100 = 0。
- 0 再赋给 double rate，得到 0.0。
- 想要 0.8，应写为：rate = static_cast<double>(score) / total;。

---
26. 阅读代码并推断结果（假设 int 为 32 位）：
int x = 2147483647; // 假设为 int 的最大值
x = x + 1;
cout << x;
下列说法更贴近标准？
A. 输出 2147483648。
 B. 自动升级为 long long，输出 2147483648。
 C. 发生整数溢出，行为未定义（很多实现中会“绕回”成负数）。
 D. 抛出异常。
 E. 保持不变，仍是 2147483647。
答案：C
解析（讲课时可简写）：
- 超过 int 可表示的范围，属于 溢出，标准规定为 未定义行为。
- 在大多数常见平台上会“绕回”，变成一个负数（通常是 -2147483648）。

---
27. 为什么在 C++ 中更推荐使用 static_cast 而不是 (type) 这种 C 风格强制转换？
A. C 风格转换无法通过编译。
 B. C 风格转换比 static_cast 慢很多。
 C. C 风格转换太“万能”，容易做出危险的转换，阅读代码时不够醒目。
 D. static_cast 才能进行基本类型之间的转换。
 E. static_cast 会自动检查所有越界问题。
答案：C
解析：
- C 风格转换语法简单但不够明确，也可能执行一些高风险转换（类似 reinterpret_cast）。
- static_cast 语义明确，更容易在代码审查时看出“这里发生了类型转换”。

---
6. 字节范围与溢出、布尔转换
28. 假设在某实现中 char 是 8 位有符号类型（范围约为 -128~127）。执行：
char c = 130;
cout << (int)c;
下列说法更合适的是？
A. 一定输出 130。
 B. 一定输出 -126。
 C. 一定输出 2。
 D. 会发生实现相关的溢出，结果是不确定的某个整数。
 E. 编译错误。
答案：D
解析：
- 130 超出有符号 char 的正数范围，会发生溢出或截断。
- 具体得到的值和平台实现有关，标准并不严格规定。
- 用来提醒学生：小范围类型接收大数时有风险。

---
29. 关于布尔值转换，下列说法正确的是？
A. 只有 1 会转换为 true，其他都为 false。
 B. 所有非零整数都会转换为 true。
 C. 所有正数为 true，所有负数为 false。
 D. 所有非零整数为 false。
 E. 浮点数不能转换为 bool。
答案：B
解析：
- 规则是：0 为假，非 0 为真，不区分 1、2、-1 等。
- 对浮点数也适用：0.0 为 false，其它值为 true。

---
30. 阅读代码并判断输出（假设 unsigned int 为 32 位）：
cout << 25u - 50;
输出大致为？
A. -25
 B. 25
 C. 一个非常大的正整数（接近无符号整型的最大值）
 D. 0
 E. 编译错误
答案：C
解析：
- 25u 是无符号整型，50（有符号）会被转换为无符号。
- 相当于在无符号世界里计算 25 - 50，出现 下溢（Underflow），结果会“绕到”一个很大的正数。