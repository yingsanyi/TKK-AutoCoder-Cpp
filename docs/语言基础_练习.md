第一模块：变量与标识符 (Variables & Identifiers) —— 完整练习
1. 关于 C++ 变量的本质，以下描述最准确的是？
A. 变量只是代码中的一个文本标签，不占用物理空间。
B. 变量是内存中一个命名的存储区域，其值在程序运行期间可以被改变。
C. 变量一旦声明，其数值就永远不能改变。
D. 变量声明时不需要指定数据类型。
E. 变量名可以随意编写，不需要遵守任何规则。
答案：B
解析：
- A 错：变量对应内存中的具体地址，是占用物理内存空间的 1。
- B 对：这是变量的标准定义。它是一个容器，里面的“内容”（数据）是可以修改的 2。
- C 错：值不能改变的是“常量”（const），变量的值是可以变的。
- D 错：C++ 是强类型语言，必须先声明数据类型 3。
- E 错：变量名必须遵循标识符命名规则 4。
2. 以下哪一组标识符在 C++ 中全部是合法的？
A. _count, test1, High_Score
B. 1stPlace, name, age
C. int, float, double
D. my-name, your+age, hello
E. std::cout, main function, var
答案：A
解析：
- A 对：下划线开头、字母开头、中间包含下划线，均符合规则 5。
- B 错：1stPlace 以数字开头，非法 6。
- C 错：全是 C++ 关键字，不能用作变量名 7。
- D 错：包含连字符 - 和加号 +，非法 8。
- E 错：包含空格（main function）和作用域符号（::），非法。
3. C++11 标准引入了一种新的初始化方式，被称为“列表初始化”，更加安全和统一。以下哪项使用了这种方式？
A. int a = 10;
B. int a(10);
C. int a{10};
D. a = 10;
E. int a : 10;
答案：C
解析：
- A 是复制初始化（Copy Initialization）9。
- B 是括号初始化/构造初始化（Direct Initialization）10。
- C 是列表初始化（List Initialization），使用花括号 {}，是 C++11 引入的特性 11。
- D 是赋值语句，不是初始化。
4. 假设有代码 int Age = 18; int age = 20;，关于这两个变量说法正确的是？
A. 编译器会报错，因为变量名重复。
B. Age 和 age 是两个完全不同的变量，占用不同的内存空间。
C. 它们是同一个变量，后一个赋值覆盖前一个。
D. 这取决于操作系统的类型。
E. 不符合命名规范，程序无法运行。
答案：B
解析： C++ 标识符是区分大小写的（Case-Sensitive）。因此，Age（大写A）和 age（小写a）被编译器视为两个完全独立的变量 (12)。
5. 以下哪个单词是 C++ 的关键字（保留字），绝对不能用作变量名？
A. Student
B. include
C. define
D. class
E. Main
答案：D
解析：
- class 是定义类的关键字 13。
- Student、Main 只是普通的标识符（注意 C++ 关键字通常全小写，Main 不是关键字，虽然 main 是主函数名，但也不是保留关键字，不过不建议占用）。
- include 和 define 是预处理指令，虽然有特殊用途，但在技术上不属于核心语言关键字列表中的保留字（尽管也不建议用作变量名），但 class 绝对是核心关键字。
6. 想要声明一个整数变量 score 并初始化为 100，以下写法错误的是？
A. int score = 100;
B. int score(100);
C. int score{100};
D. int score; score = 100;
E. score = 100; int score;
答案：E
解析： C++ 遵循“先声明，后使用”的原则。选项 E 试图在声明 score 之前就给它赋值，这是编译错误 。其他选项都是合法的声明或初始化方式。
7. 关于变量名（标识符）的长度，PPT 中提到的规则是？
A. 最长只能 8 个字符。
B. 最长只能 255 个字符。
C. 必须是 32 个字符以内。
D. C++ 标准不限制长度，但实际长度取决于编译器。
E. 长度必须是偶数。
答案：D
解析： 根据 PPT 内容，C++ 不限制标识符长度，实际限制取决于具体的编译器实现 (15)。
8. 以下关于“连锁赋值”的代码，哪一段是语法正确的？
A. int a = b = c = 10; (假设 a,b,c 未声明)
B. int a, b, c; a = b = c = 10;
C. int a, b, c = 10, 10, 10;
D. int a = 10, int b = 10;
E. a = 10 = b;
答案：B
解析：
- A 错：b 和 c 未声明，不能直接用于初始化 a 16。
- B 对：先声明了 a, b, c，然后利用赋值运算符的右结合性，从右向左依次赋值，这是合法的 17。
- C 错：语法混乱。
- D 错：逗号分隔的声明中，不需要重复写 int。
- E 错：10 是常量，不能被赋值（它不是左值）。
9. 标识符命名原则中，PPT 推荐的原则是？
A. 越短越好，比如用 a, b, c。
B. 必须使用拼音。
C. 见名知意，不宜混淆。
D. 必须全部大写。
E. 必须以 _var 结尾。
答案：C
解析： 良好的编程习惯要求标识符“见名知意”（如 studentName），避免使用含糊不清的名称，以提高代码可读性。
10. 下列哪个字符不允许出现在 C++ 的变量名中？
A. 2 (数字)
B. _ (下划线)
C. a (小写字母)
D. $ (美元符号)
E. M (大写字母)
答案：D
解析： C++ 标准标识符只能由字母、数字和下划线组成。虽然某些特定编译器（如 GCC）可能扩展支持 $，但在标准 C++ 中，$ 是非法的标识符字符 (19)。数字可以出现在中间或结尾，但不能开头。
11. 执行语句 int x; 后，变量 x 的值是？
A. 0
B. 1
C. null
D. undefined (未定义/垃圾值)
E. 编译错误
答案：D
解析： 在 C++ 中（特别是在函数内部定义的局部变量），如果只声明变量而不进行初始化，变量中存储的是内存中原有的残留数据，即“垃圾值”，这是未定义的。因此推荐声明时即初始化 (20)。
12. 为什么 int 2dogs; 是一个错误的变量声明？
A. 它是 C++ 的关键字。
B. 它包含了非法字符。
C. 它是以数字开头的。
D. 它太长了。
E. 它是复数形式。
答案：C
解析： 标识符命名规则的核心铁律之一：第一个字符必须是字母或下划线，不能是数字 (21)。
13. 下面哪种情况不属于 C++ 关键字的使用场景？
A. 定义数据类型 (如 int, float)。
B. 流程控制 (如 if, while)。
C. 定义自定义变量名 (如 int while = 10;)。
D. 访问权限控制 (如 public, private)。
E. 内存管理 (如 new, delete)。
答案：C
解析： 关键字具有特定意义，不能用作自定义的变量名。int while = 10; 会导致编译错误，因为 while 是关键字 (22)。其他选项都是关键字的正确用途。
14. 分析代码片段：
int x = 5;
int y = x;
x = 10;
执行后，y 的值是多少？
A. 5
B. 10
C. 0
D. 15
E. 未知
答案：A
解析：
1. int x = 5; -> x 内存中存入 5。
2. int y = x; -> 将 x 当前的值（5）复制一份给 y。此时 y 是 5。
3. x = 10; -> 修改 x 的值为 10。这不会影响 y，因为 y 是独立的内存空间。
4. 所以 y 仍然是 5。
15. 以下哪个选项正确演示了在同一行声明多个变量并赋初值？
A. int a = 1, b = 2, c;
B. int a = 1; b = 2; c;
C. int a, b, c = 1, 2, 3;
D. int a = 1 int b = 2;
E. variable a=1, b=2;
答案：A
解析：
- A 对：使用逗号分隔，a 初始化为1，b 初始化为2，c 声明但未初始化。语法正确 23。
- B 错：分号结束了语句，后面的 b=2 变成了未声明变量的使用。
- C 错：c 会被初始化为 1，后面的 2, 3 是逗号表达式，语法虽然可能通过（视上下文），但无法按预期给 a, b 赋值。
- D 错：不能在逗号分隔中重复写 int，或者应该用分号分开。
- E 错：没有 variable 这个关键字。

---
第二模块：数据的分类——数据类型 (Data Types) —— 完整练习
1. 在 C++ 中，以下哪种数据类型不属于“基本数据类型”？
A. int
B. bool
C. char
D. double
E. string
答案：E
解析：
- A, B, C, D 错：根据 PPT 归类，整型 (int)、布尔型 (bool)、字符型 (char) 和浮点型 (double) 都属于基本数据类型 1。
- E 对：string（字符串）在 C++ 中属于复合数据类型（或类类型），它是由标准库提供的，不是语言内置的原生基本类型 2。
2. 关于 C++ 中数据类型占用的内存大小，标准规定的最小尺寸关系是？
A. char < short < int < long
B. char <= short <= int <= long
C. char == 1, int == 4, long == 8
D. short <= long <= int
E. float <= double <= int
答案：B
解析：
- C++ 标准没有规定每种类型的具体字节数（例如 int 不一定是 4 字节），只规定了它们的大小顺序关系 3。
- 正确的关系是：char <= short <= int <= long <= long long 4。
3. 如果需要存储一个精度要求较高的小数（例如 3.141592653589793），应该优先选择哪种数据类型？
A. float
B. int
C. long double 或 double
D. short
E. unsigned int
答案：C
解析：
- float 是单精度浮点数，通常只有 6-7 位有效数字 5。
- double 是双精度浮点数，通常有 15-16 位有效数字，适合高精度存储 6。
- int 和 short 只能存整数。
4. 想要查看某个变量或数据类型在当前计算机上占用了多少字节，应该使用哪个运算符？
A. length()
B. size()
C. checkbyte()
D. sizeof
E. width
答案：D
解析： sizeof 是 C++ 的操作符（不是函数），用于返回对象或数据类型所占的内存字节数 (7)。例如 sizeof(int)。
5. unsigned short 类型通常占用 2 个字节。它能表示的数值范围是？
A. -32768 到 32767
B. 0 到 65535
C. 0 到 32767
D. -65536 到 65535
E. 0 到 4294967295
答案：B
解析：
- short 占用 2 字节（16位）。
- unsigned 表示无符号，即没有负数。
- $$2^{16} = 65536$$，所以范围是 $$0$$ 到 $2^{16} - 1$，即 0 ~ 65535 8。
- 选项 A 是有符号 short 的范围 9。
5. 当我们执行代码 int a = 3.99; 时，变量 a 的值是多少？
A. 4（四舍五入）
B. 3.99（保持不变）
C. 3（截断/舍弃小数）
D. 0（类型不匹配导致归零）
E. 编译错误
答案：C
解析： 当浮点型（double 3.99）赋值给整型（int）时，会发生隐式类型转换。转换规则是直接丢弃小数部分（截断），而不是四舍五入 (10)。
6. 在 C++ 中使用 string 类型来定义字符串变量（如 string name = "XUJC";），必须包含哪个头文件？
A. <iostream>
B. <cstring>
C. <string>
D. <math>
E. <stdlib>
答案：C
解析： 使用 C++ 标准库中的字符串类型 std::string，必须引入头文件 #include <string> (11)。注意不是 <cstring>（那是 C 语言风格的字符串处理库）。
7. 关于 bool（布尔）类型，以下说法正确的是？
A. 它占用 4 个字节。
B. 它只能取值 true 或 false。
C. 它实际上存储的是字符 't' 或 'f'。
D. 它不能参与数学运算。
E. 它属于复合数据类型。
答案：B
解析：
- bool 类型通常占用 1 个字节 12。
- 它的标准取值是 true 或 false 13。
- 在内部或参与运算时，true 对应 1，false 对应 0。
8. 观察表达式 5 + 2.5，该表达式的计算结果的数据类型是？
A. int
B. float
C. double
D. char
E. short
答案：C
解析：
- 5 是 int 类型。
- 2.5 默认为 double 类型。
- 根据**自动类型转换（隐式转换）**规则，不同类型运算时，向精度更高、长度更长的方向转换。int 会提升为 double，结果也是 double 141414。
9. 已知字符 'A' 的 ASCII 码是 65。执行 char c = 'A' + 2; 后，cout << c; 的输出结果是？
A. 67
B. 652
C. C
D. A2
E. 编译错误
答案：C
解析：
- 字符变量直接参与算术运算时，先转换为对应的 ASCII 码 15。
- 'A' (65) + 2 = 67。
- 67 对应的 ASCII 字符是 'C'。因为变量 c 是 char 类型，所以输出字符 'C'。
10. C++ 中推荐使用哪种方式将 double 类型的变量 d 转换为 int 类型？（即静态转换）
A. int(d)
B. (int)d
C. convert<int>(d)
D. static_cast<int>(d)
E. dynamic_cast<int>(d)
答案：D
解析：
- A 和 B 是 C 语言或旧式 C++ 风格的转换 16。
- D static_cast<int>(d) 是 C++ 推荐的静态转换方式，更加安全、意图更明确 17。
11. 想要给现有的数据类型 double 起一个别名 Area，以下哪种写法是 C++11 标准引入且推荐的？
A. typedef double Area;
B. #define Area double
C. using Area = double;
D. Area = double;
E. double as Area;
答案：C
解析：
- A 是传统的 typedef 写法，也是合法的 18。
- C 是 C++11 引入的 using 关键字写法，语法更直观，支持模板别名，是现代 C++ 的推荐写法 19。
12. 定义一个常量 PI，使其值在程序运行期间不能被修改，正确的定义语句是？
A. double PI = 3.14;
B. const double PI = 3.14;
C. static double PI = 3.14;
D. double const PI; PI = 3.14;
E. readonly double PI = 3.14;
答案：B
解析： const 关键字用于定义符号常量。语法为 const 类型说明符 变量名 = 常量值; (20)。D 错误是因为常量必须在声明时同时初始化。
13. 以下哪个选项中的数据类型，按照表示范围从大到小的顺序排列（假设典型 64 位环境）？
A. long long > int > short > char
B. char > short > int > long
C. double > float > long double
D. bool > char > short
E. short > long > int
答案：A
解析：
- A 正确：long long (8字节) > int (4字节) > short (2字节) > char (1字节) 21。
- B 顺序反了。
- C long double 通常比 double 大。
14. 如果代码中出现 int a = 10; double b = 3.14;，执行 cout << typeid(a+b).name();，输出的结果（类型）是？
A. int
B. double
C. float
D. long
E. char
答案：B
解析：
- 当 int 和 double 进行运算时，系统会自动进行隐式类型转换。
- 为了保证精度不丢失，转换按数据长度增加的方向进行 22。
- 整数会转换为双精度浮点数，因此 a+b 的结果类型是 double 23。

---
第三模块：数据的输入与输出 (I/O) —— 完整练习
1. 在 C++ 中，标准输入流对象 cin 通常与哪个运算符配合使用来获取用户输入？
A. << (插入运算符)
B. >> (提取运算符)
C. :: (作用域解析运算符)
D. . (成员访问运算符)
E. & (取地址运算符)
答案：B
解析： > * cin 使用 提取运算符 >> (Extraction Operator) 从输入流中提取数据并存入变量。
- cout 使用 插入运算符 << (Insertion Operator) 将数据插入到输出流中。
2. 执行语句 cout << setw(5) << 12;，屏幕上的输出结果是（_代表空格）？
A. 12
B. 12___
C. ___12
D. 00012
E. 编译错误
答案：C
解析： > * setw(n) 设置输出域宽为 n。
- 默认情况下，输出是右对齐的，不足的部分用空格填充。
- 数字 12 占 2 位，宽度设为 5，所以左边填充 3 个空格，结果是 ___12。
3. 为了使用 setw、setprecision 等格式化操纵符，必须在程序开头包含哪个头文件？
A. <iostream>
B. <fstream>
C. <iomanip>
D. <cstdlib>
E. <string>
答案：C
解析： > * <iomanip> 是 I/O Manipulators 的缩写，专门用于定义格式化输出的操纵符（如 setw, setprecision, setfill 等）。
- <iostream> 仅包含基本的输入输出功能（如 cin, cout, endl）。
4. 关于 endl 和 \n 的区别，下列说法正确的是？
A. 两者完全相同，没有任何区别。
B. \n 只能用于字符串内部，endl 只能用于字符串外部。
C. endl 不仅换行，还会强制刷新输出缓冲区，而 \n 通常只换行。
D. \n 占用的内存比 endl 大。
E. endl 是 C 语言遗留的特性，不推荐使用。
答案：C
解析： > * \n 是一个转义字符，仅表示换行。
- endl 是一个操纵符，它执行两个操作：1. 插入换行符；2. 调用 flush 强制刷新缓冲区（将内存中的数据立刻写到屏幕上）。在频繁输出时，滥用 endl 可能会降低性能。
5. 若变量 x 为 double 类型，值为 3.14159。执行 cout << fixed << setprecision(2) << x; 后的输出是？
A. 3.14159
B. 3.1
C. 3.14
D. 3.142
E. 3.15
答案：C
解析： > * fixed 表示以固定小数点格式输出。
- setprecision(2) 在 fixed 模式下表示保留 小数点后两位。
- 系统会进行四舍五入，3.14159 保留两位是 3.14。
6. 当用户输入字符串 "Hello World"（中间有空格）并按下回车，以下代码中变量 str 的值是什么？
string str;
cin >> str;
A. Hello World
B. Hello
C. World
D. HelloWorld
E. 程序崩溃
答案：B
解析： > * cin >> 使用空白字符（空格、Tab、换行）作为分隔符。
- 当它读取到 "Hello" 后面的空格时，就会停止读取。剩下的 " World" 会留在输入缓冲区中等待下一次读取。
7. 如果想要读取包含空格的一整行文本（例如 "Zhang San"），应该使用哪个函数？
A. cin >> str;
B. cin.get(str);
C. cin.read(str);
D. getline(cin, str);
E. scanf("%s", str);
答案：D
解析： > * getline(cin, str) 是专门用于读取一行字符串的函数，它会一直读取直到遇到换行符，因此可以包含空格。
8. 关于 setw 操纵符的“持久性”，以下描述正确的是？
A. 一次设置，永久有效，直到被修改。
B. 只对紧随其后的那一个输出项有效，之后恢复默认。
C. 必须和 fixed 一起使用才有效。
D. 只能用于整数输出，不能用于字符串。
E. 只要不换行，就一直有效。
答案：B
解析： > * 这是 setw 的一个特殊性质。大多数操纵符（如 setprecision, fixed, left）都是“粘性”的（Persistent），设置一次后一直有效。
- 唯独 setw 是非粘性的，它只影响紧随其后的下一个字段。
9. 假如 int a = 123;，执行 cout << setw(5) << setfill('0') << a;，输出结果是？
A. 12300
B. 00123
C.   123
D. 123  
E. 000123
答案：B
解析： > * setw(5) 设定宽度为 5。
- setfill('0') 设定填充字符为 '0'（默认为空格）。
- 默认右对齐，因此 '0' 填充在左边，结果为 00123。
10. 在 C++ 中，反斜杠 \ 用于转义。如果想要在屏幕上输出一个双引号字符 "，正确的写法是？
A. cout << """;
B. cout << "\"";
C. cout << '"';
D. cout << /";
E. B 和 C 都可以
答案：E
解析： > * 在双引号字符串中，必须用 \" 来表示双引号（选项 B）。
- 如果是字符常量（单引号包围），可以直接写 '"'（选项 C），因为单引号内不需要转义双引号。所以 B 和 C 都是正确的输出方式。
11. 执行以下代码时，用户输入 10.5，变量 num 的值是多少？
int num;
cin >> num;
A. 10.5
B. 10
C. 11
D. 0
E. 导致运行时错误
答案：B
解析： > * num 是 int 类型。当输入 10.5 时，cin 读取整数部分 10 并赋值给 num。
- 小数点 . 不是整数的一部分，因此读取停止。.5 会被留在输入缓冲区中，可能会影响后续的输入操作。
12. 想要实现输出内容左对齐，应该使用哪个操纵符？
A. right
B. left
C. align_left
D. setiosflags(ios::left)
E. B 和 D 都可以
答案：E
解析： > * left 是 <iomanip> 中提供的标准操纵符（选项 B）。
- setiosflags(ios::left) 是较老的写法，但效果一样（选项 D）。
- 默认情况下，C++ 输出是右对齐的。
13. 转义字符 \t 的主要作用是？
A. 换行
B. 输出一个反斜杠
C. 水平制表（相当于按下了 Tab 键），用于对其列
D. 发出警报声
E. 删除前一个字符
答案：C
解析： \t 代表 Horizontal Tab（水平制表符），通常用于在输出时对齐文本列。
14. 观察以下代码，最终输出的 c 的值是多少？
C++
char c;
cin >> c; // 用户输入空格 ' '// 注意：cin 默认会跳过空白字符
A. 空格 ' '
B. 无法确定，程序会继续等待输入
C. ASCII 码 0
D. \n
E. null
答案：B
解析： > * 标准的 cin >> 会自动跳过/忽略前导的空白字符（空格、Tab、换行）。
- 如果用户只输入一个空格并回车，cin 会认为还没有读到有效数据，光标会停留在下一行继续等待用户输入非空白字符。
15. 如果想让布尔值 true 和 false 在输出时显示为单词 "true" 和 "false"，而不是 1 和 0，可以使用哪个操纵符？
A. boolalpha
B. showbool
C. text
D. alpha
E. noboolalpha
答案：A
解析： > * 默认情况下，bool 类型输出为 1 或 0。
- 使用 cout << boolalpha; 可以让后续的布尔值以文本形式（true/false）输出。
- 反之，noboolalpha 恢复为数字输出。

---
这是为您精心准备的第四模块：数据的变形——类型转换 (Type Conversion) 的 30 道进阶练习题。
鉴于您提到这部分内容较为复杂，我将题目分为三个阶段：基础概念篇（巩固规则）、代码实战篇（分析结果）、进阶陷阱篇（避开雷区），帮助您由浅入深、全方位掌握 C++ 的类型转换机制。

---
第四模块：数据的变形——类型转换 —— 30道精选练习
第一阶段：基础概念篇（规则与原理）
1. C++ 中，当不同类型的数据进行混合运算时，编译器会自动进行类型转换。这种转换通常遵循什么原则？
A. 向占用内存更小的方向转换，以节省空间。
B. 向精度更高、长度更长的方向转换，以防止数据丢失。
C. 全部转换为 int 类型。
D. 全部转换为 double 类型。
E. 不进行转换，直接报错。
答案：B
解析： 隐式类型转换（自动转换）的核心原则是“宁可浪费空间，不可丢失精度”。转换按数据长度增加的方向进行，例如 int 会自动转为 double (1)(1)(1)(1)。
2. 在 C++ 的隐式转换层级中，最低级的类型（如 char, short）在参与运算前，通常会被提升为哪种类型？
A. long
B. float
C. int
D. double
E. unsigned int
答案：C
解析： 这是一个经典规则，称为整型提升 (Integral Promotion)。char 和 short 在参与算术运算时，会被自动提升为 int 以提高 CPU 处理效率 (2)(2)(2)(2)。
3. 以下哪种转换方式属于 C++ 推荐的显式转换（静态转换）写法？
A. (int)3.14
B. int(3.14)
C. [int]3.14
D. static_cast<int>(3.14)
E. convert_to_int(3.14)
答案：D
解析：
- A 是 C 语言风格的强制转换。
- B 是函数风格的强制转换。
- D static_cast<Type>(Expression) 是 C++ 特有的、更安全、意图更明确的显式转换方式 3。
4. 当我们将一个 double 类型的数据赋值给 int 类型的变量时，会发生什么？
A. 四舍五入。
B. 截断（直接丢弃小数部分）。
C. 向上取整。
D. 运行时错误。
E. 无法编译。
答案：B
解析： 浮点数转整数时，C++ 执行截断 (Truncation) 操作。例如 3.99 变成 3，-3.99 变成 -3 (4)。
5. 关于 ASCII 码与整数的转换，下列说法错误的是？
A. char 类型本质上是存储的一个整数。
B. 可以直接将 int 赋值给 char（只要在范围内）。
C. 字符 '0' 对应的整数值是 0。
D. 字符 'A' + 1 的结果是整数 66（假设 'A' 为 65）。
E. (int)'a' 可以获取 'a' 的 ASCII 码。
答案：C
解析：
- 字符 '0' 的 ASCII 码通常是 48，而不是数字 0。数字 0 对应的是空字符 \0 5。
6. 表达式 sizeof(char) + sizeof(int) 的结果类型是？
A. char
B. short
C. int
D. long
E. size_t (无符号整数)
答案：E
解析： sizeof 运算符返回的结果类型是 size_t，这是一个无符号整数类型（通常等同于 unsigned int 或 unsigned long），用于表示内存大小。
7. 在 32 位系统中，int 占 4 字节，double 占 8 字节。表达式 5 * 2.0 的结果占用多少字节？
A. 4
B. 8
C. 12
D. 16
E. 2
答案：B
解析： 5 是 int，2.0 是 double。运算时 int 会隐式转换为 double，结果也是 double。double 通常占用 8 字节 (6)。
8. 以下哪个类型转换可能会导致严重的精度丢失或数据错误？
A. float -> double
B. int -> long
C. int -> double
D. double -> float
E. char -> int
答案：D
解析： double（双精度，约15位有效数字）转换为 float（单精度，约6-7位有效数字）时，如果数值很大或小数位很多，会发生精度丢失甚至溢出。其他选项大多是向更宽的范围转换，是安全的。
9. C++ 中 static_cast 的主要作用不包括：
A. 基础数据类型之间的转换（如 int 转 char）。
B. 将空指针转换为目标类型的指针。
C. 移除变量的 const 属性。
D. 类层次结构中基类和派生类之间指针或引用的转换。
E. 明确告诉编译器“我知道我在做什么，请进行转换”。
答案：C
解析： 移除 const 属性需要使用专门的 const_cast，static_cast 无法做到这一点。
10. 关于隐式转换的发生场景，以下描述不正确的是？
A. 赋值语句中，右值类型与左值不同时。
B. 不同类型的变量进行算术运算时。
C. 函数调用时，实参类型与形参类型不完全匹配时。
D. if 或 while 条件判断中，非布尔值被用作条件时。
E. 所有的类型转换都必须显式写出，C++ 不会自动转换。
答案：E
解析： C++ 支持且广泛使用隐式类型转换（自动转换），A、B、C、D 都是隐式转换发生的典型场景。

---
第二阶段：代码实战篇（计算与分析）
1. 执行代码 cout << 10 / 4;，输出结果是？
A. 2.5
B. 2
C. 2.0
D. 3
E. 2.50
答案：B
解析： 两个整数相除，执行的是整数除法，小数部分被丢弃。10 / 4 结果为 2 (7)。
2. 执行代码 cout << 10 / 4.0;，输出结果是？
A. 2
B. 2.0
C. 2.5
D. 3
E. 编译错误
答案：C
解析： 4.0 是 double 类型。整数 10 会被隐式转换为 double，执行浮点数除法，结果为 2.5。
3. 下列代码执行后，变量 c 的值是多少？
double a = 5.6;
int b = 2;
int c = a + b;
A. 7.6
B. 8
C. 7
D. 5.6
E. 0
答案：C
解析：
1. a + b：double + int -> double，结果为 7.6。
2. int c = ...：将 7.6 赋值给 int，发生截断，变成 7 8。
4. 分析代码：cout << (int)3.8 + 3.2;，输出结果是？
A. 7
B. 7.0
C. 6
D. 6.2
E. 6.0
答案：D
解析：
1. 强制转换优先级高：(int)3.8 先执行，结果为整数 3。
2. 加法运算：3 + 3.2 -> int + double -> double。
3. 结果为 6.2。
5. 若 char ch = 'C';（ASCII 67），则表达式 ch = ch + 2; 执行后，ch 存储的字符是？
A. 'C'
B. 'D'
C. 'E'
D. 69
E. 编译错误
答案：C
解析：
1. ch + 2：char 提升为 int，67 + 2 = 69。
2. 赋值回 ch：整数 69 转换回 char。
3. 69 对应的字符是 'E'。
6. 下列代码片段的输出是？
C++
int a = 65;
cout << static_cast<char>(a);
A. 65
B. A
C. a
D. 编译错误
E. 运行异常
答案：B
解析： static_cast<char>(a) 显式地将整数 65 转换为对应的 ASCII 字符，即大写字母 'A' (9)。
7. 变量 i 为 int 类型，f 为 float 类型。表达式 (double)(i + f) 的转换顺序是？
A. 先将 i 转为 float，结果再转为 double。
B. 先将 f 转为 int，结果再转为 double。
C. 先将 i 和 f 都转为 double 再相加。
D. i 和 f 不转换，直接相加后转为 double。
E. 先将 i 转为 float，结果相加，最后将和强制转换为 double。
答案：E
解析：
1. i + f：int 转 float（隐式提升），执行加法，结果为 float。
2. (double)(...)：将上一步的 float 结果强制转换为 double。
8. 代码 int x = 5; double y = x / 2; cout << y; 的输出是？
A. 2.5
B. 2
C. 2.0
D. 3
E. 0
答案：B (或显示为 2)
解析：
1. x / 2 是整数除法（5/2），结果是整数 2。
2. 将整数 2 赋值给 double y，y 变为 2.0。
3. cout 默认输出浮点数时，如果小数部分为0，通常显示为整数形式（取决于编译器设置，通常显示 2，严格数值是 2.0）。
9. 代码 float f = 1.23456789; cout << (int)f; 输出结果是？
A. 1
B. 1.23456
C. 123456789
D. 0
E. 随机值
答案：A
解析： 强制将 float 转换为 int，直接截断小数部分，只保留整数部分 1。
10. 设 int a = 3, b = 4;，则表达式 (float)a / b 的结果是？
A. 0
B. 0.75
C. 0.0
D. 1
E. 1.0
答案：B
解析：
1. (float)a 将 a 转换为 3.0f。
2. 3.0f / b：b (int) 隐式转换为 float。
3. 执行浮点除法 3.0 / 4.0，结果为 0.75。

---
第三阶段：进阶陷阱篇（复杂场景与溢出）
1. 请看以下代码：
unsigned int u = 10;
int i = -20;
cout << (u + i > 0); // 输出 1(true) 还是 0(false)?
A. 0 (false)
B. 1 (true)
C. 编译器报错
D. 运行时崩溃
E. -10
答案：B
解析： 高危陷阱！
当 int（有符号）与 unsigned int（无符号）进行运算时，int 会被隐式转换为 unsigned int。
-20 转换为无符号数会变成一个非常大的正整数（补码表示）。
因此 10 + (非常大的数) 显然大于 0。
2. 在计算百分比时，初学者常犯的错误是 int score = 80; int total = 100; double rate = score / total;。rate 的值实际上是？
A. 0.8
B. 80.0
C. 0.0
D. 1.0
E. 0.8000
答案：C
解析： score / total 两个整数相除（80/100），结果为整数 0。然后赋值给 rate，结果为 0.0。
修正： 应写为 (double)score / total。
3. 关于 string 到 int 的转换，下列说法正确的是？
A. string s = "123"; int i = (int)s; 可以直接转换。
B. 必须使用 static_cast<int>(s)。
C. 需要使用标准库函数如 stoi(s) 或 atoi(s.c_str())。
D. C++ 会自动将字符串内容解析为数字。
E. 无法转换。
答案：C
解析： string 是类对象，不能通过简单的强制类型转换变成数字。必须使用专门的转换函数，如 C++11 引入的 stoi (string to integer)。
4. 表达式 int x = 2147483647; x = x + 1; 发生了什么？（假设 int 为 32 位）
A. x 变为 2147483648
B. 类型自动升级为 long long
C. 发生整数溢出 (Overflow)，x 变为负数 (-2147483648)
D. 抛出异常
E. x 保持不变
答案：C
解析： int 的最大值是 2147483647。加 1 后发生溢出，符号位被置位，变成了最小值 -2147483648。这是一个典型的未定义行为（虽在多数系统上表现为绕回）。
5. 为什么不建议使用 (type)expression 这种 C 风格的强制转换？
A. 它无法编译通过。
B. 它的执行速度慢。
C. 它过于强大且不清晰，能在任何类型间强转（如指针转整数），容易隐藏 bug。
D. 它只能用于基本数据类型，不能用于对象。
E. 它不能用于 const 变量。
答案：C
解析： C 风格转换语法简单但检查宽松，难以在代码中搜索定位，且可能执行危险的操作（如 reinterpret_cast 的功能），C++ 推荐使用具体的 cast 操作符来明确意图。
6. 下列混合运算中，最终结果类型是 double 的是？
A. int * int + float
B. char / short + long
C. float * double + int
D. short + unsigned int
E. long + long
答案：C
解析： 只要表达式中有一个 double，根据“向高精度对齐”原则，整个表达式的运算过程（相关部分）最终会提升到 double。
7. 执行 char c = 300;（假设 char 为 8 位有符号），cout << (int)c; 的结果最可能是？
A. 300
B. 44
C. -1
D. 溢出后的某个值（如 44 或其他负数）
E. 编译错误
答案：D
解析： char 通常只有 8 位，范围 -128~127。300 的二进制是 100101100（9位），赋值给 8 位容器会发生截断，只保留低 8 位 00101100（十进制 44）。具体结果取决于编译器对溢出的处理，通常是 44。
8. 关于布尔值转换，表达式 (bool)0.00001 的值是？
A. false
B. true
C. 0
D. 不确定
E. 编译警告
答案：B
解析： 在 C++ 中，非零即真。只要浮点数不严格等于 0.0，转换为 bool 时都为 true。
9. 分析代码 cout << 25u - 50; 的输出结果。（u 表示 unsigned）
A. -25
B. 25
C. 一个非常大的正整数
D. 0
E. 编译错误
答案：C
解析： 类似于第 21 题。25u 是无符号数，50 是有符号数。运算时 50 转为无符号数。25 - 50 在无符号算术中会发生下溢 (Underflow)，结果回绕到无符号类型的最大值附近。
10. 在 C++ 中，typeid(expr).name() 返回的信息依赖于什么？
A. C++ 标准严格规定的字符串。
B. 操作系统的版本。
C. 具体的编译器实现 (Implementation-defined)。
D. 程序员的定义。
E. 总是类型的完整英文名称。
答案：C
解析： C++ 标准只规定了 typeid 返回 type_info 对象，但 .name() 返回的字符串内容（如 i, int, PKc 等）完全取决于编译器，不同编译器输出可能不同 (10)。

---
这是为您准备的第五模块：计算的引擎——运算符 (Operators) 的完整学习资源。
本模块涵盖了 C++ 中最核心的计算逻辑：算术运算、逻辑判断、位操作以及复杂的优先级规则。这是编写任何算法的基础。

---
第五模块：计算的引擎——运算符 (Operators) —— 20道精选选择题
第一部分：算术与赋值 (Arithmetic & Assignment)
1. C++ 中，表达式 14 % 5 的结果是？
A. 2.8
B. 2
C. 4
D. 3
E. 编译错误
答案：C
解析： % 是取模运算符（求余数）。$14 \div 5 = 2 \dots 4$。注意 % 只能用于整数 (1)。
2. 执行语句 int x = 10; x += x -= x - x; 后，x 的值是？
A. 10
B. 20
C. 0
D. 30
E. 40
答案：B
解析：
1. 赋值运算符是从右向左结合的。
2. 先算最右边的 x - x，结果为 0。
3. 此时表达式变成 x += x -= 0。
4. 计算 x -= 0，即 x = x - 0，x 还是 10。该表达式返回 10。
5. 最后计算 x += 10，即 x = 10 + 10，x 变为 20。
3. 若 int a = 5;，执行 a %= 3; 后，a 的值是？
A. 1
B. 2
C. 3
D. 5
E. 0
答案：B
解析： a %= 3 等价于 a = a % 3。$$5 \div 3$$ 余 2，所以 a 变为 2 (2)。
4. 关于复合赋值运算符 a *= b + 3，其等价的完整表达式是？
A. a = a * b + 3
B. a = (a * b) + 3
C. a = a * (b + 3)
D. a = a + 3 * b
E. a = (a + 3) * b
答案：C
解析： 这是一个经典陷阱。复合赋值运算符（如 *=）右侧的表达式被视为一个整体（如同加了括号）。所以是 a = a * (b + 3)。
5. 代码 int i = 3; int k = (++i) + (++i) + (++i); 的结果在 C++ 标准中属于？
A. k=15
B. k=18
C. k=12
D. 未定义行为 (Undefined Behavior)
E. 编译错误
答案：D
解析： PPT 中明确提示：“不要在同一语句中包含一个变量的多个++或--” 。因为不同编译器对变量修改生效的时间点（序列点）处理可能不同，这属于未定义行为，应极力避免。

---
第二部分：自增与自减 (Increment & Decrement)
6. 执行 int x = 5, y; y = x++; 后，x 和 y 的值分别是？
A. x=6, y=6
B. x=5, y=5
C. x=6, y=5
D. x=5, y=6
E. x=6, y=0
答案：C
解析： x++ 是后置自增：先使用 x 当前的值（5）赋值给 y，然后 x 自增变为 6 (4)。
7. 执行 int x = 5, y; y = ++x; 后，x 和 y 的值分别是？
A. x=6, y=6
B. x=5, y=5
C. x=6, y=5
D. x=5, y=6
E. x=6, y=0
答案：A
解析： ++x 是前置自增：x 先自增变为 6，然后使用新值（6）赋值给 y (5)。
8. 表达式 y = x++ * 3; (设 x=2) 的运算顺序是？
A. 先 x*3，再 x 自增。
B. 先 x 自增，再 x*3。
C. 先取 x 的值参与乘法，乘法运算结束后 x 再自增。
D. 不确定。
E. 编译错误。
答案：C
解析： 后置 ++ 的优先级虽然高，但其语义是“返回值是原始值，副作用是稍后加1”。所以先取 x=2 算 2*3=6 赋给 y，之后 x 变为 3 (6)。

---
第三部分：逻辑与关系 (Logical & Relational)
9. 在 C++ 中，表达式 5 > 3 > 1 的值是？
A. true (1)
B. false (0)
C. 2
D. 5
E. 编译错误
答案：B
解析： 这是一个数学与编程直觉的陷阱。
1. 关系运算符从左向右结合。先算 5 > 3，结果为 true (即整数 1)。
2. 表达式变为 1 > 1。
3. 1 > 1 为假，结果为 false (即 0)。
10. 逻辑与运算符 && 具有“短路”特性。对于表达式 A && B，如果 A 为假，则：
A. B 不会被计算。
B. B 仍然会被计算。
C. 程序报错。
D. 整个表达式的值不确定。
E. A 和 B 同时计算。
答案：A
解析： 如果 A 为 false，整个 && 表达式注定为 false，C++ 为了效率会跳过 B 的计算。这被称为“短路求值”。
11. 下列表达式中，结果为 true 的是？
A. !5
B. (3 > 5) || (2 < 4)
C. !(10 == 10)
D. 5 && 0
E. false || false
答案：B
解析：
- A: !5 (非零即真，取反为假) -> false。
- B: false || true -> true。
- C: !true -> false。
- D: true && false -> false。
12. 运算符优先级的正确排序（从高到低）是？
A. && > + > =
B. + > && > =
C. = > && > +
D. && > = > +
E. + > = > &&
答案：B
解析： 算术运算符 (+) > 逻辑运算符 (&&) > 赋值运算符 (=) (7)。

---
第四部分：位运算与其它 (Bitwise & Others)
13. 二进制位运算 5 & 14 的结果是？
A. 1
B. 4
C. 5
D. 14
E. 15
答案：B
解析：
- 5: 0101
- 14: 1110
- & (按位与): 0100 -> 十进制 4 8。
14. 表达式 1 << 3 的结果相当于？
A. $$1 \times 3$$
B. $$1 + 3$$
C. $$1 \times 2^3$$
D. $$1 \div 2^3$$
E. 31
答案：C
解析： 左移运算符 << 相当于乘以 2 的 n 次方。1 << 3 即 $1 \times 8 = 8$ (9)。
15. 若 short a = 5;，表达式 ~a 的结果取决于？
A. 仅取决于 a 的值。
B. 取决于操作系统的位数。
C. 取决于 short 类型是有符号还是无符号以及其位数。
D. 总是 -6。
E. 总是 0。
答案：C
解析： ~ 是按位取反。000...0101 取反变 111...1010。在补码系统中，如果是有符号数，结果通常是 -6 (即 -a-1)。但具体二进制位取决于类型长度 (10)(10)(10)(10)。
16. 关于逗号运算符 x = (a = 3, 6 * 3)，x 的值是？
A. 3
B. 6
C. 9
D. 18
E. 编译错误
答案：D
解析： 逗号表达式从左向右执行，返回最后一个表达式的值。
1. 先执行 a=3。
2. 再执行 6*3，结果 18。
3. 整个括号的值是 18，赋值给 x 11。
17. sizeof(double) 在常见 64 位系统上的值通常是？
A. 4
B. 8
C. 10
D. 16
E. 2
答案：B
解析： double 通常占用 8 个字节 (12)。sizeof 返回的是字节数。
17. 数学函数 pow(2, 3) 的返回值类型是？
A. int
B. float
C. double
D. long
E. void
答案：C
解析： <cmath> 库中的数学函数（如 pow, sqrt）通常处理并返回 double 类型 (13)。
18. 在使用数学函数如 sqrt() 或 pow() 之前，必须包含？
A. #include <math>
B. #include <cmath>
C. #include <algorithm>
D. #include <iostream>
E. A 和 B 都可以
答案：E
解析： 在 C++ 中，推荐使用标准头文件 <cmath>。但为了兼容 C，<math.h> (或题目中的 A 写法如果是指 C 风格) 也可以用，但规范写法是 <cmath> (14)。
19. 表达式 (int)3.5 + 4.5 的值是？
A. 8.0
B. 7.5
C. 7
D. 8
E. 7.0
答案：B
解析：
1. (int)3.5 强制转换为整数 3。
2. 3 + 4.5 -> int + double -> 结果为 double 类型的 7.5。

---
编程实战：3道经典题目
题目 1：数字分离器 (Digit Separator)
题目描述：
编写一个程序，输入一个三位的正整数（例如 123），分别输出它的个位、十位和百位数字。
考察点： 取模运算 % 和 整数除法 /。
参考代码：
#include <iostream>
using namespace std;

int main() {
    int num;
    cout << "请输入一个三位数: ";
    cin >> num;

    // 核心算法
    int units = num % 10;          // 个位：除以10的余数
    int tens = (num / 10) % 10;    // 十位：先去个位，再取余
    int hundreds = num / 100;      // 百位：直接除以100取整

    cout << "百位: " << hundreds << endl;
    cout << "十位: " << tens << endl;
    cout << "个位: " << units << endl;

    return 0;
}
题目 2：两点间距离计算器 (Geometry Calculator)
题目描述：
输入平面上两点 $$A(x_1, y_1)$$ 和 $$B(x_2, y_2)$$ 的坐标，计算并输出它们之间的距离。
公式：$$Distance = \sqrt{(x_1-x_2)^2 + (y_1-y_2)^2}$$
考察点： 数学函数库 <cmath> (sqrt, pow) 以及 double 类型的使用。
参考代码：
#include <iostream>
#include <cmath>    // 必须包含，用于 sqrt 和 pow
#include <iomanip>  // 用于格式化输出
using namespace std;

int main() {
    double x1, y1, x2, y2;
    cout << "请输入A点坐标 (x1 y1): ";
    cin >> x1 >> y1;
    cout << "请输入B点坐标 (x2 y2): ";
    cin >> x2 >> y2;

    // 计算距离
    // pow(a, 2) 表示 a 的平方
    double distance = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));

    cout << fixed << setprecision(2); // 保留两位小数
    cout << "A和B之间的距离是: " << distance << endl;

    return 0;
}
题目 3：不用临时变量交换数据 (Bitwise Swap)
题目描述：
编写一个程序，输入两个整数 a 和 b，在不使用第三个临时变量的情况下交换它们的值。请使用位运算（异或）实现。
考察点： 异或运算 (^) 的性质：a ^ a = 0, a ^ 0 = a。
参考代码：
#include <iostream>
using namespace std;

int main() {
    int a, b;
    cout << "请输入整数 a 和 b: ";
    cin >> a >> b;

    cout << "交换前: a=" << a << ", b=" << b << endl;

    // 异或交换法 (仅适用于整数)
    // 原理：
    // Step 1: a 变成了 a^b 的混合体
    // Step 2: b = (a^b) ^ b = a (b变成了原来的a)
    // Step 3: a = (a^b) ^ a = b (a变成了原来的b)
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;

    cout << "交换后: a=" << a << ", b=" << b << endl;

    return 0;
}

---
🎓 C++ 编程基础：全章综合测试 (Total Review)
第一部分：单项选择题 (30 题)
模块一：基础语法与变量
1. 下列哪一组标识符在 C++ 中是完全合法的？
A. 3days, print, sum
B. student_id, _name, Int
C. void, return, cout
D. my-var, total$, break
2. 关于变量初始化的说法，错误的是？
A. int a = 10; 是最常见的初始化方式。
B. int a; 声明的局部变量，其默认值一定是 0。
C. int a(10); 是构造函数风格的初始化。
D. int a{10}; 是 C++11 推荐的列表初始化。
3. C++ 语言中，对大小写敏感（Case-Sensitive）意味着：
A. MAIN 和 main 是同一个函数。
B. 关键字（如 if）可以用大写 IF 代替。
C. 变量 Apple 和 apple 代表两个不同的内存区域。
D. 只有变量名区分大小写，函数名不区分。
4. 以下代码会导致编译错误的是？
A. int a = 1, b = 2;
B. const int MAX = 100; MAX = 200;
C. double d = 10;
D. char c = ' ';
5. 想要定义一个名为 class_room 的变量，以下哪个是正确的？
A. int class = 101;
B. int class_room = 101;
C. string 1class = "Room";
D. float class-room = 10.5;

---
模块二：数据类型
6. C++ 中占用内存最小的整数类型通常是？
A. short
B. int
C. char
D. long
7. 表达式 sizeof("Hello") 的值是（在 64 位系统上）？
A. 4
B. 5
C. 6
D. 8
8. 以下哪个字面量表示一个 float 类型的数据？
A. 3.14
B. 3.14f
C. 3
D. '3'
9. bool 类型变量在内存中存储 true 时，其实际的整数值通常是？
A. -1
B. 0
C. 1
D. 255
10. 想要在 C++ 中使用 string 类型，必须包含的头文件是？
A. <cstring>
B. <string.h>
C. <iostream>
D. <string>
11. unsigned short 类型的最大值是多少（假设 short 占 2 字节）？
A. 32767
B. 65535
C. 2147483647
D. 255

---
模块三：输入输出 (I/O)
12. 执行 cin >> a; 时，如果你输入了空格，cin 会怎么处理？
A. 将空格读入变量 a。
B. 报错。
C. 忽略前导空格，或者在非字符类型读取中将其视为分隔符停止读取。
D. 读取整行内容。
13. 若要输出 3.14159 并保留 3 位小数（显示 3.142），正确的代码片段是？
A. cout << setprecision(3) << 3.14159;
B. cout << fixed << setprecision(3) << 3.14159;
C. cout << setw(3) << 3.14159;
D. cout << setfill(3) << 3.14159;
14. 转义字符 \n 和操纵符 endl 的主要区别在于？
A. endl 会刷新缓冲区，而 \n 通常只换行。
B. \n 只能用在 printf 中。
C. endl 占用的内存更小。
D. 没有区别。
15. 以下代码的输出结果是？
C++
cout << "12" << setw(4) << "34";
A. 1234  
B. 12  34
C.   1234
D. 120034
16. 要读取一行包含空格的字符串（如 "Hello World"），应使用：
A. cin >> str;
B. scanf("%s", &str);
C. getline(cin, str);
D. cin.get(str);
17. cout << left << setw(5) << 1; 的输出结果是（_表示空格）？
A. ____1
B. 1____
C. 00001
D. 10000

---
模块四：类型转换
18. 表达式 5 / 2 + 5 % 2 的结果是？
A. 3.5
B. 3
C. 4
D. 2.5
19. 下列代码执行后，变量 x 的值是？
C++
double d = 3.99;
int x = (int)d;
A. 4
B. 3
C. 3.99
D. 0
20. int a = 10; double b = 2.5; 表达式 a + b 的结果类型是？
A. int
B. double
C. float
D. long
21. 下列哪个是 C++ 推荐的静态类型转换写法？
A. convert(a, int)
B. (int)a
C. int(a)
D. static_cast<int>(a)
22. 已知 'A' 的 ASCII 码是 65，表达式 (char)('A' + 3) 的结果是？
A. 68
B. 'D'
C. 'C'
D. 编译错误
23. 在混合运算中，C++ 编译器进行隐式转换的原则是？
A. 将所有数据转换为 int。
B. 将所有数据转换为占用内存最小的类型。
C. 尽可能不转换。
D. 将精度低、长度短的数据转换为精度高、长度长的数据。

---
模块五：运算符
24. 以下运算符中优先级最高的是？
A. &&
B. =
C. *
D. ()
25. 若 int x = 5;，表达式 x += x *= 2 执行后，x 的值是？
A. 10
B. 15
C. 20
D. 25
26. 逻辑表达式 (3 > 5) && (x++ > 0) 执行后，关于 x 的变化说法正确的是？
A. x 必定自增。
B. x 必定不自增（短路求值）。
C. x 是否自增取决于编译器。
D. 报错。
27. 算术运算符 % 不能作用于？
A. int
B. short
C. double
D. long
28. int i = 1; cout << i++ << i; 的输出结果最可能是（取决于编译器，但在标准逻辑下）？
A. 1 1
B. 1 2
C. 2 1
D. 2 2
29. 表达式 3 << 2 的值是？
A. 6
B. 9
C. 12
D. 5
30. 逗号表达式 (a=3, b=5, b+a) 的值是？
A. 3
B. 5
C. 8
D. 15

---
第二部分：答案与解析
1. B (Int不是关键字；A中3开头非法；C中void是关键字；D中$非法)
2. B (局部变量未初始化，其值是随机垃圾值，不一定是0)
3. C (大小写敏感意味着大小写不同的标识符是完全不同的)
4. B (const 常量一旦初始化，值不能被修改)
5. B (class是关键字不能用，1开头非法，-非法)
6. C (char 通常 1 字节，short 2 字节)
7. C ("Hello" 是5个字符加上末尾隐藏的 \0，共6字节)
8. B (小数默认为 double，加 f 后缀才是 float)
9. C (true 通常存储为 1，false 为 0)
10. D (注意不带 .h)
11. B ($2^{16}-1 = 65535$)
12. C (cin >> 遇到空格会停止读取当前变量)
13. B (fixed 固定小数点 + setprecision 控制小数位数)
14. A (endl = \n + flush)
15. B (12正常输出，34前补2个空格，总宽4)
16. C (getline 用于读取整行)
17. B (左对齐，右边补空格)
18. B (5/2=2, 5%2=1, 2+1=3)
19. B (浮点转整型，截断小数)
20. B (向高精度 double 对齐)
21. D (static_cast 是 C++ 风格)
22. B (65+3=68 -> 'D')
23. D (宁可浪费空间，不可丢失精度)
24. D (括号优先级最高)
25. C (先算 x*=2 得 x=10，再算 x+=10 得 20)
26. B (&&左边为假，发生短路，右边不执行)
27. C (% 只能用于整数)
28. B (i++ 先输出原值1，然后自增变2，再输出2)
29. C ($3 \times 2^2 = 12$)
30. C (逗号表达式取最后一个式子的值)

---
第三部分：5 道经典编程题
题目 1：温度转换器 (Type Conversion 陷阱)
描述：编写程序，输入华氏温度 $F$，输出摄氏温度 $C$。公式：$C = \frac{5}{9} \times (F - 32)$。结果保留两位小数。
提示：注意整数除法的坑。
参考代码：
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    double f, c;
    cout << "请输入华氏温度: ";
    cin >> f;

    // 关键点：必须写成 5.0 / 9，如果写 5/9 结果是 0
    c = 5.0 / 9 * (f - 32); 

    cout << fixed << setprecision(2);
    cout << "对应的摄氏温度为: " << c << endl;
    return 0;
}
题目 2：时间换算 (Modulo & Division)
描述：输入一个整数表示总秒数（例如 3661），将其换算为 小时:分钟:秒 的格式输出（例如 1:1:1）。
参考代码：
#include <iostream>
using namespace std;

int main() {
    int totalSeconds;
    cout << "请输入总秒数: ";
    cin >> totalSeconds;

    int hours = totalSeconds / 3600;      // 1小时=3600秒
    int minutes = (totalSeconds % 3600) / 60; // 除去小时剩下的秒数算分钟
    int seconds = totalSeconds % 60;      // 剩下的秒数

    cout << hours << ":" << minutes << ":" << seconds << endl;
    return 0;
}
题目 3：数字反转 (Arithmetic Logic)
描述：输入一个三位正整数（如 123），不使用字符串操作，仅利用算术运算符将其反转输出（输出 321）。
参考代码：
#include <iostream>
using namespace std;

int main() {
    int num;
    cout << "请输入一个三位数: ";
    cin >> num;

    int g = num % 10;       // 个位
    int s = num / 10 % 10;  // 十位
    int b = num / 100;      // 百位

    // 重新组合
    int reversed = g * 100 + s * 10 + b;
    
    cout << "反转后的数字: " << reversed << endl;
    return 0;
}
题目 4：海伦公式求三角形面积 (Math Library)
描述：输入三角形三边长 $a, b, c$，计算面积。
公式：$p = (a+b+c)/2$，面积 $S = \sqrt{p(p-a)(p-b)(p-c)}$。
参考代码：
#include <iostream>
#include <cmath> // 必须包含
using namespace std;

int main() {
    double a, b, c;
    cout << "请输入三角形三边长: ";
    cin >> a >> b >> c;

    double p = (a + b + c) / 2.0;
    double area = sqrt(p * (p - a) * (p - b) * (p - c));

    cout << "三角形面积: " << area << endl;
    return 0;
}
题目 5：大小写字母转换 (Char & ASCII)
描述：输入一个小写字母，输出其对应的大写字母。
原理：小写字母的 ASCII 码比大写字母大 32（例如 'a'=97, 'A'=65）。
参考代码：
#include <iostream>
using namespace std;

int main() {
    char lower, upper;
    cout << "请输入一个小写字母: ";
    cin >> lower;

    // 方法1：利用 ASCII 差值
    upper = lower - 32; 
    
    // 方法2（更通用，不用记数字）：upper = lower - ('a' - 'A');

    cout << "对应的大写字母: " << upper << endl;
    return 0;
}

---
🕵️ C++ 代码阅读与分析：20 道综合演练
1. 变量初始化与默认值
阅读下列代码，输出结果可能是？
#include <iostream>
using namespace std;
int g; // 全局变量
int main() {
    int l; // 局部变量
    cout << g << " " << l;
    return 0;
}
A. 0 0
B. 0 随机垃圾值
C. 随机垃圾值 0
D. 编译错误，因为变量未初始化
答案：B
解析：
- 全局变量（在 main 函数外定义的）如果没有手动初始化，编译器默认将其初始化为 0。
- 局部变量（在函数内定义的）如果没有初始化，其值是未定义的（内存中残留的垃圾值）。

---
2. 整数除法的陷阱
阅读下列代码，输出结果是？
double a = 10;
double b = 4;
int c = 4;
cout << a/c << " " << c/a << " " << c/8;
A. 2.5 0.4 0.5
B. 2.5 0 0
C. 2 0 0
D. 2.5 0.4 0
答案：D
解析：
- a/c: double / int -> double / double = 2.5。
- c/a: int / double -> double / double = 0.4。
- c/8: int / int -> 整数除法！4/8 结果为 0（小数被截断）。

---
3. 自增运算符的顺序
阅读下列代码，输出结果是？
int a = 10;
int b = a++; 
int c = ++a; 
cout << b << " " << c;
A. 10 11
B. 10 12
C. 11 12
D. 11 11
答案：B
解析：
1. b = a++: 后置自增。先把 a(10) 赋值给 b，后 a 自增变 11。此时 b=10, a=11。
2. c = ++a: 前置自增。a 先 自增变 12，后 赋值给 c。此时 c=12, a=12。

---
4. 复合赋值运算
阅读下列代码，输出结果是？
int x = 5;
x += x *= 2;
cout << x;
A. 15
B. 20
C. 10
D. 25
答案：B
解析：
赋值运算符从右向左结合。
1. 先算 x *= 2：即 x = x * 2 -> x 变为 10。该表达式返回 10。
2. 再算 x += 10：此时 x 已经是 10 了，即 x = 10 + 10 -> x 变为 20。

---
5. 字符与整数的混合运算
阅读下列代码，输出结果是？
char c = 'A'; // ASCII 65
int i = 5;
cout << (c + i) << " " << (char)(c + i);
A. 70 70
B. F F
C. 70 F
D. A5 F
答案：C
解析：
- c + i: char 提升为 int，65 + 5 = 70。输出整数 70。
- (char)(c + i): 将整数 70 强制转换回字符。ASCII 70 对应的字符是 'F'。

---
6. 逻辑运算的短路特性
阅读下列代码，输出结果是？
int x = 1;
int y = 1;
if (x > 5 && ++y > 1) {
    x++;
}
cout << x << " " << y;
A. 1 2
B. 1 1
C. 2 2
D. 2 1
答案：B
解析：
逻辑与 && 左边 x > 5 (1 > 5) 为 false。由于短路特性，右边的 ++y > 1 根本不会被执行。所以 y 保持为 1，if 块也不执行，x 保持为 1。

---
7. 格式化输出控制
阅读下列代码，输出结果是？
#include <iomanip>
// ... inside main
double pi = 3.14159;
cout << fixed << setprecision(2) << pi << " " << pi;
A. 3.14 3.14159
B. 3.14 3.14
C. 3.14 3.1
D. 3.142 3.142
答案：B
解析：
fixed 和 setprecision 是**粘性（Persistent）**的操纵符。一旦设置，对后续所有的浮点数输出都生效，直到被重置。

---
8. 布尔值的输出
阅读下列代码，输出结果是？
bool b1 = true;
bool b2 = (3 > 5);
cout << b1 << " " << b2 << " " << boolalpha << b1;
A. 1 0 1
B. true false true
C. 1 0 true
D. true 0 true
答案：C
解析：
- 默认情况下，bool 输出为整数：true -> 1, false -> 0。
- boolalpha 开启后，后续输出变为文本形式 "true"。

---
9. 输入流的读取规则
假设用户输入：10 20（中间有一个空格），代码如下：
int a;
double b;
cin >> a >> b;
cout << a << "-" << b;
输出结果是？
A. 10-20
B. 10-20.0 (或编译器默认浮点格式)
C. 10-0
D. 编译错误
答案：A (或 B)
解析： cin >> a 读取 10，遇到空格停止。cin >> b 自动跳过空格，读取 20 并转为 double 类型。输出时 cout 默认可能会去掉小数点后多余的0，显示为 10-20。

---
10. 转义字符的长度
阅读下列代码，输出结果是？
cout << sizeof("a\nb\t");
A. 4
B. 5
C. 6
D. 7
答案：B
解析：
字符串包含：'a', '\n'(1个字符), 'b', '\t'(1个字符)。
可见字符共 4 个。
但是！ 字符串末尾自动隐含一个结束符 '\0'。
所以 sizeof 返回 4 + 1 = 5。

---
11. 位运算基础
阅读下列代码，输出结果是？
int a = 3;  // 二进制 011
int b = 6;  // 二进制 110
cout << (a | b) << " " << (a & b);
A. 3 6
B. 7 2
C. 9 2
D. 7 0
答案：B
解析：
- | (或): 011 | 110 = 111 -> 7。
- & (与): 011 & 110 = 010 -> 2。

---
12. 作用域与变量覆盖
阅读下列代码，输出结果是？
int x = 10;
int main() {
    int x = 5;
    {
        int x = 2;
        cout << x << " ";
    }
    cout << x;
    return 0;
}
A. 2 5
B. 2 10
C. 5 5
D. 2 2
答案：A
解析：
- {} 内部：局部变量 x=2 覆盖了外部的 x，输出 2。
- {} 结束后：内部的 x 销毁，回到 main 函数的作用域，这里的 x 是 5，输出 5。

---
13. 逗号表达式
阅读下列代码，输出结果是？
int a;
int b = (a = 2, a + 3);
cout << a << " " << b;
A. 2 5
B. 2 3
C. 5 5
D. 0 5
答案：A
解析：
1. a = 2：a 变成 2。
2. a + 3：计算 2 + 3 = 5。
3. 逗号表达式返回最后一个式子的值（5），赋值给 b。

---
14. 溢出问题
阅读下列代码，输出结果最可能是？（假设 short 为 16 位有符号）
short s = 32767;
s = s + 1;
cout << s;
A. 32768
B. -32768
C. 0
D. 编译错误
答案：B
解析： short 最大值是 32767。加 1 发生溢出 (Overflow)。在补码表示法中，最大正数加 1 通常会变成最小负数（符号位变为1）。

---
15. 条件（三目）运算符
阅读下列代码，输出结果是？
int a = 5, b = 10;
int m = (a > b) ? a : b;
cout << m;
A. 5
B. 10
C. 0
D. true
答案：B
解析： Condition ? X : Y。如果条件为假（5 > 10 为假），返回 Y 的值，即 b (10)。这常用于求最大值。

---
16. 类型转换的优先级
阅读下列代码，输出结果是？
double d = 4.8;
int i = (int)d + 2.5; 
cout << i;
A. 6
B. 7
C. 6.5
D. 6.0
答案：A
解析：
1. (int)d 优先级高，先执行：4.8 截断为 4。
2. 4 + 2.5 = 6.5。
3. 赋值给 int i：6.5 截断为 6。

---
17. 字符串输入与 getline
用户输入：C++ Programming（回车），代码如下：
string s1, s2;
cin >> s1;
getline(cin, s2); // 注意这里会有前导空格问题
cout << s1 << "|" << s2;
输出结果是？
A. C++|Programming
B. C++| Programming
C. C++|
D. C++ Programming|
答案：B
解析：
- cin >> s1 读取 "C++"，遇到空格停止。空格留在缓冲区。
- getline(cin, s2) 从缓冲区当前位置开始读，读取了空格和 "Programming"，直到遇到回车。
- 所以 s2 的内容其实是 " Programming" (前面有个空格)。

---
18. 逻辑非与关系运算
阅读下列代码，输出结果是？
int a = 0;
cout << (!a == 1);
A. 0
B. 1
C. true (文本)
D. 编译错误
答案：B
解析：
1. !a: a 是 0 (false)，!a 就是 true (1)。
2. 1 == 1: 结果为 true (1)。

---
19. sizeof 的参数
阅读下列代码，输出结果是？
int a = 1;
cout << sizeof(a = 100) << " " << a;
A. 4 100
B. 4 1
C. 1 100
D. 1 1
答案：B
解析：
- sizeof 是编译时运算符。括号内的表达式 a = 100 不会被实际执行，编译器只分析它的类型结果（即 int）。
- 所以 sizeof 输出 4，而 a 的值保持为 1 不变。

---
20. 混合陷阱
阅读下列代码，输出结果是？
unsigned int u = 0;
cout << (u - 1);
A. -1
B. 0
C. 4294967295 (无符号最大值)
D. 编译错误
答案：C
解析： 无符号数永远是非负的。0 - 1 会发生下溢（Underflow），回绕到该类型的最大整数值（全1的二进制位）。这在循环计数条件中是一个常见的 Bug 源头。

---
