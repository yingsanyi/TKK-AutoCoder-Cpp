## 4. 循环结构——程序的“耐力”

当我们想让程序**重复做事情**（比如输出 1 到 100、统计 1000 条数据），不可能一条一条写，这就需要循环。

> 循环 = “只要条件还成立，就一直干下去”。

---

### 4.1 `while` 循环：谨慎的跑者

**口诀：先判断，后执行。**

- 逻辑：  
  1. 先看条件是不是成立；  
  2. 如果成立，就执行一次循环体，然后再回去继续判断；  
  3. 如果一开始条件就不满足，它**一次都不会执行**。

基本结构：

```cpp
while (条件) {
    // 循环体：要重复做的事
    // 记得在这里让“条件”慢慢变成 false，否则就死循环
}
```

#### 4.1.1 场景：重复输入直到合法（输入校验）

- 场景：要求用户输入一个 1–100 之间的分数，不合法就一直让他重输。

```cpp
int score;
cout << "请输入一个 1~100 之间的分数: ";
cin >> score;

while (score < 1 || score > 100) { // 条件不合法就进循环
    cout << "输入不合法，请重新输入 1~100: ";
    cin >> score;
}

cout << "你输入的分数是: " << score << endl;
```

特点：  
- 如果第一次输入就合法，`while` 体一次都不会执行。  
- 很像前门保安：**先检查，再放行**。

#### 4.1.2 场景：从数据库分页拉取数据（简化版）

- 场景：每次从服务器拉 100 条数据，直到“本次拉到的数据数量 < 100”，说明没数据了就停。

```cpp
int page = 1;
int count = fetchPage(page); // 假设返回本页获取到的数据条数

while (count == 100) {
    page++;
    count = fetchPage(page);
}
// 当最后一次获取到的数据不足 100 条时，循环结束
```

#### 【小练习 4.1】

1. 用 `while` 输出从 1 到 5 的所有整数。  
2. 指出这段代码的 bug（逻辑错误）：

```cpp
int i = 1;
while (i <= 5) {
    cout << i << endl;
    // 少了什么？
}
```

**参考答案：**

1.  

```cpp
int i = 1;
while (i <= 5) {
    cout << i << endl;
    i++;              // 别忘了递增
}
```

2. 忘记写 `i++`，`i` 永远是 1，条件 `i <= 5` 一直为真，会导致**死循环**。

---

### 4.2 `do-while` 循环：冲动的跑者

**口诀：先执行，后判断。**

- 逻辑：  
  1. 先不管三七二十一，**先做一次**；  
  2. 做完再检查条件；  
  3. 条件满足就继续做；不满足就停止。

基本结构：

```cpp
do {
    // 循环体：先干一遍
} while (条件); // 注意这里有分号
```

**和 `while` 的核心区别：**  
- `while`：可能一次也不执行；  
- `do-while`：**至少会执行一次**。

#### 4.2.1 场景：登录重试（至少出现一次登录界面）

- 场景：不管怎样，登录界面至少要出现一次；如果登录失败，询问是否重试。

```cpp
bool success = false;
char retry = 'n';

do {
    success = login(); // 假设这是一个尝试登录的函数
    if (!success) {
        cout << "登录失败，是否重试？(y/n): ";
        cin >> retry;
    }
} while (!success && retry == 'y');
```

特点：  
- 登录页面**至少显示一次**。  
- 只有在“登录失败并且用户选择重试”时，才再来一次。

#### 4.2.2 场景：菜单至少显示一次

```cpp
int choice;

do {
    cout << "1. 开始游戏\n";
    cout << "2. 设置\n";
    cout << "3. 退出\n";
    cout << "请选择(1-3): ";
    cin >> choice;

    handle(choice); // 处理选择

} while (choice != 3); // 直到选择 3 才结束
```

不管用户选不选“退出”，菜单**先给你看一遍再说**。

#### 【小练习 4.2】

1. 用 `do-while`，让用户至少输入一次密码，如果密码不是 `"123456"`，就提示“密码错误，请重试”，直到输入正确为止（用伪代码 / 简化版也可以）。  
2. 用一句话说出：`while` 和 `do-while` 最大的区别是什么？

**参考答案要点：**

1. 示意代码：

```cpp
string pwd;

do {
    cout << "请输入密码: ";
    cin >> pwd;
    if (pwd != "123456") {
        cout << "密码错误，请重试" << endl;
    }
} while (pwd != "123456");
```

2. `while` 可能一次都不执行，`do-while` **至少执行一次**。

---

### 4.3 `for` 循环：专业的运动员

最常用的循环形式，**计数清晰、结构紧凑**。

> 格式：`for (起跑线; 终点线; 步频)`

基本结构：

```cpp
for (初始化; 条件; 更新) {
    // 循环体
}
```

就像：

- 初始化：从哪儿开始跑（起点）；
- 条件：什么时候还继续跑（没到终点）；  
- 更新：每圈结束后怎么变化（步长）。

#### 4.3.1 场景：累加求和（1 加到 100）

```cpp
int sum = 0;

for (int i = 1; i <= 100; i++) {
    sum += i; // 相当于 sum = sum + i;
}

cout << "1 到 100 的和是: " << sum << endl;
```

和下面这段 `while` 是等价的，只是 `for` 更紧凑：

```cpp
int sum = 0;
int i = 1;

while (i <= 100) {
    sum += i;
    i++;
}
```

#### 4.3.2 场景：遍历数组/列表

- 场景：有一个成绩数组，想打印出所有成绩并统计平均分。

```cpp
int scores[] = {90, 85, 78, 92, 88};
int n = 5;
int sum = 0;

for (int i = 0; i < n; i++) {
    cout << "第 " << i + 1 << " 个成绩: " << scores[i] << endl;
    sum += scores[i];
}

double avg = sum * 1.0 / n;
cout << "平均分: " << avg << endl;
```

#### 4.3.3 场景：生成简单的星号图形

输出 4 行星号，每行 4 个：

```cpp
for (int i = 1; i <= 4; i++) {        // 控制行数
    for (int j = 1; j <= 4; j++) {    // 控制每行的列数
        cout << "* ";
    }
    cout << endl;
}
```

输出：

```
* * * *
* * * *
* * * *
* * * *
```

#### 【小练习 4.3】

1. 用 `for` 输出 2 到 10 之间的所有偶数。  
2. 用 `for` 求数组 `int a[] = {1, 3, 5, 7, 9};` 的元素总和。

**参考答案：**

1.  

```cpp
for (int i = 2; i <= 10; i += 2) {
    cout << i << " ";
}
cout << endl;
```

2.  

```cpp
int a[] = {1, 3, 5, 7, 9};
int n = 5;
int sum = 0;

for (int i = 0; i < n; i++) {
    sum += a[i];
}
```

---

### 4.4 循环的控制：刹车与跳过

在循环中，有时候我们需要**中途干预**：  
- 提前结束整个循环；  
- 或者跳过当前这一轮，直接进入下一轮。

主要有两个“指令”：

- `break`：**紧急刹车**，直接跳出当前这层循环；  
- `continue`：**跳过本轮剩余代码**，直接进入下一次循环。

#### 4.4.1 `break`：找到目标就停止

场景：在数组中查找某个值，找到就不用再查下去。

```cpp
int a[] = {5, 8, 2, 9, 3};
int n = 5;
int target = 9;
bool found = false;

for (int i = 0; i < n; i++) {
    if (a[i] == target) {
        cout << "在下标 " << i << " 找到目标值 " << target << endl;
        found = true;
        break; // 找到了，直接退出循环
    }
}

if (!found) {
    cout << "没有找到目标值" << endl;
}
```

#### 4.4.2 `continue`：只跳过当前这一轮

场景：统计 1–10 中**除开 5 的数字和**。

```cpp
int sum = 0;

for (int i = 1; i <= 10; i++) {
    if (i == 5) {
        continue;   // 跳过本次循环剩余部分，不执行 sum += i;
    }
    sum += i;
}

cout << "1 到 10（不含 5）的和是: " << sum << endl;
```

#### 4.4.3 `break` 和 `continue` 的区别小结

- `break`：  
  - 结束**当前这层循环**，后面的循环体和后续迭代都不会再执行。  
- `continue`：  
  - 结束本轮循环体，直接进入**下一次迭代**，不会结束整个循环。

#### 【小练习 4.4】

1. 用 `for` + `break` 写一个“从 1 加到 100，但一旦累加和超过 50 就立刻停止”的程序，最后输出“停止时的和”和“停止时加到的最后一个数”。  
2. 用 `for` + `continue` 输出 1 到 20 中**所有不是 3 的倍数**的数字。

**参考答案要点：**

1.  

```cpp
int sum = 0;
int last = 0;

for (int i = 1; i <= 100; i++) {
    sum += i;
    if (sum > 50) {
        last = i;
        break;
    }
}

cout << "停止时的和: " << sum << ", 最后加到: " << last << endl;
```

2.  

```cpp
for (int i = 1; i <= 20; i++) {
    if (i % 3 == 0) {
        continue; // 是 3 的倍数就跳过
    }
    cout << i << " ";
}
cout << endl;
```

---

4.5 for 循环中的变量作用域：在哪儿“看得见”？
在 for 循环里，我们经常这样写：
for (int i = 1; i <= 10; i++) {
    // 使用 i 做计数
}
这里有一个容易被忽视但非常重要的点：
在 for 初始化语句中声明的变量，只在这个 for 循环的内部有效。
4.5.1 作用域是什么？
作用域（scope）：简单理解就是——
这个变量“从哪一行开始能被看到，到哪一行就看不到了”。
在 for (int i = 1; ...) 里声明的 i：
- 只在这个 for 循环的大括号 { ... } 里面能用；
- 循环结束后，i 就“失效”了，外面再用会报错。
4.5.2 错误示例：在循环外使用 i
int s = 0;

for (int i = 1; i <= 10; i++) {
    s += i;
}

cout << "sum = " << s << endl;
cout << "i = " << i << endl;  // ❌ ERROR：这里已经访问不到 i 了
问题说明：
- int i = 1 在 for 里面新建了一个局部变量 i；
- 它的作用域只覆盖整个 for 循环；
- 一旦 for 执行完，i 就被销毁，cout << i 时编译器会提示“未定义的标识符 i”之类的错误。
4.5.3 正确写法 1：只在循环里用 i
如果你只在循环里用 i，循环外根本不需要访问它，那就保持现在的写法即可：
int s = 0;

for (int i = 1; i <= 10; i++) {
    s += i;   // 在这里安全使用 i
}

cout << "sum = " << s << endl; // OK
// 这里不要再用 i
优点：
- i 只在需要的地方存在，外面看不到，命名更干净、不容易冲突。
4.5.4 正确写法 2：循环外也要用 i
如果你确实需要在循环结束后，还知道“循环跑到了第几个”，那就要在循环外先声明 i：
int s = 0;
int i;              // 先在外面声明

for (i = 1; i <= 10; i++) {
    s += i;
}

cout << "sum = " << s << endl;
cout << "循环结束时 i = " << i << endl;  // 这里可以正常使用 i
说明：
- 这里 for (i = 1; i <= 10; i++) 没有再写 int，而是使用了已经声明好的 i；
- 循环结束后，i 仍然在作用域内（在同一个 { ... } 代码块里），可以拿来用。
4.5.5 再举两个小例子
例子 1：统计数组元素，只在循环里用 k
int a[] = {1, 2, 3, 4, 5};
int n = 5;
int sum = 0;

for (int k = 0; k < n; k++) {
    sum += a[k];
}

cout << "sum = " << sum << endl;
// 这里再写 cout << k; 就会编译错误
例子 2：想知道“最后一个下标”
int a[] = {1, 2, 3, 4, 5};
int n = 5;
int sum = 0;
int k;                    // 提前声明

for (k = 0; k < n; k++) {
    sum += a[k];
}

cout << "sum = " << sum << endl;
cout << "循环结束时 k = " << k << endl; // k == n

---
【小练习 4.5】
1. 判断下面代码是否能通过编译？如果不能，错误在哪里？
for (int j = 0; j < 3; j++) {
    cout << j << " ";
}
cout << j << endl;
2. 改写这段代码，使它可以在循环外输出 j 的最终值。
参考答案要点：
1. 不能通过编译：
  - int j = 0 声明的 j 只在 for 循环内部可见；
  - 循环结束后，cout << j 这行访问了一个“已经不在作用域里的变量”，编译器会报错。
2. 一种改法：
int j;                          // 在外面声明

for (j = 0; j < 3; j++) {
    cout << j << " ";
}
cout << endl;
cout << "循环结束时 j = " << j << endl;

---
这一节和后面要讲的“变量的作用域和生命周期”是一脉相承的：
- 现在先记住一句：在 for (int i = ... ) 里声明的 i，只在这个 for 循环里有效，跑完就没了。
