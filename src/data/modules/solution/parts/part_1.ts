import { SolutionData } from '../types';

export const solutions_part1: Record<string, SolutionData> = {
"3973": {
    id: "3973",
    title: "输出-1",
    content: `
> https://www.xujcoj.com/home/problem/detail/3973

**答案：**

\`\`\`cpp
#include<iostream>
using namespace std;

int main()
{
    int n;
    cin >> n; // 读取测试用例的数量

    while (n--)
    {
        int a, b;
        cin >> a >> b; // 读取两个整数

        // 核心逻辑：找出较大的那个数，乘以 2 输出
        // 相当于计算 max(a, b) * 2
        if (a >= b) 
            cout << a * 2 << endl; // 如果 a 大，输出 a 的两倍
        else 
            cout << b * 2 << endl; // 如果 b 大，输出 b 的两倍
    }
    return 0;
}
\`\`\`

**解析：**

#### 1. 分模块思路解析

* **模块一：循环框架 (\`while(n--)\`)**

  * **思路：** 这是一个标准的多组数据处理结构。
  * **逻辑：** 程序首先询问“要比几次”，然后进入循环，每处理完一组，机会 \`n\` 就减少一次，直到为 0。

* **模块二：大小判定 (\`if-else\`)**

  * **思路：** 这是一个简单的决策问题——谁大听谁的。
  * **逻辑：** 比较 \`a\` 和 \`b\` 的大小。我们的目标是“取最大值”，然后对这个最大值进行“翻倍”操作。

#### 2. 关键知识点

| 知识点       | 代码片段         | 说明                                                         |
| :----------- | :--------------- | :----------------------------------------------------------- |
| **条件分支** | \`if (a >= b)...\` | 基础控制流，用于选择执行路径。这里实现了 \`max()\` 函数的逻辑。 |
| **算术运算** | \`a * 2\`          | 基础乘法运算。                                               |
| **多组输入** | \`while (n--)\`    | 竞赛常见写法，控制程序重复执行指定次数。                     |
`
  },
"3974": {
    id: "3974",
    title: "输出-2",
    content: `
> https://www.xujcoj.com/home/problem/detail/3974

**答案：**

\`\`\`cpp
#include<iostream>
using namespace std;

int main()
{
    int n;
    cin >> n; // 读取测试数据的组数

    // 循环处理每一组数据
    while (n--)
    {
        int a, b;
        cin >> a >> b; // 读取两个整数

        // 核心逻辑：计算两个数之间的差值（绝对值）
        // 目的：始终保证输出非负数的结果
        if (a >= b) 
            cout << a - b << endl; // 如果 a 较大，直接用 a 减 b
        else 
            cout << b - a << endl; // 如果 b 较大，反过来用 b 减 a
    }
    return 0;
}
\`\`\`

**解析：**

#### 1. 分模块思路解析

* **模块一：多组数据循环 (\`while(n--)\`)**

  * **思路：** 这是一个标准的“多测试用例”处理结构。
  * **逻辑：** 程序首先询问“有多少组数据”，然后进入循环，每处理完一组，计数器 \`n\` 减 1，直到减为 0 停止。

* **模块二：绝对值逻辑 (\`if...else\`)**

  * **思路：** 模拟数学中的“绝对值”概念，或者计算两点之间的“距离”。
  * **逻辑：** 我们希望得到两个数相差多少，而不关心方向（正负）。

    * 代码手动实现了 \`abs(a - b)\` 的功能：总是用**大数减小数**，确保结果永远是非负的。

* **模块三：独立输出 (\`endl\`)**

  * **思路：** 格式化输出。
  * **逻辑：** 每次计算完结果后立即换行，避免不同测试用例的答案连在一起。

#### 2. 关键知识点

| 知识点         | 代码片段             | 说明                                                         |
| :------------- | :------------------- | :----------------------------------------------------------- |
| **绝对值算法** | \`if(a>=b)...else...\` | 手动实现绝对值函数 \`abs()\` 的逻辑。核心思想是**“大减小”**。 |
| **条件分支**   | \`if...else\`          | 根据数值大小关系选择不同的计算路径（a 减 b 还是 b 减 a）。   |
| **多组输入**   | \`while (n--)\`        | 竞赛题常见模式，用于在一个程序运行中连续处理多组独立的数据。 |
`
  },
"3975": {
    id: "3975",
    title: "输出-3",
    content: `
> https://www.xujcoj.com/home/problem/detail/3975

**答案：**

\`\`\`cpp
#include<iostream>
using namespace std;

int main()
{
    int n;
    cin >> n; // 读取测试数据的组数

    // 循环处理每一组数据
    while (n--)
    {
        int a, b;
        cin >> a >> b; // 读取两个数值

        // 核心逻辑：找出 a 和 b 中较小的那个数，乘以 3 输出
        // 场景推测：类似于“木桶效应”或配对问题，结果取决于短板（较小值）
        if (a >= b) 
            cout << b * 3 << endl; 
        else 
            cout << a * 3 << endl; 
    }
    return 0;
}
\`\`\`

**解析：**

#### 1. 分模块思路解析

* **模块一：多组数据处理 (\`while(n--)\`)**

  * **思路：** 典型的竞赛题目框架。
  * **逻辑：** 只要 \`n\` 不为 0，就进入循环处理下一组数据，处理完后 \`n\` 自动减 1。

* **模块二：逻辑判断 (\`if...else\`)**

  * **思路：** 寻找“短板”。
  * **逻辑：** 无论 \`a\` 和 \`b\` 具体是多少，这段代码的本质是计算 \`min(a, b) * 3\`。

    * 当 \`a\` 比 \`b\` 大（或相等）时，\`b\` 是较小值，计算 \`b * 3\`。
    * 当 \`a\` 比 \`b\` 小时，\`a\` 是较小值，计算 \`a * 3\`。

* **模块三：输出控制 (\`cout << ... << endl\`)**

  * **思路：** 输出计算结果并换行。
  * **逻辑：** 这里的 \`endl\` 必不可少，否则不同测试用例的答案连在一起。

#### 2. 关键知识点

| 知识点             | 代码片段                 | 说明                                                         |
| :----------------- | :----------------------- | :----------------------------------------------------------- |
| **条件分支**       | \`if (a >= b)... else...\` | 基础控制结构，根据条件真假执行不同代码块。这里用于手动实现“取最小值”的逻辑。 |
| **数学逻辑**       | \`min(a, b)\`              | 虽然代码没调用 \`min\` 函数，但通过 \`if\` 判断实现了相同功能。等价于 \`min(a, b) * 3\`。 |
| **局部变量作用域** | \`int a, b;\` 在循环内     | 每次循环重新定义变量，互不干扰。这是一种良好的编程习惯，避免上一轮的数据污染这一轮。 |
`
  },
"1629": {
    id: "1629",
    title: "连续的数字",
    content: `
> [https://www.xujcoj.com/home/problem/detail/1629](https://www.xujcoj.com/home/problem/detail/1629)

**答案：**

\`\`\`
#include <iostream>
using namespace std;

// 简单的排序函数（冒泡排序）
void bubbleSort(int arr[], int n) {
    for(int i = 0; i < n - 1; i++) {
        for(int j = 0; j < n - 1 - i; j++) {
            if(arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

int main() {
    int n;
    cin >> n;
    while(n--) {
        int m;
        cin >> m;

        int nums[1005];
        for(int i = 0; i < m; i++) {
            cin >> nums[i];
        }

        int a;
        cin >> a;

        // 排序
        bubbleSort(nums, m);

        // 去重：将重复的数字标记为一个特殊值
        int unique[1005];
        int uniqueCount = 0;
        unique[0] = nums[0];
        uniqueCount = 1;

        for(int i = 1; i < m; i++) {
            if(nums[i] != nums[i - 1]) {
                unique[uniqueCount] = nums[i];
                uniqueCount++;
            }
        }

        // 检查是否存在a个连续的整数
        bool found = false;
        for(int i = 0; i <= uniqueCount - a; i++) {
            // 检查从i开始的a个数是否连续
            bool consecutive = true;
            for(int j = 0; j < a - 1; j++) {
                if(unique[i + j + 1] != unique[i + j] + 1) {
                    consecutive = false;
                    break;
                }
            }
            if(consecutive) {
                found = true;
                break;
            }
        }

        if(found) {
            cout << "Yes" << endl;
        } else {
            cout << "No" << endl;
        }
    }
    return 0;
}

\`\`\`

**解析：**

1. **题目理解**
    1. **给定 m 个整数**
    2. **判断是否存在 a 个连续的整数**
    3. **连续整数：相差为 1 的整数序列，如 3，4，5，6**
    4. **注意：数组中可能有重复的数字**
2. **算法思路**
    1. **步骤 1**：对 m 个数字排序
    2. **步骤 2**：去重，保留不同的数字
    3. **步骤 3**：检查去重后的数组中是否存在 a 个连续递增的数字
    4. **判断连续**：相邻两个数的差为 1
3. **关键点：为什么需要去重**
    1. **样例 2：**\`5 1 2 1 5 4\`，有重复的 1 和 5
    2. **如果不去重，排序后：**\`1 1 2 4 5 5\`
    3. **检查时会因为两个 1 而误判**
    4. **去重后：**\`1 2 4 5\`，才能正确判断
4. **排序算法（****冒泡排序**）****

\`\`\`
void bubbleSort(int arr[], int n) {
    for(int i = 0; i < n - 1; i++) {
        for(int j = 0; j < n - 1 - i; j++) {
            if(arr[j] > arr[j + 1]) {
                // 交换
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

\`\`\`

1. **去重算法**

\`\`\`
int unique[1005];
int uniqueCount = 0;
unique[0] = nums[0];  // 第一个数直接加入
uniqueCount = 1;

for(int i = 1; i < m; i++) {
    if(nums[i] != nums[i - 1]) {  // 与前一个不同
        unique[uniqueCount] = nums[i];
        uniqueCount++;
    }
}

\`\`\`

1. **检查连续性**

\`\`\`
for(int i = 0; i <= uniqueCount - a; i++) {
    bool consecutive = true;
    for(int j = 0; j < a - 1; j++) {
        if(unique[i + j + 1] != unique[i + j] + 1) {
            consecutive = false;
            break;
        }
    }
    if(consecutive) {
        found = true;
        break;
    }
}

\`\`\`

1. **变量说明**
    1. \`m\`：整数的个数
    2. \`nums[]\`：原始输入的 m 个整数
    3. \`a\`：要找的连续整数的个数
    4. \`unique[]\`：去重后的数组
    5. \`uniqueCount\`：去重后数组的长度
    6. \`found\`：是否找到 a 个连续整数的标志
2. **时间复杂度分析**
    1. **排序：O（m²）（冒泡排序）**
    2. **去重：O（m）**
    3. **检查连续：O（uniqueCount × a），最坏 O（m × a）**
    4. **总时间复杂度：O（m²）**
    5. **对于 m≤1000，完全可以在 2 秒内完成**
3. **样例验证**
    1. **样例 1：5 6 4 10 7 5， a=3**
        * **排序后：4 5 5 6 7 10**
        * **去重后：4 5 6 7 10**
        * **检查： **
        * **i=0: 4，5，6 连续 ✓**
        * **输出：Yes ✓**
    2. **样例 2：5 1 2 1 5 4， a=3**
        * **排序后：1 1 2 4 5 5**
        * **去重后：1 2 4 5**
        * **检查： **
        * **i=0: 1，2，4 不连续（2→4 差 2）**
        * **i=1: 2，4，5 不连续（2→4 差 2）**
        * **输出：No ✓**
4. **注意事项**
    1. **边界条件**：
        * **a=1 时，任何数字都算 1 个连续整数，必定 Yes**
        * **uniqueCount < a 时，不可能有 a 个连续整数**
    2. **数组大小**：声明为 1005，留有余量
    3. **去重的重要性**：必须先去重再检查连续性
    4. **循环范围**：\`i <= uniqueCount - a\` 避免越界
5. **可能的优化**
    1. **特判 a=1**：
    2. \`if(a == 1) {    cout << "Yes" << endl;    continue;}\`
    3. **特判 uniqueCount < a**：
    4. \`if(uniqueCount < a) {    cout << "No" << endl;    continue;}\`
    5. **这些优化可以提前结束，但不是必需的**
6. **完整的算法流程**

\`\`\`
1. 读入m个数字
2. 读入a
3. 对m个数字排序（冒泡排序）
4. 去重，得到uniqueCount个不同的数字
5. 遍历所有可能的起始位置：
- 检查从该位置开始的a个数是否连续
- 如果连续，输出Yes并结束
6. 如果都不连续，输出No

\`\`\`

1. **为什么不用****标准库**
    1. **题目要求不使用 **\`<algorithm>\`
    2. **手写冒泡排序简单可靠**
    3. **对于 m≤1000 的规模，O（m²）完全可接受**
    4. **锻炼基本算法实现能力**
`
  },
"3323": {
    id: "3323",
    title: "星号阵列-17",
    content: `
> https://www.xujcoj.com/home/problem/detail/3323

**答案：**

\`\`\`cpp
#include<iostream>
using namespace std;

int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            if (i >= j || i + j >= n + 1)
            {
                cout << "*";
            }
            else
            {
                cout << " ";
            }
        }
        cout << endl;
    }
    return 0;
}
\`\`\`

**解析：**

#### 1. 分模块思路解析
- 二维遍历：外层控制行 \`i\`，内层控制列 \`j\`，扫描 \`n×n\` 网格
- 区域判定：并集条件
  - \`i >= j\`：主对角线及其下方区域
  - \`i + j >= n + 1\`：副对角线及其下方区域
  - \`||\` 取并集，形成目标填充形状

#### 2. 关键知识点
- 图形坐标：用 \`(行, 列)\` 表示坐标
- 对角线方程：\`i == j\` 主对角线；\`i + j == n + 1\` 副对角线
`
  },
"3397": {
    id: "3397",
    title: "星号阵列-18",
    content: `
> https://www.xujcoj.com/home/problem/detail/3397

**答案：**

\`\`\`cpp
#include<iostream>
using namespace std;

int main()
{
    int n;
    cin >> n; // 读取矩阵的大小（边长）

    // 外层循环控制行号 (i)，从 1 到 n
    for (int i = 1; i <= n; i++)
    {
        // 内层循环控制列号 (j)，从 1 到 n
        for (int j = 1; j <= n; j++)
        {
            // 优先级 1：绘制边框
            // 如果是第一行、最后一行、第一列、最后一列，打印 '*'
            if (i == 1 || i == n || j == 1 || j == n)
            {
                cout << "*";
            }
            // 优先级 2：绘制中间的“十字”分隔线
            // n/2 和 n/2+1 确定了中间的两行和两列，打印 '+'
            else if (i == n / 2 || i == n / 2 + 1 || j == n / 2 || j == n / 2 + 1)
            {
                cout << "+";
            }
            // 优先级 3：填充四个区域（象限）
            // 右上区域：行号小，列号大
            else if (i < n / 2 && j > n / 2)
            {
                cout << 1;
            }
            // 左上区域：行号小，列号小
            else if (i < n / 2 && j < n / 2)
            {
                cout << 2;
            }
            // 左下区域：行号大，列号小
            else if (i > n / 2 && j < n / 2)
            {
                cout << 3;
            }
            // 右下区域：行号大，列号大（剩余情况）
            else
            {
                cout << 4;
            }
        }
        // 每打印完一行后换行
        cout << endl;
    }
    return 0;
}
\`\`\`

**解析：**

#### 1. 分模块思路解析

* **模块一：二维网格遍历 (嵌套 \`for\`)**

  * **思路：** 这是一个典型的图形打印问题。我们需要逐行、逐个像素地扫描一个 \\(n \\times n\\) 的正方形画布。
  * **逻辑：** 外层循环 \`i\` 代表当前的 **y 坐标（行）**，内层循环 \`j\` 代表当前的 **x 坐标（列）**。

* **模块二：图层优先级逻辑 (\`if-else if-else\`)**

  * **思路：** 就像画画一样，上面的颜料会覆盖下面的。这里使用条件判断的顺序来决定“谁覆盖谁”。
  * **逻辑：**

    1. **最顶层（边框）：** 只要碰到边缘（\`i=1\` 等），无条件画 \`*\`。
    2. **次顶层（骨架）：** 如果不是边框，但处于中间的“十字架”位置（\`n/2\` 附近），画 \`+\`。
    3. **底层（填充）：** 如果既不是边框也不是骨架，根据坐标位置填入数字。

* **模块三：象限判定 (坐标比较)**

  * **思路：** 将剩下的空白区域切分为四块。
  * **逻辑：** 利用中心线 \`n/2\` 作为分界线：

    * **行小列小** (\`<, <\`)：左上角 (2)
    * **行小列大** (\`<, >\`)：右上角 (1)
    * **行大列小** (\`>, <\`)：左下角 (3)
    * **行大列大** (\`else\`)：右下角 (4)

#### 2. 关键知识点

| 知识点             | 代码片段                    | 说明                                                         |        |                                  |
| :----------------- | :-------------------------- | :----------------------------------------------------------- | ------ | -------------------------------- |
| **嵌套循环**       | \`for(i...){ for(j...){ } }\` | 处理矩阵、网格或图形打印的核心结构。时间复杂度为 \`O(n^2)\`。  |        |                                  |
| **逻辑优先级**     | \`if...else if...else\`       | 条件的顺序至关重要。排在前面的条件（如边框）具有更高的优先级，会屏蔽掉后面的条件。 |        |                                  |
| **边界判定**       | \`i == 1 \`                   |                                                              | \`i==n\` | 检测当前坐标是否位于矩形的边缘。 |
| **整数除法与定位** | \`n / 2\`                     | 利用整数除法的特性找到矩阵的“中间位置”或“分割线”。           |        |                                  |
`
  },
"3992": {
    id: "3992",
    title: "星号阵列-23",
    content: `
> https://www.xujcoj.com/home/problem/detail/3992

**答案：**

\`\`\`cpp
#include<iostream>
using namespace std;

int main()
{
    int a;
    cin >> a; // 读取初始值

    // 开启一个无限循环，直到满足终止条件才 break
    while (true)
    {
        // 1. 打印当前数量的星号
        for (int i = 0; i < a; i++)
        {
            cout << "*";
        }
        cout << endl;

        // 2. 终止条件检查
        // 如果 a 变成了 1 或 2，游戏结束，跳出循环
        if (a == 1 || a == 2) break;

        // 3. 计算因数个数 (包含 1 和它本身)
        int cnt = 0;
        for (int i = 1; i <= a; i++)
        {
            // 如果 i 能整除 a，说明 i 是 a 的因数
            if (a % i == 0) cnt++;
        }

        // 4. 更新 a 的值
        // 下一轮的 a 变成了当前 a 的因数个数
        a = cnt;
    }
    return 0;
}
\`\`\`

**解析：**

#### 1. 分模块思路解析

* **模块一：可视化输出 (\`cout << "*"\`)**

  * **思路：** 将当前的数字 \`a\` 具象化，数值是多少就打印多少个星号。

* **模块二：计算因数 (\`cnt\`)**

  * **思路：** 这是一个数学变换规则。我们需要找出 \`a\` 有多少个约数。
  * **逻辑：** 暴力遍历 \`1\` 到 \`a\` 的所有数字，试探能不能整除 \`a\`。如果能，计数器 \`cnt\` 加 1。例如 \`a=10\`，因数有 1, 2, 5, 10，共 4 个。

* **模块三：状态迭代与终止 (\`a = cnt\`)**

  * **思路：** 这是一个“数字黑洞”类的游戏。数字会不断变小（通常情况），直到无法再变。
  * **逻辑：** 把刚才算出的因数个数 \`cnt\` 赋值给 \`a\`，进入下一轮。当 \`a\` 降到 1 或 2 时停止（因为 1 的因数是 1，2 的因数是 2，会陷入死循环，所以需强制终止）。

#### 2. 关键知识点

| 知识点           | 代码片段                  | 说明                                             |
| :--------------- | :------------------------ | :----------------------------------------------- |
| **因数计数**     | \`if (a % i == 0) cnt++\`   | 数论基础。统计一个整数的所有正约数个数。         |
| **死循环与中断** | \`while(true)\` ... \`break\` | 构造不确定次数的循环，内部通过条件判断手动跳出。 |
| **序列迭代**     | \`a = cnt\`                 | 程序的当前状态依赖于上一轮的计算结果。           |
`
  },
"2541": {
    id: "2541",
    title: "除法",
    content: `
> https://www.xujcoj.com/home/problem/detail/2541

**答案：**

\`\`\`cpp
#include<iostream>
using namespace std;
int main()
{
    int a, b;
    cin >> a >> b;
    if (a % b == 0)
    {
        cout << a << "/" << b << "=" << a / b;
    }
    else
    {
        cout << a << "/" << b << "=" << a / b << "......" << a % b;
    }
    return 0;
}
\`\`\`

**解析：**

#### 1. 题目要点
- 输入两个整数 \`a\`、\`b\`，输出整除或带余数的格式化结果
- 输出格式：
  - 整除：\`a/b=商\`
  - 不整除：\`a/b=商......余数\`

#### 2. 模块化思路
- 整除判断（\`%\`）：
  - \`a % b == 0\` 表示能整除
- 分类输出：
  - 能整除：输出商
  - 不能整除：输出商与余数，间隔为 \`......\`

#### 3. 关键知识点
- 取模运算：\`a % b\` 得到余数
- 整数除法：\`a / b\` 取整得到商（C++ 向下取整）
`
  },
"4310": {
    id: "4310",
    title: "星号阵列27",
    content: `
> https://www.xujcoj.com/home/problem/detail/4310

**答案：**

\`\`\`cpp
#include<iostream>
using namespace std;
int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            if (i == 1 || i == n || j == 1 || j == n || 
                i + j == (n + 1) / 2 + 1 || 
                i + j == (n + 1) / 2 + n || 
                i - j == 1 - (n + 1) / 2 || 
                i - j == (n + 1) / 2 - 1)
            {
                cout << "*";
            }
            else
            {
                cout << " ";
            }
        }
        cout << endl;
    }
    return 0;
}
\`\`\`

**解析：**

#### 1. 代码与规范注释
- 双重循环遍历正方形网格，外框与菱形由直线方程组合判定
- 条件满足打印 \`*\`，否则打印空格

#### 2. 分模块思路解析
- 模块一：外框绘制
  - 逻辑：\`i==1\`、\`i==n\`、\`j==1\`、\`j==n\` 四条边
- 模块二：内部菱形绘制（直线方程）
  - 逻辑：四条直线方程
    - \`i + j = 常数\`（反对角线方向）
    - \`i - j = 常数\`（主对角线方向）
    - 中点 \`mid = (n + 1) / 2\`，连接四边中点

#### 3. 关键知识点
- 直线方程应用：\`i + j == ...\` 与 \`i - j == ...\`
- 中点公式：\`(n + 1) / 2\` 为中心位置（整数运算）
`
  },
"2539": {
    id: "2539",
    title: "反向输出四位数",
    content: `
> [https://www.xujcoj.com/home/problem/detail/2539](https://www.xujcoj.com/home/problem/detail/2539)

**答案：**

\`\`\`cpp
#include<iostream>
using namespace std;

int main(){
    int n;
    cin >> n;
    
    while(n){
        cout << n % 10;
        n /= 10;
    }
    
    return 0;
}
\`\`\`

**或使用字符串：**

\`\`\`cpp
#include<iostream>
#include<string>
using namespace std;

int main(){
    string s;
    cin >> s;
    
    for(int i = s.length() - 1; i >= 0; i--){
        cout << s[i];
    }
    
    return 0;
}
\`\`\`

**解析**：

**核心思路**：从后往前逐位输出

**方法1 - 取模法**：

\`\`\`
输入：1280

n % 10 = 0 → 输出0，n变为128
n % 10 = 8 → 输出8，n变为12
n % 10 = 2 → 输出2，n变为1
n % 10 = 1 → 输出1，n变为0

输出：0821
\`\`\`

**方法2 - 字符串法**：

\`\`\`
输入："1280"
从索引3到0倒序输出：s[3]=0, s[2]=8, s[1]=2, s[0]=1
输出：0821
\`\`\`

**典型例子**：

\`\`\`
1000 → 0001（保留前导0）
9876 → 6789
5005 → 5005（回文数）
\`\`\`

**易错点**：

❌ **错误1：先计算反转整数再输出**

\`\`\`cpp
int reversed = 0;
while(n){
    reversed = reversed * 10 + n % 10;
    n /= 10;
}
cout << reversed;  // 1280 → 821（丢失前导0）
\`\`\`

❌ **错误2：多余换行**

\`\`\`cpp
cout << n % 10 << endl;  // 题目要求不换行
\`\`\`

**关键点**：

- 逐位输出自动保留前导0
- 不换行
`
  }
};
