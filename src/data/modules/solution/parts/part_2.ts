import { SolutionData } from '../types';

export const solutions_part2: Record<string, SolutionData> = {
"2770": {
    id: "2770",
    title: "菱形阵列",
    content: `
> https://www.xujcoj.com/home/problem/detail/2770

**解析**：

**核心思路**：菱形 = 上半部分（含中间行）+ 下半部分

**样例分析**（m=4）：

\`\`\`
   *        行1: 3空格 + * + 0空格
  * *       行2: 2空格 + * + 1空格 + *
 *   *      行3: 1空格 + * + 3空格 + *
*     *     行4: 0空格 + * + 5空格 + *（中间行）
 *   *      行5: 1空格 + * + 3空格 + *
  * *       行6: 2空格 + * + 1空格 + *
   *        行7: 3空格 + * + 0空格
\`\`\`

**规律总结**：

对于第 i 行（1 ≤ i ≤ m，上半部分）：

- 前导空格数：\`m - i\`
- 星号间空格数：\`2*i - 3\`（i=1时为0）
- 总宽度：\`2*i - 1\`

对于下半部分：倒序输出第 1 到 m-1 行

**具体实现**：

\`\`\`
第i行输出流程：
1. 输出 (m-i) 个空格
2. 输出第一个 *
3. 如果不是第一行：
   - 输出 (2*i-3) 个空格
   - 输出第二个 *
4. 换行
\`\`\`

**典型例子**：

**m=2**：

\`\`\`
 *
* *
 *
\`\`\`

**m=3**：

\`\`\`
  *
 * *
*   *
 * *
  *
\`\`\`

**m=5**：

\`\`\`
    *
   * *
  *   *
 *     *
*       *
 *     *
  *   *
   * *
    *
\`\`\`

**易错点**：

❌ **错误1：行末多余空格**

\`\`\`cpp
for(int j = 1; j <= 2 * i - 1; j++){
    if(j == 1 || j == 2 * i - 1)
        cout << "*";
    else
        cout << " ";
}
// 正确：只在需要的位置输出空格
\`\`\`

❌ **错误2：输出实心菱形**

\`\`\`cpp
for(int j = 1; j <= 2 * i - 1; j++){
    cout << "*";  // 错误：全部输出星号
}
// 应该只在两端输出星号
\`\`\`

❌ **错误3：下半部分包含中间行**

\`\`\`cpp
for(int i = m; i >= 1; i--)  // 错误：重复输出中间行
// 应该：for(int i = m - 1; i >= 1; i--)
\`\`\`

❌ **错误4：第一行输出两个星号**

\`\`\`cpp
if(j == 1 || j == 2 * i - 1){
    cout << "*";
}
// 当i=1时，2*i-1=1，只有一个星号位置，这是正确的
// 但要注意条件判断：j==1 且 j==2*i-1同时成立时只输出一次
\`\`\`

**关键点**：

- 空心菱形只在两端输出星号
- 每行末尾不能有多余空格
- 下半部分不包含中间行（从m-1开始）
- 第一行只有一个星号
`,
    answers: [
      {
        label: "基础解法",
        content: `\`\`\`cpp
#include<iostream>
using namespace std;

int main(){
    int m;
    cin >> m;
    
    // 上半部分（包括中间行）
    for(int i = 1; i <= m; i++){
        // 输出前导空格
        for(int j = 1; j <= m - i; j++){
            cout << " ";
        }
        
        // 输出星号
        for(int j = 1; j <= 2 * i - 1; j++){
            if(j == 1 || j == 2 * i - 1){
                cout << "*";  // 两端的星号
            } else {
                cout << " ";  // 中间的空格
            }
        }
        cout << endl;
    }
    
    // 下半部分
    for(int i = m - 1; i >= 1; i--){
        // 输出前导空格
        for(int j = 1; j <= m - i; j++){
            cout << " ";
        }
        
        // 输出星号
        for(int j = 1; j <= 2 * i - 1; j++){
            if(j == 1 || j == 2 * i - 1){
                cout << "*";  // 两端的星号
            } else {
                cout << " ";  // 中间的空格
            }
        }
        cout << endl;
    }
    
    return 0;
}
\`\`\``
      },
      {
        label: "优化写法",
        content: `\`\`\`cpp
#include<iostream>
using namespace std;

int main(){
    int m;
    cin >> m;
    
    // 上半部分
    for(int i = 1; i <= m; i++){
        for(int j = 1; j <= m - i; j++) cout << " ";
        cout << "*";
        if(i > 1){
            for(int j = 1; j <= 2 * i - 3; j++) cout << " ";
            cout << "*";
        }
        cout << endl;
    }
    
    // 下半部分
    for(int i = m - 1; i >= 1; i--){
        for(int j = 1; j <= m - i; j++) cout << " ";
        cout << "*";
        if(i > 1){
            for(int j = 1; j <= 2 * i - 3; j++) cout << " ";
            cout << "*";
        }
        cout << endl;
    }
    
    return 0;
}
\`\`\``
      }
    ]
  },
"2583": {
    id: "2583",
    title: "等差数列 -2",
    content: `
> [https://www.xujcoj.com/home/problem/detail/2583](https://www.xujcoj.com/home/problem/detail/2583)

**答案：**

\`\`\`
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    while(n--) {
        long long a, b, c, x;
        cin >> a >> b >> c >> x;

        // 计算公差
        long long d = b - a;

        // 特判：检查公差是否一致（验证是否为等差数列）
        // 实际题目保证是等差数列，这步可省略
        // if(c - b != d) { ... }

        // 如果公差<=0，数列不递增
        if(d <= 0) {
            // 检查第一项是否大于x
            if(a > x) {
                cout << 1 << endl;
            } else {
                cout << -1 << endl;
            }
        } else {
            // 公差>0，数列递增
            // 第n项：an = a + (n-1)*d
            // 要找最小的n使得 a + (n-1)*d > x
            // 即 (n-1)*d > x - a
            // 即 n-1 > (x - a) / d
            // 即 n > (x - a) / d + 1

            if(a > x) {
                // 第一项就满足
                cout << 1 << endl;
            } else {
                // 计算需要第几项
                // n > (x - a) / d + 1
                // n >= floor((x - a) / d) + 2

                long long diff = x - a;
                long long k = diff / d;  // 向下取整

                // 验证第k+1项是否满足
                long long item = a + k * d;
                if(item > x) {
                    cout << k + 1 << endl;
                } else {
                    cout << k + 2 << endl;
                }
            }
        }
    }
    return 0;
}

\`\`\`

**解析**：

1. **题目理解**
    1. **给定等差数列的前三项 a、b、c**
    2. **等差数列通项公式：**a_n = a_1 + （n-1）d**，其中 d 是公差**
    3. **找到第一个大于 x 的项的序号**
    4. **如果不存在这样的项，输出 -1**
2. **数学分析**
    1. **公差计算**：**d = b - a = c - b**
    2. **通项公式**：**a_n = a + （n-1）d**
    3. **目标**：找最小的 n 使得 **a_n > x**
    4. **不等式求解**： **a + （n-1）d > x**（n-1）d > x - a**n - 1 > \\frac{x-a}{d}**n > \\frac{x-a}{d} + 1
3. **分类讨论**
    1. **情况 1：公差 d ≤ 0**（数列不递增）
        * **如果 **a > x**，第 1 项就满足，输出 1**
        * **如果 **a \\leq x**，数列越来越小，永远不会大于 x，输出 -1**
    2. **情况 2：公差 d > 0**（数列递增）
        * **如果 **a > x**，第 1 项就满足，输出 1**
        * **否则通过公式计算第几项开始大于 x**
4. **公差为正时的计算方法**
    1. **设 **diff = x - a**（差值）**
    2. **计算 **k = \\lfloor\\frac{diff}{d}\\rfloor**（向下取整）**
    3. **第 **k+1** 项：**a_{k+1} = a + k \\cdot d
    4. **判断逻辑**：
        * **如果 **a + k \\cdot d > x**，答案是 **k+1
        * **否则答案是 **k+2
    5. **原因**：整数除法自动向下取整，需要验证边界
5. **代码实现细节**
    1. **数据类型**：使用 \`long long\`，因为范围在 **\\pm 5 \\times 10^8**
    2. **公差计算**：**d = b - a**
    3. **特判第一项**：如果 **a > x**，直接输出 1
    4. **整数除法处理**：
        * **C++中整数除法自动向下取整**
        * **需要验证计算出的项是否真的满足条件**
    5. **边界验证**：
        * **计算 **item = a + k \\cdot d
        * **如果 **item > x**，答案是 **k+1
        * **否则答案是 **k+2
6. **变量说明**
    1. \`a, b, c\`：等差数列的前三项
    2. \`x\`：目标值
    3. \`d\`：公差
    4. \`diff\`：**x - a** 的差值
    5. \`k\`：通过整数除法计算的商
    6. \`item\`：第 **k+1** 项的值
7. **时间复杂度分析**
    1. **每组 case 只需 O（1）的计算**
    2. **总时间复杂度：O（n）**
8. **样例验证**
    1. **样例 1：4 5 6 7**
        * **公差：**d = 5 - 4 = 1
        * **第 1 项：4 ≤ 7**
        * **diff = 7 - 4 = 3**
        * **k = 3 / 1 = 3**
        * **第 4 项：**a_4 = 4 + 3 \\times 1 = 7**（不大于 7）**
        * **第 5 项：**a_5 = 4 + 4 \\times 1 = 8 > 7** ✓**
        * **输出：5 ✓**
    2. **样例 2：9 7 5 10**
        * **公差：**d = 7 - 9 = -2 < 0
        * **第 1 项：9 ≤ 10**
        * **数列递减，不可能大于 10**
        * **输出：-1 ✓**
    3. **样例 3：10 20 30 15**
        * **公差：**d = 20 - 10 = 10
        * **第 1 项：10 ≤ 15**
        * **diff = 15 - 10 = 5**
        * **k = 5 / 10 = 0**
        * **第 1 项：**a_1 = 10 + 0 \\times 10 = 10**（不大于 15）**
        * **第 2 项：**a_2 = 10 + 1 \\times 10 = 20 > 15** ✓**
        * **输出：2 ✓**
9. **注意事项**
    1. **整数除法陷阱**：
        * **负数除法在不同语言可能有不同行为**
        * **本题中 **x - a** 可能为负，需要小心处理**
        * **当 **a > x** 时直接返回 1，避免除法问题**
    2. **溢出风险**：
        * **（n-1） \\times d** 可能溢出
        * **使用** \`long long\`并且先判断特殊情况
    3. **公差为 0**：
        * **如果 **d = 0**，数列是常数列**
        * **归入 **d \\leq 0** 的情况处理**
    4. **边界情况**：
        * **第一项就满足**
        * **数列递减永远不满足**
        * **x** 为负数或很大的正数
10. **更详细的算法流程**

\`\`\`
1. 读入 a, b, c, x
2. 计算公差 d = b - a
3. 如果 d <= 0:
如果 a > x: 输出 1
否则: 输出 -1
4. 否则 (d > 0):
如果 a > x: 输出 1
否则:
计算 k = (x - a) / d
计算第 k+1 项的值
如果第 k+1 项 > x: 输出 k+1
否则: 输出 k+2

\`\`\`

1. **为什么需要验证边界**
    1. **整数除法会自动截断小数部分**
    2. **例如：**（x-a）/d = 3.7**，整数除法得到 3**
    3. **需要检查第 4 项（k+1=4）是否满足**
    4. **如果恰好 **a + 3d = x**，则需要第 5 项（k+2=5）**
    5. **通过实际计算第 k+1 项的值来准确判断**
2. **优化提示**
    1. **可以用数学公式直接计算： **n = \\lfloor\\frac{x-a}{d}\\rfloor + 2
    2. **但需要特别处理恰好整除的情况**
    3. **当前方法通过验证更加稳妥可靠**
`
  },
"2874": {
    id: "2874",
    title: "互质的数量",
    content: `
> [https://www.xujcoj.com/home/problem/detail/2874](https://www.xujcoj.com/home/problem/detail/2874)

**答案：**

\`\`\`
#include <iostream>
using namespace std;

long long phi(long long m) {
    long long res = m;
    for(long long i = 2; i * i <= m; i++) {
        if(m % i == 0) {
            while(m % i == 0) m /= i;
            res = res / i * (i - 1);
        }
    }
    if(m > 1) res = res / m * (m - 1);
    return res;
}

int main() {
    int n;
    cin >> n;
    while(n--) {
        long long m;
        cin >> m;
        if(m == 1) {
            cout << 0 << endl;
        } else {
            cout << phi(m) << endl;
        }
    }
    return 0;
}

\`\`\`

**解析**：

**可能的误区**

1. **你可能遇到 m=1 的极端输入。**
    1. **按定义 phi（1）=1，但“小于 1”的正整数是 0 个，所以本题应特判 m=1 时输出 0。**

* **本题就是考查欧拉函数的计算，唯一要注意的就是 m=1 时输出 0。**
* **你可以重新测试下如 m=1、2、3...的样例，就明白了！**
`
  },
"2899": {
    id: "2899",
    title: "各位数字的乘积",
    content: `
> [https://www.xujcoj.com/home/problem/detail/2899](https://www.xujcoj.com/home/problem/detail/2899)

**答案：**

\`\`\`
#include <iostream>
using namespace std;

int main() {
    int T;
    cin >> T;
    while(T--) {
        long long N;
        cin >> N;

        // 特殊情况：N=0
        if(N == 0) {
            cout << 10 << endl;
            continue;
        }

        // 特殊情况：N=1
        if(N == 1) {
            cout << 1 << endl;
            continue;
        }

        // 统计每个数字(2-9)需要的个数
        int count[10] = {0};
        long long temp = N;

        // 从9到2进行质因数分解
        for(int d = 9; d >= 2; d--) {
            while(temp % d == 0) {
                count[d]++;
                temp /= d;
            }
        }

        // 如果temp不为1，说明N包含大于9的质因数
        // 或者包含质因数不在2-9范围内，无法用单个数字表示
        if(temp != 1) {
            cout << -1 << endl;
            continue;
        }

        // 从小到大输出数字，组成最小的Q
        for(int d = 2; d <= 9; d++) {
            for(int i = 0; i < count[d]; i++) {
                cout << d;
            }
        }
        cout << endl;
    }
    return 0;
}

\`\`\`

**解析：**

1. **题目理解**
    1. **给定整数 N**
    2. **找最小正整数 Q，使得 Q 各位数字的乘积等于 N**
    3. **如果不存在，输出 -1**
2. **关键思路**
    1. **目标**：将 N 分解成单个数字（1-9）的乘积
    2. **策略**：用尽可能少的数字，且数字尽可能小
    3. **方法**：将 N 分解质因数，然后组合成 1-9 的数字
3. **为什么从 9 到 2 分解**
    1. **贪心策略**：优先用大的数字（9，8，7...)
    2. **原因 1**：减少数字个数
        * **例如：N=8**
        * **用 2：2×2×2（3 位）**
        * **用 8：8（1 位）✓**
    3. **原因 2**：得到更小的 Q
        * **相同位数时，小数字在前面**
        * **从小到大输出：2，3，4，5，6，7，8，9**
        * **所以先用 9 分解，再用 8，...**
4. **特殊情况处理**
    1. **N=0**:
        * **任何数字（1-9）乘积都≥1，无法得到 0**
        * **但 0 只能用"10"表示（1×0=0）**
        * **输出：10**
    2. **N=1**:
        * **最小的正整数是 1**
        * **1 的各位数字乘积是 1**
        * **输出：1**
5. **分解过程**

\`\`\`
for(int d = 9; d >= 2; d--) {
    while(temp % d == 0) {
        count[d]++;
        temp /= d;
    }
}

\`\`\`

1. **无解判断**

\`\`\`
if(temp != 1) {
    cout << -1 << endl;
    continue;
}

\`\`\`

1. **构造最小 Q**

\`\`\`
for(int d = 2; d <= 9; d++) {
    for(int i = 0; i < count[d]; i++) {
        cout << d;
    }
}

\`\`\`

1. **样例验证**
    1. **样例：N=10**
        * **10 = 2 × 5**
        * **count[2]=1, count[5]=1**
        * **输出：25 ✓**
        * **验证：2×5=10 ✓**
2. **更多****测试用例**
    1. **测试 1：N=24**
        * **24 = 2³ × 3**
        * **从 9 到 2 分解： **
        * **9: 24%9≠0**
        * **8: 24%8=0 → 24/8=3, count[8]=1, temp=3**
        * **7，6，5，4：跳过**
        * **3: 3%3=0 → 3/3=1, count[3]=1, temp=1**
        * **输出：38**
        * **验证：3×8=24 ✓**
    2. **测试 2：N=0**
        * **特殊情况**
        * **输出：10**
        * **验证：1×0=0 ✓**
    3. **测试 3：N=1**
        * **特殊情况**
        * **输出：1**
        * **验证：1=1 ✓**
    4. **测试 4：N=13**
        * **13 是质数，>9**
        * **分解后 temp=13≠1**
        * **输出：-1 ✓**
3. **为什么这样是最小的**
    1. **位数最少**：
        * **用大数字（9，8，7...）分解，减少位数**
        * **例如：2×2×2=8 vs 8，后者位数少**
    2. **数字最小**：
        * **从小到大排列：2，3，4，...,9**
        * **例如：2×5=10，输出 25 而不是 52**
4. **变量说明**
    1. \`N\`：输入的整数
    2. \`count[d]\`：需要数字 d 的个数
    3. \`temp\`：当前剩余的值
    4. \`d\`：当前尝试分解的数字
5. **时间复杂度分析**
    1. **分解循环：最多 log（N）次除法**
    2. **对每个数字 2-9：O（8 × log（N））**
    3. **输出：O（总数字个数） ≤ O（log（N））**
    4. **总时间复杂度：O（log（N））**
    5. **对于 N≤10⁹，完全可以接受**
6. **空间复杂度分析**
    1. **count 数组：O（10） = O（1）**
    2. **几个变量：O（1）**
    3. **总空间复杂度：O（1）**
7. **数学原理**
    1. **合数分解**：
        * **2，3，5，7 是质数**
        * **4=2², 6=2×3, 8=2³, 9=3²**
    2. **最优分解**：
        * **优先用 9（3²）而不是 3×3**
        * **优先用 8（2³）而不是 2×2×2**
        * **优先用 6（2×3）而不是 2×3**
    3. **贪心正确性**：
        * **用更大的数字 → 位数更少**
        * **位数相同时，小数字在前 → 数值更小**
8. **为什么 N=0 输出 10**
    1. **0 不能由 1-9 的乘积得到（最小是 1）**
    2. **必须包含数字 0**
    3. **最小的包含 0 的正整数是 10**
    4. **10 的各位数字乘积：1×0=0 ✓**
9. **完整的算法流程**

\`\`\`
1. 读入N
2. 特判N=0，输出10
3. 特判N=1，输出1
4. 初始化count数组为0
5. 从9到2分解N：
a. 尽可能多地除以当前数字
b. 记录使用次数
6. 如果分解后剩余值≠1，输出-1
7. 从2到9输出对应个数的数字
8. 换行

\`\`\`

1. **为什么不用 1 分解**
    1. **1 乘以任何数都是该数本身**
    2. **不改变乘积的值**
    3. **但会增加位数，使 Q 变大**
    4. **所以不使用 1**
2. **注意事项**
    1. **N=0 的特殊性**：
        * **唯一需要数字 0 的情况**
        * **最小是 10，不是 0（0 不是正整数）**
    2. **分解顺序**：
        * **必须从大到小（9→2）**
        * **确保位数最少**
    3. **输出顺序**：
        * **必须从小到大（2→9）**
        * **确保数值最小**
    4. **数据类型**：
        * **N≤10⁹，用 **\`long long\` 安全
3. **常见错误**
    1. **❌ 忘记处理 N=0 的特殊情况**
    2. **❌ 从 2 到 9 分解（导致位数多）**
    3. **❌ 从 9 到 2 输出（导致数值大）**
    4. **❌ 忘记判断 temp≠1 的无解情况**
    5. **❌ 认为 N=0 输出 -1 或 0**
    6. **✓ 从 9 到 2 分解，从 2 到 9 输出**
4. **优化说明**
    1. **本算法已经是最优解**
    2. **时间复杂度：O（log（N））**
    3. **空间复杂度：O（1）**
    4. **无需进一步优化**

**这道题巧妙地结合了贪心策略和数论知识，关键在于理解"最小"的两层含义：位数最少+数值最小。**
`
  },
"2974": {
    id: "2974",
    title: "出土",
    content: `
> [https://www.xujcoj.com/home/problem/detail/2974](https://www.xujcoj.com/home/problem/detail/2974)

**答案：**

\`\`\`
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n; // 案例数
    for(int kase = 0; kase < n; kase++) {
        int a, c;
        double b;
        cin >> a >> b >> c;
        double temp[2000005];
        for(int i = 0; i < c; i++) {
            cin >> temp[i];
        }
        int day = -1;
        // 对每一天，从第 a 天检查是否达标（连续 a 天不小于 b）
        for(int i = a - 1; i < c; i++) {
            bool ok = true;
            for(int j = i - a + 1; j <= i; j++) {
                if(temp[j] < b) {
                    ok = false;
                    break;
                }
            }
            if(ok) {
                day = i + 1; // 下标0起，所以加1
                break;
            }
        }
        cout << day << endl;
    }
    return 0;
}

\`\`\`

**解析**：

1. **整体思路**：
    1. **对每组案例，先输入参数** \`a\`（连续天数）、\`b\`（温度下限）、\`c\`（天数），后面读取 \`c\`天温度。
    2. **我们需要找****第一个连续 a 天全部不少于 b** 的区间，并输出这 a 天最后一天的编号（即钻出地面的天数）。
    3. **如果所有 c 天温度都不满足要求，输出 -1。**
2. **输入处理**：
    1. **用数组** \`temp[]\`存放每天温度，输入时注意浮点数输入。
3. **查找满足条件的区间**：
    1. **枚举检查，从第 a-1 天（下标）开始，每次向前找到 a 个温度，判断是否都大于等于 b。**
    2. **判断方式是循环检查，如果有任何一天温度小于 b，标记不成立（**\`ok=false\`），立即 break。
    3. **一旦找到一组满足的，把该天编号赋值给变量** \`day\`（记得从 0 起要加 1），立即 break 退出查找。
4. **输出说明**：
    1. **如有找到，直接输出最后一天编号。**
    2. **如果所有天都没找到，**\`day\`保持 -1，最后输出 -1。
    3. **每组案例结果各占一行。**
5. **边界处理与效率**：
    1. **温度判断采用滑动窗口查找，最大 200 万也可通过（用最基础嵌套循环写法，效率够题目的测试数据）。**
    2. **数组大小按最大 2,000,000 设定，保证极端输入不越界。**

**你指出上一题的答案有误。确实存在问题：**

* \`maxProduct\`初始化为 \`0\`是不妥的，因为所有乘积都可能是负数或 0。如样例所示，可能出现最大乘积为负数的情况。
* **正确写法应当直接用 bool 判断是否为首组，无需 maxProduct 初值为 0。**

**我们应该将 maxProduct 初始化为一个很小的数（或者用 bool flag 判首次赋值）。 下面是****修正后的标准答案**以及详细解析！
`
  },
"3019": {
    id: "3019",
    title: "ax+b=c",
    content: `
> [https://www.xujcoj.com/home/problem/detail/3019](https://www.xujcoj.com/home/problem/detail/3019)

**答案：**

\`\`\`
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n; // 案例数
    for(int kase = 0; kase < n; kase++) {
        int a, b, c;
        cin >> a >> b >> c;
        // 方程ax + b = c，转化为 ax = c - b，即 x = (c - b) / a
        if(a == 0) {
            if(b == c) {
                // 0x + b = b，x可取任意值，此时最小正整数解为1
                cout << 1 << endl;
            } else {
                // 0x + b = c，b!=c，无解
                cout << "None" << endl;
            }
        } else {
            int right = c - b;
            if(right % a == 0) {
                int x = right / a;
                // 唯一解
                cout << x << endl;
            } else {
                cout << "None" << endl;
            }
        }
    }
    return 0;
}

\`\`\`

**解析**：

1. **题目分析**
    1. **题意为解一元一次方程 （ ax + b = c ）。**
    2. **情况 1：a=0 **
        * **若 b=c，则方程为 0x+b=b，即任意 x 都满足。不止一个解，输出“最小正整数解 1”。**
        * **若 b≠c，则无解，输出 None。**
    3. **情况 2：a≠0 **
        * **( x = \\frac{c-b}{a} )**
        * **若（c-b）能整除 a，则唯一整数解。**
        * **否则无整数解，输出 None。**
2. **实现流程**
    1. **输入 a， b， c 后，判断 a 是否为 0。**
    2. **若 a**=0，判断 b=c，否则无解。
    3. **若 a≠0，先判断能否整除，能则输出计算出来的 x，不能输出 None。**
3. **边界细节**
    1. **要输出“最小正整数解”，只发生在无穷多解（即 a=0 且 b=c），此时最小正整数为 1。**
    2. **唯一解不要求正负，都输出。**
4. **输入输出保证**
    1. **案例间每行一个结果，严格按题意。**
`
  },
"3204": {
    id: "3204",
    title: "校庆日",
    content: `
> [https://www.xujcoj.com/home/problem/detail/3204](https://www.xujcoj.com/home/problem/detail/3204)

**答案：**

\`\`\`
#include <iostream>
using namespace std;

// 每个月的天数（非闰年）
int daysInMonth[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

// 判断日期date(月份m1,日期d1)是否在范围[a月b日, c月d日]内
bool inRange(int m1, int d1, int a, int b, int c, int d) {
    // 将日期转换为年内第几天进行比较
    int date1 = 0, dateA = 0, dateC = 0;

    for(int i = 1; i < m1; i++) date1 += daysInMonth[i];
    date1 += d1;

    for(int i = 1; i < a; i++) dateA += daysInMonth[i];
    dateA += b;

    for(int i = 1; i < c; i++) dateC += daysInMonth[i];
    dateC += d;

    return date1 >= dateA && date1 <= dateC;
}

int main() {
    int n;
    cin >> n;
    while(n--) {
        int m;
        cin >> m;

        // 存储所有条件
        int a[105], b[105], c[105], d[105];
        char answer[105];

        for(int i = 0; i < m; i++) {
            cin >> a[i] >> b[i] >> c[i] >> d[i] >> answer[i];
        }

        int validCount = 0;
        int resultMonth = 0, resultDay = 0;

        // 枚举1月1日到12月31日的每一天
        for(int month = 1; month <= 12; month++) {
            for(int day = 1; day <= daysInMonth[month]; day++) {
                bool valid = true;

                // 检查当前日期是否满足所有条件
                for(int i = 0; i < m; i++) {
                    bool isInRange = inRange(month, day, a[i], b[i], c[i], d[i]);

                    // 如果回答是Y，但不在范围内，矛盾
                    if(answer[i] == 'Y' && !isInRange) {
                        valid = false;
                        break;
                    }
                    // 如果回答是N，但在范围内，矛盾
                    if(answer[i] == 'N' && isInRange) {
                        valid = false;
                        break;
                    }
                }

                if(valid) {
                    validCount++;
                    resultMonth = month;
                    resultDay = day;

                    // 优化：如果已经找到超过1个答案，可以提前结束
                    if(validCount > 1) {
                        break;
                    }
                }
            }
            if(validCount > 1) break;
        }

        if(validCount == 0) {
            cout << "-1" << endl;
        } else if(validCount == 1) {
            cout << resultMonth << " " << resultDay << endl;
        } else {
            cout << ">1" << endl;
        }
    }
    return 0;
}

\`\`\`

**解析**：

1. **题目理解**
    1. **给定 m 个同学的猜测范围和 Tql 的回答（Y 表示在范围内，N 表示不在范围内）**
    2. **需要根据所有条件，确定唯一的校庆日期**
    3. **三种输出情况： **
        * **唯一解：输出月份和日期**
        * **多解：输出">1"**
        * **无解：输出"-1"**
2. **算法思路**
    1. **枚举所有可能的日期**：从 1 月 1 日到 12 月 31 日（共 365 天，非闰年）
    2. **逐个验证**：对每个日期，检查是否满足所有 m 个条件
    3. **条件验证**：
        * **如果回答是 Y，该日期必须在范围内**
        * **如果回答是 N，该日期必须不在范围内**
    4. **统计结果**：
        * **记录满足所有条件的日期数量**
        * **如果恰好 1 个，输出该日期**
        * **如果 0 个，输出 -1**
        * **如果大于 1 个，输出>1**
3. **核心函数：inRange**
    1. **功能**：判断日期（m1 月 d1 日）是否在范围[a 月 b 日， c 月 d 日]内
    2. **实现方法**：将日期转换为"年内第几天"进行比较
    3. **转换逻辑**：
        * **累加该月之前所有月份的天数**
        * **加上当月的日期数**
    4. **比较逻辑**：date1 >= dateA && date1 <= dateC
4. **代码实现细节**
    1. **月份天数数组**：
        * \`daysInMonth[1~12]\` 存储每月天数
        * **索引 0 不使用，方便从 1 开始计数**
        * **简化处理：1921 年不是闰年，2 月固定 28 天**
    2. **存储条件**：
        * **使用数组存储所有同学的猜测范围和回答**
        * \`a[i], b[i], c[i], d[i]\`：第 i 个同学的范围
        * \`answer[i]\`：第 i 个同学得到的回答（'Y'或'N'）
    3. **枚举验证**：
        * **外层循环：枚举月份（1-12）**
        * **内层循环：枚举该月的每一天（1-daysInMonth[month]）**
        * **最内层循环：检查所有 m 个条件**
    4. **提前终止优化**：
        * **如果已经找到超过 1 个答案，可以立即终止搜索**
5. **变量说明**
    1. \`n\`：测试用例数量
    2. \`m\`：同学数量（条件数量）
    3. \`a[i], b[i], c[i], d[i]\`：第 i 个条件的日期范围
    4. \`answer[i]\`：第 i 个条件的回答（'Y'或'N'）
    5. \`validCount\`：满足所有条件的日期数量
    6. \`resultMonth, resultDay\`：记录找到的有效日期
6. **时间复杂度分析**
    1. **外层：枚举 365 天**
    2. **中层：检查 m 个条件（m≤100）**
    3. **内层：日期比较需要累加月份天数（最多 12 次）**
    4. **总时间复杂度：**O（365 \\times m \\times 12） = O（4380m）
    5. **对于 m≤100，约 44 万次运算，完全可以通过**
7. **样例验证**
    1. **样例 1：**
        * **条件 1：4 月 6 日到 4 月 9 日，回答 Y（校庆在这个范围）**
        * **条件 2：4 月 7 日到 4 月 9 日，回答 N（校庆不在这个范围）**
        * **分析：必须在[4.6-4.9]但不在[4.7-4.9]，只有 4 月 6 日满足**
        * **输出：4 6 ✓**
    2. **样例 2：**
        * **条件 1：4 月 6 日到 4 月 9 日，回答 Y**
        * **条件 2：4 月 7 日到 4 月 9 日，回答 Y**
        * **分析：必须同时在两个范围内，交集是[4.7-4.9]，共 3 天**
        * **输出：>1 ✓**
    3. **样例 3：**
        * **条件 1：4 月 6 日到 4 月 9 日，回答 Y**
        * **条件 2：4 月 7 日到 4 月 9 日，回答 Y**
        * **条件 3：2 月 28 日到 3 月 1 日，回答 Y**
        * **分析：前两个条件要求在 4 月，第三个条件要求在 2 月底或 3 月初，矛盾**
        * **输出：-1 ✓**
8. **注意事项**
    1. **闰年处理**：题目提到 1921 年，非闰年，2 月 28 天即可
    2. **日期比较**：将日期转换为"年内第几天"便于比较大小
    3. **边界情况**：
        * **跨月范围：如 2 月 28 日到 3 月 1 日**
        * **单日范围：如 4 月 6 日到 4 月 6 日**
    4. **字符读取**：answer[i]读取'Y'或'N'字符
    5. **输出格式**：
        * **唯一解：月份和日期用空格分隔**
        * **多解：输出字符串">1"（注意是大于号）**
        * **无解：输出"-1"**
9. **算法优点**
    1. **暴力枚举简单可靠**：逻辑清晰，不易出错
    2. **数据量小**：只需枚举 365 天，计算量完全可接受
    3. **易于调试**：可以逐个检查每个日期的验证过程
10. **可能的陷阱**
    1. **日期范围判断**：必须正确处理跨月的情况
    2. **条件逻辑**：Y 和 N 的判断不能弄反
    3. **输出格式**：">1"是字符串，不是数字
    4. **数组越界**：daysInMonth 数组从索引 1 开始使用
`
  },
"3322": {
    id: "3322",
    title: "最大分差",
    content: `
> https://www.xujcoj.com/home/problem/detail/3322

**答案：**

\`\`\`cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    int maxScore = 0;    // 最高分
    int minScore = 100;  // 最低分

    for(int i = 0; i < n; i++) {
        int score;
        cin >> score;

        // 更新最高分
        if(score > maxScore) {
            maxScore = score;
        }

        // 更新最低分
        if(score < minScore) {
            minScore = score;
        }
    }

    // 最大分差 = 最高分 - 最低分
    int diff = maxScore - minScore;

    cout << diff;

    return 0;
}

\`\`\`

**解析：**

1. **题目理解**

    - 给定n个学生的成绩
    - 求成绩差距最大的两个学生的分差
    - **关键**：最大分差 = 最高分 - 最低分

2. **核心思路**

    - 找出所有成绩中的**最高分**
    - 找出所有成绩中的**最低分**
    - 计算差值：**maxScore - minScore**

3. **为什么是最高分减最低分**

    - 分差 = |分数1 - 分数2|
    - 要使分差最大，应该选择相差最大的两个数
    - 数组中相差最大的两个数必然是最大值和最小值
    - 因此：最大分差 = max - min

4. **初始化技巧**

\`\`\`cpp
int maxScore = 0;    // 最高分初始化为0（成绩最小值）
int minScore = 100;  // 最低分初始化为100（成绩最大值）

\`\`\`

    - **maxScore初始化为0**：因为成绩范围[0,100]，任何成绩都≥0
    - **minScore初始化为100**：因为任何成绩都≤100
    - 这样第一个数就能正确更新

5. **更新最值的逻辑**

\`\`\`cpp
if(score > maxScore) {
maxScore = score;  // 找到更大的，更新最高分
}

if(score < minScore) {
minScore = score;  // 找到更小的，更新最低分
}

\`\`\`

6. **样例验证**

    - **输入：5个成绩：40 100 80 90 65**

\`\`\`
初始：maxScore=0, minScore=100

i=0: score=40
40 > 0 → maxScore=40
40 < 100 → minScore=40

i=1: score=100
100 > 40 → maxScore=100
100 ≮ 40 → minScore=40

i=2: score=80
80 ≯ 100 → maxScore=100
80 ≮ 40 → minScore=40

i=3: score=90
90 ≯ 100 → maxScore=100
90 ≮ 40 → minScore=40

i=4: score=65
65 ≯ 100 → maxScore=100
65 ≮ 40 → minScore=40

最终：maxScore=100, minScore=40
分差：100 - 40 = 60 ✓

\`\`\`

7. **变量说明**

    - \`n\`：学生数量
    - \`maxScore\`：当前遇到的最高分
    - \`minScore\`：当前遇到的最低分
    - \`score\`：当前读入的成绩
    - \`diff\`：最大分差

8. **时间复杂度分析**

    - 遍历n个成绩：O(n)
    - 每次比较更新：O(1)
    - 总时间复杂度：O(n)

9. **空间复杂度分析**

    - 只使用几个变量
    - 空间复杂度：O(1)

10. **更多测试用例**

    - **测试1：全部相同**
        - 输入：3个成绩：50 50 50
        - maxScore=50, minScore=50
        - 输出：0
    - **测试2：只有两个学生**
        - 输入：2个成绩：30 90
        - maxScore=90, minScore=30
        - 输出：60
    - **测试3：包含0分和100分**
        - 输入：4个成绩：0 50 75 100
        - maxScore=100, minScore=0
        - 输出：100
    - **测试4：递增序列**
        - 输入：5个成绩：10 20 30 40 50
        - maxScore=50, minScore=10
        - 输出：40

11. **为什么不需要存储所有成绩**

    - 只需要最大值和最小值
    - 不需要知道是哪个学生
    - 边读边更新，节省空间

12. **替代方法：使用数组**

\`\`\`cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
int n;
cin >> n;

int scores[100];
for(int i = 0; i < n; i++) {
    cin >> scores[i];
}

// 找最大值和最小值
int maxScore = *max_element(scores, scores + n);
int minScore = *min_element(scores, scores + n);

cout << maxScore - minScore;

return 0;
}

\`\`\`

    - 使用STL的max_element和min_element函数
    - 需要存储所有成绩
    - 空间复杂度：O(n)

13. **替代方法：排序**

\`\`\`cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
int n;
cin >> n;

int scores[100];
for(int i = 0; i < n; i++) {
    cin >> scores[i];
}

// 排序
sort(scores, scores + n);

// 最大分差 = 最后一个 - 第一个
cout << scores[n-1] - scores[0];

return 0;
}

\`\`\`

    - 排序后，第一个是最小值，最后一个是最大值
    - 时间复杂度：O(n log n)
    - 比直接找最值慢

14. **方法对比**

    | 方法         | 时间复杂度 | 空间复杂度 | 优点           | 缺点         |
    | ------------ | ---------- | ---------- | -------------- | ------------ |
    | 边读边更新   | O(n)       | O(1)       | 最快，最省空间 | 无           |
    | 使用数组+STL | O(n)       | O(n)       | 代码简洁       | 需要额外空间 |
    | 排序         | O(n log n) | O(n)       | 思路直观       | 较慢，浪费   |

15. **初始化的其他方法**

\`\`\`cpp
// 方法1：使用第一个数初始化
int maxScore, minScore;
cin >> maxScore;
minScore = maxScore;

for(int i = 1; i < n; i++) {  // 从第2个开始
int score;
cin >> score;
// 更新最值...
}

// 方法2：使用极值初始化
int maxScore = -1;      // 或 INT_MIN
int minScore = 101;     // 或 INT_MAX

// 方法3：使用题目范围初始化（推荐）
int maxScore = 0;       // 成绩最小值
int minScore = 100;     // 成绩最大值

\`\`\`

16. **注意事项**

    - **输出格式**：不要换行（题目明确要求）
    - **初始化**：maxScore初始化为最小可能值，minScore初始化为最大可能值
    - **边界情况**：
        - n=2时，就是两个数的差
        - 所有成绩相同时，输出0
    - **数据范围**：成绩[0,100]，使用int即可

17. **完整的算法流程**

\`\`\`
1. 读入学生数量n
2. 初始化maxScore=0, minScore=100
3. 循环n次：
a. 读入一个成绩score
b. 如果score > maxScore，更新maxScore
c. 如果score < minScore，更新minScore
4. 计算diff = maxScore - minScore
5. 输出diff（不换行）

\`\`\`

18. **数学原理**

    - 对于任意两个数a和b，|a-b|表示它们的差
    - 在一组数中，要使|a-b|最大：
        - a应该取最大值
        - b应该取最小值
        - 或反之
    - 因此：max_diff = max(数组) - min(数组)

19. **边界情况处理**

    - **所有学生同分**：
        - max = min
        - diff = 0
    - **只有两个学生**：
        - 就是这两个人的分差
    - **包含0分**：
        - 0是合法成绩
        - 正常处理
    - **包含100分**：
        - 100是最高分
        - 正常处理

20. **常见错误**

    - ❌ 初始化maxScore=100, minScore=0（反了）
    - ❌ 比较时写成 >= 或 <=（导致不更新）
    - ❌ 忘记输出不换行
    - ❌ 计算差值时写成minScore - maxScore（负数）
    - ❌ 尝试枚举所有配对求最大差（O(n²)，浪费）
    - ✓ 一次遍历找最大最小值，相减即可

21. **优化说明**

    - 本算法已经是最优解
    - 时间：O(n)，必须读完所有数据
    - 空间：O(1)，只用常数个变量
    - 无需进一步优化

22. **扩展思考**

    - 如果要求输出是哪两个学生？
        - 需要记录最大值和最小值的索引
    - 如果要求第二大的分差？
        - 需要找第二大和第二小的值
        - 或最大与第二小、第二大与最小中的较大者
    - 如果成绩可以重复且要求不同学生？
        - 仍然是最大减最小
        - 因为最大和最小必然来自不同位置

这道题是一个经典的"在一组数中找最大值和最小值"的问题，关键是理解**最大分差一定等于最高分减最低分**这个数学事实。`,
    answers: [
      {
        label: "参考答案 1",
        content: `
> https://www.xujcoj.com/home/problem/detail/3322

**答案：**

\`\`\`cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    int maxScore = 0;    // 最高分
    int minScore = 100;  // 最低分

    for(int i = 0; i < n; i++) {
        int score;
        cin >> score;

        // 更新最高分
        if(score > maxScore) {
            maxScore = score;
        }

        // 更新最低分
        if(score < minScore) {
            minScore = score;
        }
    }

    // 最大分差 = 最高分 - 最低分
    int diff = maxScore - minScore;

    cout << diff;

    return 0;
}

\`\`\`

**解析：**

1. **题目理解**

    - 给定n个学生的成绩
    - 求成绩差距最大的两个学生的分差
    - **关键**：最大分差 = 最高分 - 最低分

2. **核心思路**

    - 找出所有成绩中的**最高分**
    - 找出所有成绩中的**最低分**
    - 计算差值：**maxScore - minScore**

3. **为什么是最高分减最低分**

    - 分差 = |分数1 - 分数2|
    - 要使分差最大，应该选择相差最大的两个数
    - 数组中相差最大的两个数必然是最大值和最小值
    - 因此：最大分差 = max - min

4. **初始化技巧**

    \`\`\`cpp
int maxScore = 0;    // 最高分初始化为0（成绩最小值）
int minScore = 100;  // 最低分初始化为100（成绩最大值）

\`\`\`

    - **maxScore初始化为0**：因为成绩范围[0,100]，任何成绩都≥0
    - **minScore初始化为100**：因为任何成绩都≤100
    - 这样第一个数就能正确更新

5. **更新最值的逻辑**

    \`\`\`cpp
if(score > maxScore) {
    maxScore = score;  // 找到更大的，更新最高分
}

if(score < minScore) {
    minScore = score;  // 找到更小的，更新最低分
}

\`\`\`

6. **样例验证**

    - **输入：5个成绩：40 100 80 90 65**

    \`\`\`
初始：maxScore=0, minScore=100

i=0: score=40
40 > 0 → maxScore=40
40 < 100 → minScore=40

i=1: score=100
100 > 40 → maxScore=100
100 ≮ 40 → minScore=40

i=2: score=80
80 ≯ 100 → maxScore=100
80 ≮ 40 → minScore=40

i=3: score=90
90 ≯ 100 → maxScore=100
90 ≮ 40 → minScore=40

i=4: score=65
65 ≯ 100 → maxScore=100
65 ≮ 40 → minScore=40

最终：maxScore=100, minScore=40
分差：100 - 40 = 60 ✓

\`\`\`

7. **变量说明**

    - \`n\`：学生数量
    - \`maxScore\`：当前遇到的最高分
    - \`minScore\`：当前遇到的最低分
    - \`score\`：当前读入的成绩
    - \`diff\`：最大分差

8. **时间复杂度分析**

    - 遍历n个成绩：O(n)
    - 每次比较更新：O(1)
    - 总时间复杂度：O(n)

9. **空间复杂度分析**

    - 只使用几个变量
    - 空间复杂度：O(1)

10. **更多测试用例**

    - **测试1：全部相同**
        - 输入：3个成绩：50 50 50
        - maxScore=50, minScore=50
        - 输出：0
    - **测试2：只有两个学生**
        - 输入：2个成绩：30 90
        - maxScore=90, minScore=30
        - 输出：60
    - **测试3：包含0分和100分**
        - 输入：4个成绩：0 50 75 100
        - maxScore=100, minScore=0
        - 输出：100
    - **测试4：递增序列**
        - 输入：5个成绩：10 20 30 40 50
        - maxScore=50, minScore=10
        - 输出：40

11. **为什么不需要存储所有成绩**

    - 只需要最大值和最小值
    - 不需要知道是哪个学生
    - 边读边更新，节省空间

12. **替代方法：使用数组**

    \`\`\`cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int n;
    cin >> n;

    int scores[100];
    for(int i = 0; i < n; i++) {
        cin >> scores[i];
    }

    // 找最大值和最小值
    int maxScore = *max_element(scores, scores + n);
    int minScore = *min_element(scores, scores + n);

    cout << maxScore - minScore;

    return 0;
}

\`\`\`

    - 使用STL的max_element和min_element函数
    - 需要存储所有成绩
    - 空间复杂度：O(n)

13. **替代方法：排序**

    \`\`\`cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int n;
    cin >> n;

    int scores[100];
    for(int i = 0; i < n; i++) {
        cin >> scores[i];
    }

    // 排序
    sort(scores, scores + n);

    // 最大分差 = 最后一个 - 第一个
    cout << scores[n-1] - scores[0];

    return 0;
}

\`\`\`

    - 排序后，第一个是最小值，最后一个是最大值
    - 时间复杂度：O(n log n)
    - 比直接找最值慢

14. **方法对比**

    | 方法         | 时间复杂度 | 空间复杂度 | 优点           | 缺点         |
    | ------------ | ---------- | ---------- | -------------- | ------------ |
    | 边读边更新   | O(n)       | O(1)       | 最快，最省空间 | 无           |
    | 使用数组+STL | O(n)       | O(n)       | 代码简洁       | 需要额外空间 |
    | 排序         | O(n log n) | O(n)       | 思路直观       | 较慢，浪费   |

15. **初始化的其他方法**

    \`\`\`cpp
// 方法1：使用第一个数初始化
int maxScore, minScore;
cin >> maxScore;
minScore = maxScore;

for(int i = 1; i < n; i++) {  // 从第2个开始
    int score;
    cin >> score;
    // 更新最值...
}

// 方法2：使用极值初始化
int maxScore = -1;      // 或 INT_MIN
int minScore = 101;     // 或 INT_MAX

// 方法3：使用题目范围初始化（推荐）
int maxScore = 0;       // 成绩最小值
int minScore = 100;     // 成绩最大值

\`\`\`

16. **注意事项**

    - **输出格式**：不要换行（题目明确要求）
    - **初始化**：maxScore初始化为最小可能值，minScore初始化为最大可能值
    - **边界情况**：
        - n=2时，就是两个数的差
        - 所有成绩相同时，输出0
    - **数据范围**：成绩[0,100]，使用int即可

17. **完整的算法流程**

    \`\`\`
1. 读入学生数量n
2. 初始化maxScore=0, minScore=100
3. 循环n次：
a. 读入一个成绩score
b. 如果score > maxScore，更新maxScore
c. 如果score < minScore，更新minScore
4. 计算diff = maxScore - minScore
5. 输出diff（不换行）

\`\`\`

18. **数学原理**

    - 对于任意两个数a和b，|a-b|表示它们的差
    - 在一组数中，要使|a-b|最大：
        - a应该取最大值
        - b应该取最小值
        - 或反之
    - 因此：max_diff = max(数组) - min(数组)

19. **边界情况处理**

    - **所有学生同分**：
        - max = min
        - diff = 0
    - **只有两个学生**：
        - 就是这两个人的分差
    - **包含0分**：
        - 0是合法成绩
        - 正常处理
    - **包含100分**：
        - 100是最高分
        - 正常处理

20. **常见错误**

    - ❌ 初始化maxScore=100, minScore=0（反了）
    - ❌ 比较时写成 >= 或 <=（导致不更新）
    - ❌ 忘记输出不换行
    - ❌ 计算差值时写成minScore - maxScore（负数）
    - ❌ 尝试枚举所有配对求最大差（O(n²)，浪费）
    - ✓ 一次遍历找最大最小值，相减即可

21. **优化说明**

    - 本算法已经是最优解
    - 时间：O(n)，必须读完所有数据
    - 空间：O(1)，只用常数个变量
    - 无需进一步优化

22. **扩展思考**

    - 如果要求输出是哪两个学生？
        - 需要记录最大值和最小值的索引
    - 如果要求第二大的分差？
        - 需要找第二大和第二小的值
        - 或最大与第二小、第二大与最小中的较大者
    - 如果成绩可以重复且要求不同学生？
        - 仍然是最大减最小
        - 因为最大和最小必然来自不同位置

这道题是一个经典的"在一组数中找最大值和最小值"的问题，关键是理解**最大分差一定等于最高分减最低分**这个数学事实。`
      },
      {
        label: "参考答案 (使用数组)",
        content: `### 替代方法：使用数组

\`\`\`cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int n;
    cin >> n;

    int scores[100];
    for(int i = 0; i < n; i++) {
        cin >> scores[i];
    }

    // 找最大值和最小值
    int maxScore = *max_element(scores, scores + n);
    int minScore = *min_element(scores, scores + n);

    cout << maxScore - minScore;

    return 0;
}

\`\`\`

    - 使用STL的max_element和min_element函数
    - 需要存储所有成绩
    - 空间复杂度：O(n)`
      },
      {
        label: "参考答案 (排序)",
        content: `### 替代方法：排序

\`\`\`cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int n;
    cin >> n;

    int scores[100];
    for(int i = 0; i < n; i++) {
        cin >> scores[i];
    }

    // 排序
    sort(scores, scores + n);

    // 最大分差 = 最后一个 - 第一个
    cout << scores[n-1] - scores[0];

    return 0;
}

\`\`\`

    - 排序后，第一个是最小值，最后一个是最大值
    - 时间复杂度：O(n log n)
    - 比直接找最值慢`
      },
    ]
  },
"3429": {
    id: "3429",
    title: "公共质因数的和",
    content: `
> [https://www.xujcoj.com/home/problem/detail/3429](https://www.xujcoj.com/home/problem/detail/3429)

**答案：**

\`\`\`
#include <iostream>
using namespace std;

// 计算最大公约数
long long gcd(long long a, long long b) {
    while(b != 0) {
        long long temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

// 计算n的所有质因数之和
int sumOfPrimeFactors(long long n) {
    int sum = 0;

    // 处理因子2
    if(n % 2 == 0) {
        sum += 2;
        while(n % 2 == 0) {
            n /= 2;
        }
    }

    // 处理奇数因子，从3开始
    for(long long i = 3; i * i <= n; i += 2) {
        if(n % i == 0) {
            sum += i;
            while(n % i == 0) {
                n /= i;
            }
        }
    }

    // 如果n>1，说明n本身是一个质数
    if(n > 1) {
        sum += n;
    }

    return sum;
}

int main() {
    int n;
    cin >> n;
    while(n--) {
        long long a, b;
        cin >> a >> b;

        // a和b的公共质因数 = gcd(a,b)的质因数
        long long g = gcd(a, b);
        int result = sumOfPrimeFactors(g);

        cout << result << endl;
    }
    return 0;
}

\`\`\`

**解析：**

**代码已经移除了 **\`<algorithm>\` 头文件。原代码中实际上也没有使用 \`<algorithm>\` 中的任何函数（如 \`sort\`、\`min\`、\`max\` 等），所以直接删除即可。

**主要功能模块：**

1. **GCD****函数**（辗转相除法）
    1. **不依赖任何标准库函数**
    2. **纯粹的数学算法实现**
2. **质因数分解函数**
    1. **只使用基本的算术运算**
    2. **不需要任何额外的头文件**
3. **主函数**
    1. **使用 **\`<iostream>\` 进行输入输出
    2. **这是必需的，无法去除**

**代码特点：**

* **✓ 不包含 **\`<algorithm>\` 头文件
* **✓ 只使用 **\`<iostream>\` 进行基本 I/O
* **✓ 所有算法都是手写实现**
* **✓ 不依赖任何 STL 容器或算法函数**

**样例验证：**

* **输入：10 15**
    * **gcd(10,15) = 5**
    * **5 的质因数：5**
    * **输出：5 ✓**
* **输入：36 48**
    * **gcd(36,48) = 12**
    * **12 = 2² × 3**
    * **质因数：2， 3**
    * **输出：2+3=5 ✓**
`
  },
"3518": {
    id: "3518",
    title: "递增数列",
    content: `
> [https://www.xujcoj.com/home/problem/detail/3518](https://www.xujcoj.com/home/problem/detail/3518)

**答案：**

\`\`\`
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    while(n--) {
        int a;
        cin >> a;

        int prev;
        cin >> prev;  // 读入第一项

        bool isIncreasing = true;

        // 从第二项开始检查
        for(int i = 1; i < a; i++) {
            int current;
            cin >> current;

            if(current < prev) {
                isIncreasing = false;
            }

            prev = current;
        }

        if(isIncreasing) {
            cout << "Yes" << endl;
        } else {
            cout << "No" << endl;
        }
    }
    return 0;
}

\`\`\`

**解析：**

1. **题目理解**
    1. **递增数列定义**：从第 2 项起，每一项的值 ≥ 前一项的值
    2. **注意：是"不小于"（≥），不是"大于"（>）**
    3. **允许相邻元素相等，如 1，2，2，4，5 是递增数列**
    4. **只要有一对相邻元素满足"后 < 前"，就不是递增数列**
2. **算法思路**
    1. **边读边判断**：不需要存储整个数组
    2. **逐对比较**：比较相邻的两个元素
    3. **提前标记**：一旦发现不满足条件，标记为 false
    4. **空间优化**：只需保存前一个元素，不需要数组
3. **核心逻辑**

\`\`\`
读入第一项作为prev
for 第2项到第a项:
读入current
if current < prev:
不是递增数列
prev = current  // 更新prev

\`\`\`

1. **为什么不需要数组**
    1. **只需比较相邻元素**
    2. **用一个变量 **\`prev\` 保存前一个元素即可
    3. **空间复杂度**：O（1） 而不是 O（a）
    4. **特别重要**：题目说 a×n ≤ 3×10⁶，如果每组都存数组可能内存不够
2. **代码实现细节**
    1. **变量说明**：
        * \`prev\`：前一个元素的值
        * \`current\`：当前读入的元素的值
        * \`isIncreasing\`：标志位，记录是否递增
    2. **读入策略**：
        * **先读入第一项到 **\`prev\`
        * **循环从第二项开始，共读入 a-1 次**
    3. **判断条件**：
        * \`current < prev\` 表示不递增
        * **注意：**\`current == prev\` 是允许的
3. **变量说明**
    1. \`n\`：案例数量
    2. \`a\`：当前案例的数列项数
    3. \`prev\`：前一个元素
    4. \`current\`：当前元素
    5. \`isIncreasing\`：是否为递增数列的标志
4. **时间复杂度分析**
    1. **每组案例：O（a），需要读入并比较 a 个数**
    2. **总时间复杂度：O（总元素个数） = O（a×n） ≤ O（3×10⁶）**
    3. **时间限制 4 秒，完全可以通过**
5. **空间复杂度分析**
    1. **只使用常数个变量**
    2. **空间复杂度：O（1）**
    3. **不需要存储整个数组**
6. **样例验证**
    1. **样例 1：1 2 2 4 5**
        * **prev=1, current=2: 2≥1 ✓**
        * **prev=2， current=2: 2≥2 ✓ （相等也可以）**
        * **prev=2, current=4: 4≥2 ✓**
        * **prev=4, current=5: 5≥4 ✓**
        * **全部满足，输出：Yes ✓**
    2. **样例 2：1 2 4 3**
        * **prev=1, current=2: 2≥1 ✓**
        * **prev=2, current=4: 4≥2 ✓**
        * **prev=4, current=3: 3<4 ✗**
        * **发现不满足，输出：No ✓**
7. **注意事项**
    1. **边界情况**：
        * **a=1：只有一个元素，算递增数列（没有第 2 项需要比较）**
        * **所有元素相等：如 3，3，3，3，是递增数列**
    2. **判断条件**：
        * **用 **\`<\` 判断违反递增条件
        * **不要用 **\`<=\`，因为相等是允许的
    3. **及时更新 prev**：
        * **每次读入新元素后，要更新 **\`prev = current\`
        * **即使发现不递增也要继续读完所有数据**
    4. **为什么即使发现 false 也要读完**：
        * **输入流需要保持同步**
        * **否则会影响下一组案例的读入**
8. **优化：可以提前终止吗？**
    1. **理论上可以**：发现不递增后不再判断
    2. **实际上不行**：必须读完所有输入数据
    3. **原因**：输入流中还有剩余数据，会影响下一组案例
    4. **解决方案**：继续读完，但不再更新判断结果
9. **更详细的实现（带提前发现优化）** 虽然当前代码已经足够好，但如果想略微优化：

\`\`\`
for(int i = 1; i < a; i++) {
    int current;
    cin >> current;

    if(isIncreasing && current < prev) {
        isIncreasing = false;
    }

    prev = current;
}

\`\`\`

1. **完整的算法流程**

\`\`\`
1. 读入案例数量n
2. 对每组案例：
a. 读入数列长度a
b. 读入第一个元素prev
c. 设置isIncreasing = true
d. 循环读入剩余a-1个元素：
- 读入current
- 如果current < prev，设置isIncreasing = false
- 更新prev = current
e. 根据isIncreasing输出Yes或No

\`\`\`

1. **为什么这题时间限制是 4 秒**
    1. **数据规模大：a×n ≤ 3×10⁶**
    2. **需要处理大量输入**
    3. **4 秒的时间限制给了足够的缓冲**
    4. **我们的 O（总元素数）算法完全足够**
2. **可能的错误**
    1. **❌ 忘记更新 prev**
    2. **❌ 使用 **\`<=\` 而不是 \`<\` 判断
    3. **❌ 只读入一部分数据就输出结果**
    4. **❌ 使用数组存储导致内存不足**
    5. **✓ 边读边判断，只用 O（1）空间**

**这道题是一个很好的"流式处理"例子，展示了如何在不存储所有数据的情况下完成判断，既节省内存又提高效率。**
`
  }
};
